var Sd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ph = { exports: {} }, we = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Za = Symbol.for("react.element"), P2 = Symbol.for("react.portal"), B2 = Symbol.for("react.fragment"), F2 = Symbol.for("react.strict_mode"), U2 = Symbol.for("react.profiler"), $2 = Symbol.for("react.provider"), H2 = Symbol.for("react.context"), q2 = Symbol.for("react.forward_ref"), G2 = Symbol.for("react.suspense"), V2 = Symbol.for("react.memo"), W2 = Symbol.for("react.lazy"), _d = Symbol.iterator;
function K2(e) {
  return e === null || typeof e != "object" ? null : (e = _d && e[_d] || e["@@iterator"], typeof e == "function" ? e : null);
}
var Bh = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, Fh = Object.assign, Uh = {};
function Hi(e, t, n) {
  this.props = e, this.context = t, this.refs = Uh, this.updater = n || Bh;
}
Hi.prototype.isReactComponent = {};
Hi.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState");
};
Hi.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function $h() {
}
$h.prototype = Hi.prototype;
function $u(e, t, n) {
  this.props = e, this.context = t, this.refs = Uh, this.updater = n || Bh;
}
var Hu = $u.prototype = new $h();
Hu.constructor = $u;
Fh(Hu, Hi.prototype);
Hu.isPureReactComponent = !0;
var Td = Array.isArray, Hh = Object.prototype.hasOwnProperty, qu = { current: null }, qh = { key: !0, ref: !0, __self: !0, __source: !0 };
function Gh(e, t, n) {
  var r, i = {}, a = null, l = null;
  if (t != null) for (r in t.ref !== void 0 && (l = t.ref), t.key !== void 0 && (a = "" + t.key), t) Hh.call(t, r) && !qh.hasOwnProperty(r) && (i[r] = t[r]);
  var o = arguments.length - 2;
  if (o === 1) i.children = n;
  else if (1 < o) {
    for (var s = Array(o), u = 0; u < o; u++) s[u] = arguments[u + 2];
    i.children = s;
  }
  if (e && e.defaultProps) for (r in o = e.defaultProps, o) i[r] === void 0 && (i[r] = o[r]);
  return { $$typeof: Za, type: e, key: a, ref: l, props: i, _owner: qu.current };
}
function Y2(e, t) {
  return { $$typeof: Za, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };
}
function Gu(e) {
  return typeof e == "object" && e !== null && e.$$typeof === Za;
}
function j2(e) {
  var t = { "=": "=0", ":": "=2" };
  return "$" + e.replace(/[=:]/g, function(n) {
    return t[n];
  });
}
var Nd = /\/+/g;
function xs(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? j2("" + e.key) : t.toString(36);
}
function Vl(e, t, n, r, i) {
  var a = typeof e;
  (a === "undefined" || a === "boolean") && (e = null);
  var l = !1;
  if (e === null) l = !0;
  else switch (a) {
    case "string":
    case "number":
      l = !0;
      break;
    case "object":
      switch (e.$$typeof) {
        case Za:
        case P2:
          l = !0;
      }
  }
  if (l) return l = e, i = i(l), e = r === "" ? "." + xs(l, 0) : r, Td(i) ? (n = "", e != null && (n = e.replace(Nd, "$&/") + "/"), Vl(i, t, n, "", function(u) {
    return u;
  })) : i != null && (Gu(i) && (i = Y2(i, n + (!i.key || l && l.key === i.key ? "" : ("" + i.key).replace(Nd, "$&/") + "/") + e)), t.push(i)), 1;
  if (l = 0, r = r === "" ? "." : r + ":", Td(e)) for (var o = 0; o < e.length; o++) {
    a = e[o];
    var s = r + xs(a, o);
    l += Vl(a, t, n, s, i);
  }
  else if (s = K2(e), typeof s == "function") for (e = s.call(e), o = 0; !(a = e.next()).done; ) a = a.value, s = r + xs(a, o++), l += Vl(a, t, n, s, i);
  else if (a === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return l;
}
function ul(e, t, n) {
  if (e == null) return e;
  var r = [], i = 0;
  return Vl(e, r, "", "", function(a) {
    return t.call(n, a, i++);
  }), r;
}
function X2(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(function(n) {
      (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n);
    }, function(n) {
      (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n);
    }), e._status === -1 && (e._status = 0, e._result = t);
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var St = { current: null }, Wl = { transition: null }, Z2 = { ReactCurrentDispatcher: St, ReactCurrentBatchConfig: Wl, ReactCurrentOwner: qu };
function Vh() {
  throw Error("act(...) is not supported in production builds of React.");
}
we.Children = { map: ul, forEach: function(e, t, n) {
  ul(e, function() {
    t.apply(this, arguments);
  }, n);
}, count: function(e) {
  var t = 0;
  return ul(e, function() {
    t++;
  }), t;
}, toArray: function(e) {
  return ul(e, function(t) {
    return t;
  }) || [];
}, only: function(e) {
  if (!Gu(e)) throw Error("React.Children.only expected to receive a single React element child.");
  return e;
} };
we.Component = Hi;
we.Fragment = B2;
we.Profiler = U2;
we.PureComponent = $u;
we.StrictMode = F2;
we.Suspense = G2;
we.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Z2;
we.act = Vh;
we.cloneElement = function(e, t, n) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var r = Fh({}, e.props), i = e.key, a = e.ref, l = e._owner;
  if (t != null) {
    if (t.ref !== void 0 && (a = t.ref, l = qu.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var o = e.type.defaultProps;
    for (s in t) Hh.call(t, s) && !qh.hasOwnProperty(s) && (r[s] = t[s] === void 0 && o !== void 0 ? o[s] : t[s]);
  }
  var s = arguments.length - 2;
  if (s === 1) r.children = n;
  else if (1 < s) {
    o = Array(s);
    for (var u = 0; u < s; u++) o[u] = arguments[u + 2];
    r.children = o;
  }
  return { $$typeof: Za, type: e.type, key: i, ref: a, props: r, _owner: l };
};
we.createContext = function(e) {
  return e = { $$typeof: H2, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: $2, _context: e }, e.Consumer = e;
};
we.createElement = Gh;
we.createFactory = function(e) {
  var t = Gh.bind(null, e);
  return t.type = e, t;
};
we.createRef = function() {
  return { current: null };
};
we.forwardRef = function(e) {
  return { $$typeof: q2, render: e };
};
we.isValidElement = Gu;
we.lazy = function(e) {
  return { $$typeof: W2, _payload: { _status: -1, _result: e }, _init: X2 };
};
we.memo = function(e, t) {
  return { $$typeof: V2, type: e, compare: t === void 0 ? null : t };
};
we.startTransition = function(e) {
  var t = Wl.transition;
  Wl.transition = {};
  try {
    e();
  } finally {
    Wl.transition = t;
  }
};
we.unstable_act = Vh;
we.useCallback = function(e, t) {
  return St.current.useCallback(e, t);
};
we.useContext = function(e) {
  return St.current.useContext(e);
};
we.useDebugValue = function() {
};
we.useDeferredValue = function(e) {
  return St.current.useDeferredValue(e);
};
we.useEffect = function(e, t) {
  return St.current.useEffect(e, t);
};
we.useId = function() {
  return St.current.useId();
};
we.useImperativeHandle = function(e, t, n) {
  return St.current.useImperativeHandle(e, t, n);
};
we.useInsertionEffect = function(e, t) {
  return St.current.useInsertionEffect(e, t);
};
we.useLayoutEffect = function(e, t) {
  return St.current.useLayoutEffect(e, t);
};
we.useMemo = function(e, t) {
  return St.current.useMemo(e, t);
};
we.useReducer = function(e, t, n) {
  return St.current.useReducer(e, t, n);
};
we.useRef = function(e) {
  return St.current.useRef(e);
};
we.useState = function(e) {
  return St.current.useState(e);
};
we.useSyncExternalStore = function(e, t, n) {
  return St.current.useSyncExternalStore(e, t, n);
};
we.useTransition = function() {
  return St.current.useTransition();
};
we.version = "18.3.1";
Ph.exports = we;
var xt = Ph.exports, Wh = { exports: {} }, Gt = {}, Kh = { exports: {} }, Yh = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
  function t(I, $) {
    var E = I.length;
    I.push($);
    e: for (; 0 < E; ) {
      var Z = E - 1 >>> 1, ee = I[Z];
      if (0 < i(ee, $)) I[Z] = $, I[E] = ee, E = Z;
      else break e;
    }
  }
  function n(I) {
    return I.length === 0 ? null : I[0];
  }
  function r(I) {
    if (I.length === 0) return null;
    var $ = I[0], E = I.pop();
    if (E !== $) {
      I[0] = E;
      e: for (var Z = 0, ee = I.length, A = ee >>> 1; Z < A; ) {
        var Se = 2 * (Z + 1) - 1, xe = I[Se], he = Se + 1, qe = I[he];
        if (0 > i(xe, E)) he < ee && 0 > i(qe, xe) ? (I[Z] = qe, I[he] = E, Z = he) : (I[Z] = xe, I[Se] = E, Z = Se);
        else if (he < ee && 0 > i(qe, E)) I[Z] = qe, I[he] = E, Z = he;
        else break e;
      }
    }
    return $;
  }
  function i(I, $) {
    var E = I.sortIndex - $.sortIndex;
    return E !== 0 ? E : I.id - $.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var a = performance;
    e.unstable_now = function() {
      return a.now();
    };
  } else {
    var l = Date, o = l.now();
    e.unstable_now = function() {
      return l.now() - o;
    };
  }
  var s = [], u = [], c = 1, d = null, h = 3, p = !1, g = !1, w = !1, S = typeof setTimeout == "function" ? setTimeout : null, y = typeof clearTimeout == "function" ? clearTimeout : null, v = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function x(I) {
    for (var $ = n(u); $ !== null; ) {
      if ($.callback === null) r(u);
      else if ($.startTime <= I) r(u), $.sortIndex = $.expirationTime, t(s, $);
      else break;
      $ = n(u);
    }
  }
  function C(I) {
    if (w = !1, x(I), !g) if (n(s) !== null) g = !0, ge(R);
    else {
      var $ = n(u);
      $ !== null && B(C, $.startTime - I);
    }
  }
  function R(I, $) {
    g = !1, w && (w = !1, y(P), P = -1), p = !0;
    var E = h;
    try {
      for (x($), d = n(s); d !== null && (!(d.expirationTime > $) || I && !V()); ) {
        var Z = d.callback;
        if (typeof Z == "function") {
          d.callback = null, h = d.priorityLevel;
          var ee = Z(d.expirationTime <= $);
          $ = e.unstable_now(), typeof ee == "function" ? d.callback = ee : d === n(s) && r(s), x($);
        } else r(s);
        d = n(s);
      }
      if (d !== null) var A = !0;
      else {
        var Se = n(u);
        Se !== null && B(C, Se.startTime - $), A = !1;
      }
      return A;
    } finally {
      d = null, h = E, p = !1;
    }
  }
  var T = !1, z = null, P = -1, U = 5, O = -1;
  function V() {
    return !(e.unstable_now() - O < U);
  }
  function K() {
    if (z !== null) {
      var I = e.unstable_now();
      O = I;
      var $ = !0;
      try {
        $ = z(!0, I);
      } finally {
        $ ? ae() : (T = !1, z = null);
      }
    } else T = !1;
  }
  var ae;
  if (typeof v == "function") ae = function() {
    v(K);
  };
  else if (typeof MessageChannel < "u") {
    var ie = new MessageChannel(), re = ie.port2;
    ie.port1.onmessage = K, ae = function() {
      re.postMessage(null);
    };
  } else ae = function() {
    S(K, 0);
  };
  function ge(I) {
    z = I, T || (T = !0, ae());
  }
  function B(I, $) {
    P = S(function() {
      I(e.unstable_now());
    }, $);
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
    I.callback = null;
  }, e.unstable_continueExecution = function() {
    g || p || (g = !0, ge(R));
  }, e.unstable_forceFrameRate = function(I) {
    0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : U = 0 < I ? Math.floor(1e3 / I) : 5;
  }, e.unstable_getCurrentPriorityLevel = function() {
    return h;
  }, e.unstable_getFirstCallbackNode = function() {
    return n(s);
  }, e.unstable_next = function(I) {
    switch (h) {
      case 1:
      case 2:
      case 3:
        var $ = 3;
        break;
      default:
        $ = h;
    }
    var E = h;
    h = $;
    try {
      return I();
    } finally {
      h = E;
    }
  }, e.unstable_pauseExecution = function() {
  }, e.unstable_requestPaint = function() {
  }, e.unstable_runWithPriority = function(I, $) {
    switch (I) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        I = 3;
    }
    var E = h;
    h = I;
    try {
      return $();
    } finally {
      h = E;
    }
  }, e.unstable_scheduleCallback = function(I, $, E) {
    var Z = e.unstable_now();
    switch (typeof E == "object" && E !== null ? (E = E.delay, E = typeof E == "number" && 0 < E ? Z + E : Z) : E = Z, I) {
      case 1:
        var ee = -1;
        break;
      case 2:
        ee = 250;
        break;
      case 5:
        ee = 1073741823;
        break;
      case 4:
        ee = 1e4;
        break;
      default:
        ee = 5e3;
    }
    return ee = E + ee, I = { id: c++, callback: $, priorityLevel: I, startTime: E, expirationTime: ee, sortIndex: -1 }, E > Z ? (I.sortIndex = E, t(u, I), n(s) === null && I === n(u) && (w ? (y(P), P = -1) : w = !0, B(C, E - Z))) : (I.sortIndex = ee, t(s, I), g || p || (g = !0, ge(R))), I;
  }, e.unstable_shouldYield = V, e.unstable_wrapCallback = function(I) {
    var $ = h;
    return function() {
      var E = h;
      h = $;
      try {
        return I.apply(this, arguments);
      } finally {
        h = E;
      }
    };
  };
})(Yh);
Kh.exports = Yh;
var Q2 = Kh.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var J2 = xt, qt = Q2;
function W(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var jh = /* @__PURE__ */ new Set(), Na = {};
function Zr(e, t) {
  Ri(e, t), Ri(e + "Capture", t);
}
function Ri(e, t) {
  for (Na[e] = t, e = 0; e < t.length; e++) jh.add(t[e]);
}
var Gn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), N0 = Object.prototype.hasOwnProperty, e3 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ad = {}, Cd = {};
function t3(e) {
  return N0.call(Cd, e) ? !0 : N0.call(Ad, e) ? !1 : e3.test(e) ? Cd[e] = !0 : (Ad[e] = !0, !1);
}
function n3(e, t, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function r3(e, t, n, r) {
  if (t === null || typeof t > "u" || n3(e, t, n, r)) return !0;
  if (r) return !1;
  if (n !== null) switch (n.type) {
    case 3:
      return !t;
    case 4:
      return t === !1;
    case 5:
      return isNaN(t);
    case 6:
      return isNaN(t) || 1 > t;
  }
  return !1;
}
function _t(e, t, n, r, i, a, l) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = a, this.removeEmptyString = l;
}
var st = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
  st[e] = new _t(e, 0, !1, e, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = e[0];
  st[t] = new _t(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  st[e] = new _t(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  st[e] = new _t(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
  st[e] = new _t(e, 3, !1, e.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
  st[e] = new _t(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function(e) {
  st[e] = new _t(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(e) {
  st[e] = new _t(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function(e) {
  st[e] = new _t(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var Vu = /[\-:]([a-z])/g;
function Wu(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
  var t = e.replace(
    Vu,
    Wu
  );
  st[t] = new _t(t, 1, !1, e, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
  var t = e.replace(Vu, Wu);
  st[t] = new _t(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
  var t = e.replace(Vu, Wu);
  st[t] = new _t(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  st[e] = new _t(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
st.xlinkHref = new _t("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
  st[e] = new _t(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function Ku(e, t, n, r) {
  var i = st.hasOwnProperty(t) ? st[t] : null;
  (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (r3(t, n, i, r) && (n = null), r || i === null ? t3(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
}
var Zn = J2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, cl = Symbol.for("react.element"), fi = Symbol.for("react.portal"), hi = Symbol.for("react.fragment"), Yu = Symbol.for("react.strict_mode"), A0 = Symbol.for("react.profiler"), Xh = Symbol.for("react.provider"), Zh = Symbol.for("react.context"), ju = Symbol.for("react.forward_ref"), C0 = Symbol.for("react.suspense"), M0 = Symbol.for("react.suspense_list"), Xu = Symbol.for("react.memo"), ir = Symbol.for("react.lazy"), Qh = Symbol.for("react.offscreen"), Md = Symbol.iterator;
function Qi(e) {
  return e === null || typeof e != "object" ? null : (e = Md && e[Md] || e["@@iterator"], typeof e == "function" ? e : null);
}
var He = Object.assign, ks;
function ua(e) {
  if (ks === void 0) try {
    throw Error();
  } catch (n) {
    var t = n.stack.trim().match(/\n( *(at )?)/);
    ks = t && t[1] || "";
  }
  return `
` + ks + e;
}
var Es = !1;
function Ss(e, t) {
  if (!e || Es) return "";
  Es = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t) if (t = function() {
      throw Error();
    }, Object.defineProperty(t.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(t, []);
      } catch (u) {
        var r = u;
      }
      Reflect.construct(e, [], t);
    } else {
      try {
        t.call();
      } catch (u) {
        r = u;
      }
      e.call(t.prototype);
    }
    else {
      try {
        throw Error();
      } catch (u) {
        r = u;
      }
      e();
    }
  } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), a = r.stack.split(`
`), l = i.length - 1, o = a.length - 1; 1 <= l && 0 <= o && i[l] !== a[o]; ) o--;
      for (; 1 <= l && 0 <= o; l--, o--) if (i[l] !== a[o]) {
        if (l !== 1 || o !== 1)
          do
            if (l--, o--, 0 > o || i[l] !== a[o]) {
              var s = `
` + i[l].replace(" at new ", " at ");
              return e.displayName && s.includes("<anonymous>") && (s = s.replace("<anonymous>", e.displayName)), s;
            }
          while (1 <= l && 0 <= o);
        break;
      }
    }
  } finally {
    Es = !1, Error.prepareStackTrace = n;
  }
  return (e = e ? e.displayName || e.name : "") ? ua(e) : "";
}
function i3(e) {
  switch (e.tag) {
    case 5:
      return ua(e.type);
    case 16:
      return ua("Lazy");
    case 13:
      return ua("Suspense");
    case 19:
      return ua("SuspenseList");
    case 0:
    case 2:
    case 15:
      return e = Ss(e.type, !1), e;
    case 11:
      return e = Ss(e.type.render, !1), e;
    case 1:
      return e = Ss(e.type, !0), e;
    default:
      return "";
  }
}
function O0(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case hi:
      return "Fragment";
    case fi:
      return "Portal";
    case A0:
      return "Profiler";
    case Yu:
      return "StrictMode";
    case C0:
      return "Suspense";
    case M0:
      return "SuspenseList";
  }
  if (typeof e == "object") switch (e.$$typeof) {
    case Zh:
      return (e.displayName || "Context") + ".Consumer";
    case Xh:
      return (e._context.displayName || "Context") + ".Provider";
    case ju:
      var t = e.render;
      return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
    case Xu:
      return t = e.displayName || null, t !== null ? t : O0(e.type) || "Memo";
    case ir:
      t = e._payload, e = e._init;
      try {
        return O0(e(t));
      } catch {
      }
  }
  return null;
}
function a3(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return O0(t);
    case 8:
      return t === Yu ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function wr(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function Jh(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
}
function l3(e) {
  var t = Jh(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
    var i = n.get, a = n.set;
    return Object.defineProperty(e, t, { configurable: !0, get: function() {
      return i.call(this);
    }, set: function(l) {
      r = "" + l, a.call(this, l);
    } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function() {
      return r;
    }, setValue: function(l) {
      r = "" + l;
    }, stopTracking: function() {
      e._valueTracker = null, delete e[t];
    } };
  }
}
function dl(e) {
  e._valueTracker || (e._valueTracker = l3(e));
}
function ep(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(), r = "";
  return e && (r = Jh(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1;
}
function oo(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function R0(e, t) {
  var n = t.checked;
  return He({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked });
}
function Od(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked;
  n = wr(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null };
}
function tp(e, t) {
  t = t.checked, t != null && Ku(e, "checked", t, !1);
}
function I0(e, t) {
  tp(e, t);
  var n = wr(t.value), r = t.type;
  if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value") ? D0(e, t.type, n) : t.hasOwnProperty("defaultValue") && D0(e, t.type, wr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked);
}
function Rd(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type;
    if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return;
    t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t;
  }
  n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n);
}
function D0(e, t, n) {
  (t !== "number" || oo(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
}
var ca = Array.isArray;
function Si(e, t, n, r) {
  if (e = e.options, t) {
    t = {};
    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
    for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0);
  } else {
    for (n = "" + wr(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        e[i].selected = !0, r && (e[i].defaultSelected = !0);
        return;
      }
      t !== null || e[i].disabled || (t = e[i]);
    }
    t !== null && (t.selected = !0);
  }
}
function z0(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(W(91));
  return He({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue });
}
function Id(e, t) {
  var n = t.value;
  if (n == null) {
    if (n = t.children, t = t.defaultValue, n != null) {
      if (t != null) throw Error(W(92));
      if (ca(n)) {
        if (1 < n.length) throw Error(W(93));
        n = n[0];
      }
      t = n;
    }
    t == null && (t = ""), n = t;
  }
  e._wrapperState = { initialValue: wr(n) };
}
function np(e, t) {
  var n = wr(t.value), r = wr(t.defaultValue);
  n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r);
}
function Dd(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function rp(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function L0(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? rp(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e;
}
var fl, ip = function(e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, i) {
    MSApp.execUnsafeLocalFunction(function() {
      return e(t, n, r, i);
    });
  } : e;
}(function(e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
  else {
    for (fl = fl || document.createElement("div"), fl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = fl.firstChild; e.firstChild; ) e.removeChild(e.firstChild);
    for (; t.firstChild; ) e.appendChild(t.firstChild);
  }
});
function Aa(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var pa = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, o3 = ["Webkit", "ms", "Moz", "O"];
Object.keys(pa).forEach(function(e) {
  o3.forEach(function(t) {
    t = t + e.charAt(0).toUpperCase() + e.substring(1), pa[t] = pa[e];
  });
});
function ap(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || pa.hasOwnProperty(e) && pa[e] ? ("" + t).trim() : t + "px";
}
function lp(e, t) {
  e = e.style;
  for (var n in t) if (t.hasOwnProperty(n)) {
    var r = n.indexOf("--") === 0, i = ap(n, t[n], r);
    n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i;
  }
}
var s3 = He({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function P0(e, t) {
  if (t) {
    if (s3[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(W(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(W(60));
      if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(W(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(W(62));
  }
}
function B0(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var F0 = null;
function Zu(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
}
var U0 = null, _i = null, Ti = null;
function zd(e) {
  if (e = el(e)) {
    if (typeof U0 != "function") throw Error(W(280));
    var t = e.stateNode;
    t && (t = jo(t), U0(e.stateNode, e.type, t));
  }
}
function op(e) {
  _i ? Ti ? Ti.push(e) : Ti = [e] : _i = e;
}
function sp() {
  if (_i) {
    var e = _i, t = Ti;
    if (Ti = _i = null, zd(e), t) for (e = 0; e < t.length; e++) zd(t[e]);
  }
}
function up(e, t) {
  return e(t);
}
function cp() {
}
var _s = !1;
function dp(e, t, n) {
  if (_s) return e(t, n);
  _s = !0;
  try {
    return up(e, t, n);
  } finally {
    _s = !1, (_i !== null || Ti !== null) && (cp(), sp());
  }
}
function Ca(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = jo(n);
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(W(231, t, typeof n));
  return n;
}
var $0 = !1;
if (Gn) try {
  var Ji = {};
  Object.defineProperty(Ji, "passive", { get: function() {
    $0 = !0;
  } }), window.addEventListener("test", Ji, Ji), window.removeEventListener("test", Ji, Ji);
} catch {
  $0 = !1;
}
function u3(e, t, n, r, i, a, l, o, s) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(n, u);
  } catch (c) {
    this.onError(c);
  }
}
var ma = !1, so = null, uo = !1, H0 = null, c3 = { onError: function(e) {
  ma = !0, so = e;
} };
function d3(e, t, n, r, i, a, l, o, s) {
  ma = !1, so = null, u3.apply(c3, arguments);
}
function f3(e, t, n, r, i, a, l, o, s) {
  if (d3.apply(this, arguments), ma) {
    if (ma) {
      var u = so;
      ma = !1, so = null;
    } else throw Error(W(198));
    uo || (uo = !0, H0 = u);
  }
}
function Qr(e) {
  var t = e, n = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do
      t = e, t.flags & 4098 && (n = t.return), e = t.return;
    while (e);
  }
  return t.tag === 3 ? n : null;
}
function fp(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
  }
  return null;
}
function Ld(e) {
  if (Qr(e) !== e) throw Error(W(188));
}
function h3(e) {
  var t = e.alternate;
  if (!t) {
    if (t = Qr(e), t === null) throw Error(W(188));
    return t !== e ? null : e;
  }
  for (var n = e, r = t; ; ) {
    var i = n.return;
    if (i === null) break;
    var a = i.alternate;
    if (a === null) {
      if (r = i.return, r !== null) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === a.child) {
      for (a = i.child; a; ) {
        if (a === n) return Ld(i), e;
        if (a === r) return Ld(i), t;
        a = a.sibling;
      }
      throw Error(W(188));
    }
    if (n.return !== r.return) n = i, r = a;
    else {
      for (var l = !1, o = i.child; o; ) {
        if (o === n) {
          l = !0, n = i, r = a;
          break;
        }
        if (o === r) {
          l = !0, r = i, n = a;
          break;
        }
        o = o.sibling;
      }
      if (!l) {
        for (o = a.child; o; ) {
          if (o === n) {
            l = !0, n = a, r = i;
            break;
          }
          if (o === r) {
            l = !0, r = a, n = i;
            break;
          }
          o = o.sibling;
        }
        if (!l) throw Error(W(189));
      }
    }
    if (n.alternate !== r) throw Error(W(190));
  }
  if (n.tag !== 3) throw Error(W(188));
  return n.stateNode.current === n ? e : t;
}
function hp(e) {
  return e = h3(e), e !== null ? pp(e) : null;
}
function pp(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = pp(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var mp = qt.unstable_scheduleCallback, Pd = qt.unstable_cancelCallback, p3 = qt.unstable_shouldYield, m3 = qt.unstable_requestPaint, Ye = qt.unstable_now, g3 = qt.unstable_getCurrentPriorityLevel, Qu = qt.unstable_ImmediatePriority, gp = qt.unstable_UserBlockingPriority, co = qt.unstable_NormalPriority, v3 = qt.unstable_LowPriority, vp = qt.unstable_IdlePriority, Vo = null, Nn = null;
function y3(e) {
  if (Nn && typeof Nn.onCommitFiberRoot == "function") try {
    Nn.onCommitFiberRoot(Vo, e, void 0, (e.current.flags & 128) === 128);
  } catch {
  }
}
var hn = Math.clz32 ? Math.clz32 : x3, b3 = Math.log, w3 = Math.LN2;
function x3(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (b3(e) / w3 | 0) | 0;
}
var hl = 64, pl = 4194304;
function da(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function fo(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var r = 0, i = e.suspendedLanes, a = e.pingedLanes, l = n & 268435455;
  if (l !== 0) {
    var o = l & ~i;
    o !== 0 ? r = da(o) : (a &= l, a !== 0 && (r = da(a)));
  } else l = n & ~i, l !== 0 ? r = da(l) : a !== 0 && (r = da(a));
  if (r === 0) return 0;
  if (t !== 0 && t !== r && !(t & i) && (i = r & -r, a = t & -t, i >= a || i === 16 && (a & 4194240) !== 0)) return t;
  if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t; ) n = 31 - hn(t), i = 1 << n, r |= e[n], t &= ~i;
  return r;
}
function k3(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function E3(e, t) {
  for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, a = e.pendingLanes; 0 < a; ) {
    var l = 31 - hn(a), o = 1 << l, s = i[l];
    s === -1 ? (!(o & n) || o & r) && (i[l] = k3(o, t)) : s <= t && (e.expiredLanes |= o), a &= ~o;
  }
}
function q0(e) {
  return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;
}
function yp() {
  var e = hl;
  return hl <<= 1, !(hl & 4194240) && (hl = 64), e;
}
function Ts(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t;
}
function Qa(e, t, n) {
  e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - hn(t), e[t] = n;
}
function S3(e, t) {
  var n = e.pendingLanes & ~t;
  e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - hn(n), a = 1 << i;
    t[i] = 0, r[i] = -1, e[i] = -1, n &= ~a;
  }
}
function Ju(e, t) {
  var n = e.entangledLanes |= t;
  for (e = e.entanglements; n; ) {
    var r = 31 - hn(n), i = 1 << r;
    i & t | e[r] & t && (e[r] |= t), n &= ~i;
  }
}
var _e = 0;
function bp(e) {
  return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1;
}
var wp, ec, xp, kp, Ep, G0 = !1, ml = [], fr = null, hr = null, pr = null, Ma = /* @__PURE__ */ new Map(), Oa = /* @__PURE__ */ new Map(), lr = [], _3 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Bd(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      fr = null;
      break;
    case "dragenter":
    case "dragleave":
      hr = null;
      break;
    case "mouseover":
    case "mouseout":
      pr = null;
      break;
    case "pointerover":
    case "pointerout":
      Ma.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Oa.delete(t.pointerId);
  }
}
function ea(e, t, n, r, i, a) {
  return e === null || e.nativeEvent !== a ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: a, targetContainers: [i] }, t !== null && (t = el(t), t !== null && ec(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e);
}
function T3(e, t, n, r, i) {
  switch (t) {
    case "focusin":
      return fr = ea(fr, e, t, n, r, i), !0;
    case "dragenter":
      return hr = ea(hr, e, t, n, r, i), !0;
    case "mouseover":
      return pr = ea(pr, e, t, n, r, i), !0;
    case "pointerover":
      var a = i.pointerId;
      return Ma.set(a, ea(Ma.get(a) || null, e, t, n, r, i)), !0;
    case "gotpointercapture":
      return a = i.pointerId, Oa.set(a, ea(Oa.get(a) || null, e, t, n, r, i)), !0;
  }
  return !1;
}
function Sp(e) {
  var t = Fr(e.target);
  if (t !== null) {
    var n = Qr(t);
    if (n !== null) {
      if (t = n.tag, t === 13) {
        if (t = fp(n), t !== null) {
          e.blockedOn = t, Ep(e.priority, function() {
            xp(n);
          });
          return;
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function Kl(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = V0(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var r = new n.constructor(n.type, n);
      F0 = r, n.target.dispatchEvent(r), F0 = null;
    } else return t = el(n), t !== null && ec(t), e.blockedOn = n, !1;
    t.shift();
  }
  return !0;
}
function Fd(e, t, n) {
  Kl(e) && n.delete(t);
}
function N3() {
  G0 = !1, fr !== null && Kl(fr) && (fr = null), hr !== null && Kl(hr) && (hr = null), pr !== null && Kl(pr) && (pr = null), Ma.forEach(Fd), Oa.forEach(Fd);
}
function ta(e, t) {
  e.blockedOn === t && (e.blockedOn = null, G0 || (G0 = !0, qt.unstable_scheduleCallback(qt.unstable_NormalPriority, N3)));
}
function Ra(e) {
  function t(i) {
    return ta(i, e);
  }
  if (0 < ml.length) {
    ta(ml[0], e);
    for (var n = 1; n < ml.length; n++) {
      var r = ml[n];
      r.blockedOn === e && (r.blockedOn = null);
    }
  }
  for (fr !== null && ta(fr, e), hr !== null && ta(hr, e), pr !== null && ta(pr, e), Ma.forEach(t), Oa.forEach(t), n = 0; n < lr.length; n++) r = lr[n], r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < lr.length && (n = lr[0], n.blockedOn === null); ) Sp(n), n.blockedOn === null && lr.shift();
}
var Ni = Zn.ReactCurrentBatchConfig, ho = !0;
function A3(e, t, n, r) {
  var i = _e, a = Ni.transition;
  Ni.transition = null;
  try {
    _e = 1, tc(e, t, n, r);
  } finally {
    _e = i, Ni.transition = a;
  }
}
function C3(e, t, n, r) {
  var i = _e, a = Ni.transition;
  Ni.transition = null;
  try {
    _e = 4, tc(e, t, n, r);
  } finally {
    _e = i, Ni.transition = a;
  }
}
function tc(e, t, n, r) {
  if (ho) {
    var i = V0(e, t, n, r);
    if (i === null) Ls(e, t, r, po, n), Bd(e, r);
    else if (T3(i, e, t, n, r)) r.stopPropagation();
    else if (Bd(e, r), t & 4 && -1 < _3.indexOf(e)) {
      for (; i !== null; ) {
        var a = el(i);
        if (a !== null && wp(a), a = V0(e, t, n, r), a === null && Ls(e, t, r, po, n), a === i) break;
        i = a;
      }
      i !== null && r.stopPropagation();
    } else Ls(e, t, r, null, n);
  }
}
var po = null;
function V0(e, t, n, r) {
  if (po = null, e = Zu(r), e = Fr(e), e !== null) if (t = Qr(e), t === null) e = null;
  else if (n = t.tag, n === 13) {
    if (e = fp(t), e !== null) return e;
    e = null;
  } else if (n === 3) {
    if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
    e = null;
  } else t !== e && (e = null);
  return po = e, null;
}
function _p(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (g3()) {
        case Qu:
          return 1;
        case gp:
          return 4;
        case co:
        case v3:
          return 16;
        case vp:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var sr = null, nc = null, Yl = null;
function Tp() {
  if (Yl) return Yl;
  var e, t = nc, n = t.length, r, i = "value" in sr ? sr.value : sr.textContent, a = i.length;
  for (e = 0; e < n && t[e] === i[e]; e++) ;
  var l = n - e;
  for (r = 1; r <= l && t[n - r] === i[a - r]; r++) ;
  return Yl = i.slice(e, 1 < r ? 1 - r : void 0);
}
function jl(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
}
function gl() {
  return !0;
}
function Ud() {
  return !1;
}
function Vt(e) {
  function t(n, r, i, a, l) {
    this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = a, this.target = l, this.currentTarget = null;
    for (var o in e) e.hasOwnProperty(o) && (n = e[o], this[o] = n ? n(a) : a[o]);
    return this.isDefaultPrevented = (a.defaultPrevented != null ? a.defaultPrevented : a.returnValue === !1) ? gl : Ud, this.isPropagationStopped = Ud, this;
  }
  return He(t.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var n = this.nativeEvent;
    n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = gl);
  }, stopPropagation: function() {
    var n = this.nativeEvent;
    n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = gl);
  }, persist: function() {
  }, isPersistent: gl }), t;
}
var qi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e) {
  return e.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, rc = Vt(qi), Ja = He({}, qi, { view: 0, detail: 0 }), M3 = Vt(Ja), Ns, As, na, Wo = He({}, Ja, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ic, button: 0, buttons: 0, relatedTarget: function(e) {
  return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
}, movementX: function(e) {
  return "movementX" in e ? e.movementX : (e !== na && (na && e.type === "mousemove" ? (Ns = e.screenX - na.screenX, As = e.screenY - na.screenY) : As = Ns = 0, na = e), Ns);
}, movementY: function(e) {
  return "movementY" in e ? e.movementY : As;
} }), $d = Vt(Wo), O3 = He({}, Wo, { dataTransfer: 0 }), R3 = Vt(O3), I3 = He({}, Ja, { relatedTarget: 0 }), Cs = Vt(I3), D3 = He({}, qi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), z3 = Vt(D3), L3 = He({}, qi, { clipboardData: function(e) {
  return "clipboardData" in e ? e.clipboardData : window.clipboardData;
} }), P3 = Vt(L3), B3 = He({}, qi, { data: 0 }), Hd = Vt(B3), F3 = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, U3 = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, $3 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function H3(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = $3[e]) ? !!t[e] : !1;
}
function ic() {
  return H3;
}
var q3 = He({}, Ja, { key: function(e) {
  if (e.key) {
    var t = F3[e.key] || e.key;
    if (t !== "Unidentified") return t;
  }
  return e.type === "keypress" ? (e = jl(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? U3[e.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ic, charCode: function(e) {
  return e.type === "keypress" ? jl(e) : 0;
}, keyCode: function(e) {
  return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
}, which: function(e) {
  return e.type === "keypress" ? jl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
} }), G3 = Vt(q3), V3 = He({}, Wo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), qd = Vt(V3), W3 = He({}, Ja, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ic }), K3 = Vt(W3), Y3 = He({}, qi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), j3 = Vt(Y3), X3 = He({}, Wo, {
  deltaX: function(e) {
    return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
  },
  deltaY: function(e) {
    return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Z3 = Vt(X3), Q3 = [9, 13, 27, 32], ac = Gn && "CompositionEvent" in window, ga = null;
Gn && "documentMode" in document && (ga = document.documentMode);
var J3 = Gn && "TextEvent" in window && !ga, Np = Gn && (!ac || ga && 8 < ga && 11 >= ga), Gd = " ", Vd = !1;
function Ap(e, t) {
  switch (e) {
    case "keyup":
      return Q3.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function Cp(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
}
var pi = !1;
function e5(e, t) {
  switch (e) {
    case "compositionend":
      return Cp(t);
    case "keypress":
      return t.which !== 32 ? null : (Vd = !0, Gd);
    case "textInput":
      return e = t.data, e === Gd && Vd ? null : e;
    default:
      return null;
  }
}
function t5(e, t) {
  if (pi) return e === "compositionend" || !ac && Ap(e, t) ? (e = Tp(), Yl = nc = sr = null, pi = !1, e) : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return Np && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var n5 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function Wd(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!n5[e.type] : t === "textarea";
}
function Mp(e, t, n, r) {
  op(r), t = mo(t, "onChange"), 0 < t.length && (n = new rc("onChange", "change", null, n, r), e.push({ event: n, listeners: t }));
}
var va = null, Ia = null;
function r5(e) {
  $p(e, 0);
}
function Ko(e) {
  var t = vi(e);
  if (ep(t)) return e;
}
function i5(e, t) {
  if (e === "change") return t;
}
var Op = !1;
if (Gn) {
  var Ms;
  if (Gn) {
    var Os = "oninput" in document;
    if (!Os) {
      var Kd = document.createElement("div");
      Kd.setAttribute("oninput", "return;"), Os = typeof Kd.oninput == "function";
    }
    Ms = Os;
  } else Ms = !1;
  Op = Ms && (!document.documentMode || 9 < document.documentMode);
}
function Yd() {
  va && (va.detachEvent("onpropertychange", Rp), Ia = va = null);
}
function Rp(e) {
  if (e.propertyName === "value" && Ko(Ia)) {
    var t = [];
    Mp(t, Ia, e, Zu(e)), dp(r5, t);
  }
}
function a5(e, t, n) {
  e === "focusin" ? (Yd(), va = t, Ia = n, va.attachEvent("onpropertychange", Rp)) : e === "focusout" && Yd();
}
function l5(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return Ko(Ia);
}
function o5(e, t) {
  if (e === "click") return Ko(t);
}
function s5(e, t) {
  if (e === "input" || e === "change") return Ko(t);
}
function u5(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var gn = typeof Object.is == "function" ? Object.is : u5;
function Da(e, t) {
  if (gn(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  var n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!N0.call(t, i) || !gn(e[i], t[i])) return !1;
  }
  return !0;
}
function jd(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function Xd(e, t) {
  var n = jd(e);
  e = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e };
      e = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = jd(n);
  }
}
function Ip(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Ip(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
}
function Dp() {
  for (var e = window, t = oo(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) e = t.contentWindow;
    else break;
    t = oo(e.document);
  }
  return t;
}
function lc(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
}
function c5(e) {
  var t = Dp(), n = e.focusedElem, r = e.selectionRange;
  if (t !== n && n && n.ownerDocument && Ip(n.ownerDocument.documentElement, n)) {
    if (r !== null && lc(n)) {
      if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
      else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) {
        e = e.getSelection();
        var i = n.textContent.length, a = Math.min(r.start, i);
        r = r.end === void 0 ? a : Math.min(r.end, i), !e.extend && a > r && (i = r, r = a, a = i), i = Xd(n, a);
        var l = Xd(
          n,
          r
        );
        i && l && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== l.node || e.focusOffset !== l.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), a > r ? (e.addRange(t), e.extend(l.node, l.offset)) : (t.setEnd(l.node, l.offset), e.addRange(t)));
      }
    }
    for (t = [], e = n; e = e.parentNode; ) e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++) e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top;
  }
}
var d5 = Gn && "documentMode" in document && 11 >= document.documentMode, mi = null, W0 = null, ya = null, K0 = !1;
function Zd(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  K0 || mi == null || mi !== oo(r) || (r = mi, "selectionStart" in r && lc(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), ya && Da(ya, r) || (ya = r, r = mo(W0, "onSelect"), 0 < r.length && (t = new rc("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = mi)));
}
function vl(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
}
var gi = { animationend: vl("Animation", "AnimationEnd"), animationiteration: vl("Animation", "AnimationIteration"), animationstart: vl("Animation", "AnimationStart"), transitionend: vl("Transition", "TransitionEnd") }, Rs = {}, zp = {};
Gn && (zp = document.createElement("div").style, "AnimationEvent" in window || (delete gi.animationend.animation, delete gi.animationiteration.animation, delete gi.animationstart.animation), "TransitionEvent" in window || delete gi.transitionend.transition);
function Yo(e) {
  if (Rs[e]) return Rs[e];
  if (!gi[e]) return e;
  var t = gi[e], n;
  for (n in t) if (t.hasOwnProperty(n) && n in zp) return Rs[e] = t[n];
  return e;
}
var Lp = Yo("animationend"), Pp = Yo("animationiteration"), Bp = Yo("animationstart"), Fp = Yo("transitionend"), Up = /* @__PURE__ */ new Map(), Qd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function _r(e, t) {
  Up.set(e, t), Zr(t, [e]);
}
for (var Is = 0; Is < Qd.length; Is++) {
  var Ds = Qd[Is], f5 = Ds.toLowerCase(), h5 = Ds[0].toUpperCase() + Ds.slice(1);
  _r(f5, "on" + h5);
}
_r(Lp, "onAnimationEnd");
_r(Pp, "onAnimationIteration");
_r(Bp, "onAnimationStart");
_r("dblclick", "onDoubleClick");
_r("focusin", "onFocus");
_r("focusout", "onBlur");
_r(Fp, "onTransitionEnd");
Ri("onMouseEnter", ["mouseout", "mouseover"]);
Ri("onMouseLeave", ["mouseout", "mouseover"]);
Ri("onPointerEnter", ["pointerout", "pointerover"]);
Ri("onPointerLeave", ["pointerout", "pointerover"]);
Zr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Zr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Zr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Zr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Zr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Zr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var fa = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), p5 = new Set("cancel close invalid load scroll toggle".split(" ").concat(fa));
function Jd(e, t, n) {
  var r = e.type || "unknown-event";
  e.currentTarget = n, f3(r, t, void 0, e), e.currentTarget = null;
}
function $p(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], i = r.event;
    r = r.listeners;
    e: {
      var a = void 0;
      if (t) for (var l = r.length - 1; 0 <= l; l--) {
        var o = r[l], s = o.instance, u = o.currentTarget;
        if (o = o.listener, s !== a && i.isPropagationStopped()) break e;
        Jd(i, o, u), a = s;
      }
      else for (l = 0; l < r.length; l++) {
        if (o = r[l], s = o.instance, u = o.currentTarget, o = o.listener, s !== a && i.isPropagationStopped()) break e;
        Jd(i, o, u), a = s;
      }
    }
  }
  if (uo) throw e = H0, uo = !1, H0 = null, e;
}
function De(e, t) {
  var n = t[Q0];
  n === void 0 && (n = t[Q0] = /* @__PURE__ */ new Set());
  var r = e + "__bubble";
  n.has(r) || (Hp(t, e, 2, !1), n.add(r));
}
function zs(e, t, n) {
  var r = 0;
  t && (r |= 4), Hp(n, e, r, t);
}
var yl = "_reactListening" + Math.random().toString(36).slice(2);
function za(e) {
  if (!e[yl]) {
    e[yl] = !0, jh.forEach(function(n) {
      n !== "selectionchange" && (p5.has(n) || zs(n, !1, e), zs(n, !0, e));
    });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[yl] || (t[yl] = !0, zs("selectionchange", !1, t));
  }
}
function Hp(e, t, n, r) {
  switch (_p(t)) {
    case 1:
      var i = A3;
      break;
    case 4:
      i = C3;
      break;
    default:
      i = tc;
  }
  n = i.bind(null, t, n, e), i = void 0, !$0 || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1);
}
function Ls(e, t, n, r, i) {
  var a = r;
  if (!(t & 1) && !(t & 2) && r !== null) e: for (; ; ) {
    if (r === null) return;
    var l = r.tag;
    if (l === 3 || l === 4) {
      var o = r.stateNode.containerInfo;
      if (o === i || o.nodeType === 8 && o.parentNode === i) break;
      if (l === 4) for (l = r.return; l !== null; ) {
        var s = l.tag;
        if ((s === 3 || s === 4) && (s = l.stateNode.containerInfo, s === i || s.nodeType === 8 && s.parentNode === i)) return;
        l = l.return;
      }
      for (; o !== null; ) {
        if (l = Fr(o), l === null) return;
        if (s = l.tag, s === 5 || s === 6) {
          r = a = l;
          continue e;
        }
        o = o.parentNode;
      }
    }
    r = r.return;
  }
  dp(function() {
    var u = a, c = Zu(n), d = [];
    e: {
      var h = Up.get(e);
      if (h !== void 0) {
        var p = rc, g = e;
        switch (e) {
          case "keypress":
            if (jl(n) === 0) break e;
          case "keydown":
          case "keyup":
            p = G3;
            break;
          case "focusin":
            g = "focus", p = Cs;
            break;
          case "focusout":
            g = "blur", p = Cs;
            break;
          case "beforeblur":
          case "afterblur":
            p = Cs;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = $d;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = R3;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = K3;
            break;
          case Lp:
          case Pp:
          case Bp:
            p = z3;
            break;
          case Fp:
            p = j3;
            break;
          case "scroll":
            p = M3;
            break;
          case "wheel":
            p = Z3;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = P3;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = qd;
        }
        var w = (t & 4) !== 0, S = !w && e === "scroll", y = w ? h !== null ? h + "Capture" : null : h;
        w = [];
        for (var v = u, x; v !== null; ) {
          x = v;
          var C = x.stateNode;
          if (x.tag === 5 && C !== null && (x = C, y !== null && (C = Ca(v, y), C != null && w.push(La(v, C, x)))), S) break;
          v = v.return;
        }
        0 < w.length && (h = new p(h, g, null, n, c), d.push({ event: h, listeners: w }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (h = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", h && n !== F0 && (g = n.relatedTarget || n.fromElement) && (Fr(g) || g[Vn])) break e;
        if ((p || h) && (h = c.window === c ? c : (h = c.ownerDocument) ? h.defaultView || h.parentWindow : window, p ? (g = n.relatedTarget || n.toElement, p = u, g = g ? Fr(g) : null, g !== null && (S = Qr(g), g !== S || g.tag !== 5 && g.tag !== 6) && (g = null)) : (p = null, g = u), p !== g)) {
          if (w = $d, C = "onMouseLeave", y = "onMouseEnter", v = "mouse", (e === "pointerout" || e === "pointerover") && (w = qd, C = "onPointerLeave", y = "onPointerEnter", v = "pointer"), S = p == null ? h : vi(p), x = g == null ? h : vi(g), h = new w(C, v + "leave", p, n, c), h.target = S, h.relatedTarget = x, C = null, Fr(c) === u && (w = new w(y, v + "enter", g, n, c), w.target = x, w.relatedTarget = S, C = w), S = C, p && g) t: {
            for (w = p, y = g, v = 0, x = w; x; x = ai(x)) v++;
            for (x = 0, C = y; C; C = ai(C)) x++;
            for (; 0 < v - x; ) w = ai(w), v--;
            for (; 0 < x - v; ) y = ai(y), x--;
            for (; v--; ) {
              if (w === y || y !== null && w === y.alternate) break t;
              w = ai(w), y = ai(y);
            }
            w = null;
          }
          else w = null;
          p !== null && ef(d, h, p, w, !1), g !== null && S !== null && ef(d, S, g, w, !0);
        }
      }
      e: {
        if (h = u ? vi(u) : window, p = h.nodeName && h.nodeName.toLowerCase(), p === "select" || p === "input" && h.type === "file") var R = i5;
        else if (Wd(h)) if (Op) R = s5;
        else {
          R = l5;
          var T = a5;
        }
        else (p = h.nodeName) && p.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (R = o5);
        if (R && (R = R(e, u))) {
          Mp(d, R, n, c);
          break e;
        }
        T && T(e, h, u), e === "focusout" && (T = h._wrapperState) && T.controlled && h.type === "number" && D0(h, "number", h.value);
      }
      switch (T = u ? vi(u) : window, e) {
        case "focusin":
          (Wd(T) || T.contentEditable === "true") && (mi = T, W0 = u, ya = null);
          break;
        case "focusout":
          ya = W0 = mi = null;
          break;
        case "mousedown":
          K0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          K0 = !1, Zd(d, n, c);
          break;
        case "selectionchange":
          if (d5) break;
        case "keydown":
        case "keyup":
          Zd(d, n, c);
      }
      var z;
      if (ac) e: {
        switch (e) {
          case "compositionstart":
            var P = "onCompositionStart";
            break e;
          case "compositionend":
            P = "onCompositionEnd";
            break e;
          case "compositionupdate":
            P = "onCompositionUpdate";
            break e;
        }
        P = void 0;
      }
      else pi ? Ap(e, n) && (P = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (P = "onCompositionStart");
      P && (Np && n.locale !== "ko" && (pi || P !== "onCompositionStart" ? P === "onCompositionEnd" && pi && (z = Tp()) : (sr = c, nc = "value" in sr ? sr.value : sr.textContent, pi = !0)), T = mo(u, P), 0 < T.length && (P = new Hd(P, e, null, n, c), d.push({ event: P, listeners: T }), z ? P.data = z : (z = Cp(n), z !== null && (P.data = z)))), (z = J3 ? e5(e, n) : t5(e, n)) && (u = mo(u, "onBeforeInput"), 0 < u.length && (c = new Hd("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = z));
    }
    $p(d, t);
  });
}
function La(e, t, n) {
  return { instance: e, listener: t, currentTarget: n };
}
function mo(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var i = e, a = i.stateNode;
    i.tag === 5 && a !== null && (i = a, a = Ca(e, n), a != null && r.unshift(La(e, a, i)), a = Ca(e, t), a != null && r.push(La(e, a, i))), e = e.return;
  }
  return r;
}
function ai(e) {
  if (e === null) return null;
  do
    e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function ef(e, t, n, r, i) {
  for (var a = t._reactName, l = []; n !== null && n !== r; ) {
    var o = n, s = o.alternate, u = o.stateNode;
    if (s !== null && s === r) break;
    o.tag === 5 && u !== null && (o = u, i ? (s = Ca(n, a), s != null && l.unshift(La(n, s, o))) : i || (s = Ca(n, a), s != null && l.push(La(n, s, o)))), n = n.return;
  }
  l.length !== 0 && e.push({ event: t, listeners: l });
}
var m5 = /\r\n?/g, g5 = /\u0000|\uFFFD/g;
function tf(e) {
  return (typeof e == "string" ? e : "" + e).replace(m5, `
`).replace(g5, "");
}
function bl(e, t, n) {
  if (t = tf(t), tf(e) !== t && n) throw Error(W(425));
}
function go() {
}
var Y0 = null, j0 = null;
function X0(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
}
var Z0 = typeof setTimeout == "function" ? setTimeout : void 0, v5 = typeof clearTimeout == "function" ? clearTimeout : void 0, nf = typeof Promise == "function" ? Promise : void 0, y5 = typeof queueMicrotask == "function" ? queueMicrotask : typeof nf < "u" ? function(e) {
  return nf.resolve(null).then(e).catch(b5);
} : Z0;
function b5(e) {
  setTimeout(function() {
    throw e;
  });
}
function Ps(e, t) {
  var n = t, r = 0;
  do {
    var i = n.nextSibling;
    if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") {
      if (r === 0) {
        e.removeChild(i), Ra(t);
        return;
      }
      r--;
    } else n !== "$" && n !== "$?" && n !== "$!" || r++;
    n = i;
  } while (n);
  Ra(t);
}
function mr(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function rf(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e;
        t--;
      } else n === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var Gi = Math.random().toString(36).slice(2), _n = "__reactFiber$" + Gi, Pa = "__reactProps$" + Gi, Vn = "__reactContainer$" + Gi, Q0 = "__reactEvents$" + Gi, w5 = "__reactListeners$" + Gi, x5 = "__reactHandles$" + Gi;
function Fr(e) {
  var t = e[_n];
  if (t) return t;
  for (var n = e.parentNode; n; ) {
    if (t = n[Vn] || n[_n]) {
      if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = rf(e); e !== null; ) {
        if (n = e[_n]) return n;
        e = rf(e);
      }
      return t;
    }
    e = n, n = e.parentNode;
  }
  return null;
}
function el(e) {
  return e = e[_n] || e[Vn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;
}
function vi(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(W(33));
}
function jo(e) {
  return e[Pa] || null;
}
var J0 = [], yi = -1;
function Tr(e) {
  return { current: e };
}
function ze(e) {
  0 > yi || (e.current = J0[yi], J0[yi] = null, yi--);
}
function Re(e, t) {
  yi++, J0[yi] = e.current, e.current = t;
}
var xr = {}, pt = Tr(xr), Ot = Tr(!1), Vr = xr;
function Ii(e, t) {
  var n = e.type.contextTypes;
  if (!n) return xr;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
  var i = {}, a;
  for (a in n) i[a] = t[a];
  return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i;
}
function Rt(e) {
  return e = e.childContextTypes, e != null;
}
function vo() {
  ze(Ot), ze(pt);
}
function af(e, t, n) {
  if (pt.current !== xr) throw Error(W(168));
  Re(pt, t), Re(Ot, n);
}
function qp(e, t, n) {
  var r = e.stateNode;
  if (t = t.childContextTypes, typeof r.getChildContext != "function") return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in t)) throw Error(W(108, a3(e) || "Unknown", i));
  return He({}, n, r);
}
function yo(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || xr, Vr = pt.current, Re(pt, e), Re(Ot, Ot.current), !0;
}
function lf(e, t, n) {
  var r = e.stateNode;
  if (!r) throw Error(W(169));
  n ? (e = qp(e, t, Vr), r.__reactInternalMemoizedMergedChildContext = e, ze(Ot), ze(pt), Re(pt, e)) : ze(Ot), Re(Ot, n);
}
var Pn = null, Xo = !1, Bs = !1;
function Gp(e) {
  Pn === null ? Pn = [e] : Pn.push(e);
}
function k5(e) {
  Xo = !0, Gp(e);
}
function Nr() {
  if (!Bs && Pn !== null) {
    Bs = !0;
    var e = 0, t = _e;
    try {
      var n = Pn;
      for (_e = 1; e < n.length; e++) {
        var r = n[e];
        do
          r = r(!0);
        while (r !== null);
      }
      Pn = null, Xo = !1;
    } catch (i) {
      throw Pn !== null && (Pn = Pn.slice(e + 1)), mp(Qu, Nr), i;
    } finally {
      _e = t, Bs = !1;
    }
  }
  return null;
}
var bi = [], wi = 0, bo = null, wo = 0, Kt = [], Yt = 0, Wr = null, Fn = 1, Un = "";
function Lr(e, t) {
  bi[wi++] = wo, bi[wi++] = bo, bo = e, wo = t;
}
function Vp(e, t, n) {
  Kt[Yt++] = Fn, Kt[Yt++] = Un, Kt[Yt++] = Wr, Wr = e;
  var r = Fn;
  e = Un;
  var i = 32 - hn(r) - 1;
  r &= ~(1 << i), n += 1;
  var a = 32 - hn(t) + i;
  if (30 < a) {
    var l = i - i % 5;
    a = (r & (1 << l) - 1).toString(32), r >>= l, i -= l, Fn = 1 << 32 - hn(t) + i | n << i | r, Un = a + e;
  } else Fn = 1 << a | n << i | r, Un = e;
}
function oc(e) {
  e.return !== null && (Lr(e, 1), Vp(e, 1, 0));
}
function sc(e) {
  for (; e === bo; ) bo = bi[--wi], bi[wi] = null, wo = bi[--wi], bi[wi] = null;
  for (; e === Wr; ) Wr = Kt[--Yt], Kt[Yt] = null, Un = Kt[--Yt], Kt[Yt] = null, Fn = Kt[--Yt], Kt[Yt] = null;
}
var $t = null, Ut = null, Le = !1, fn = null;
function Wp(e, t) {
  var n = Zt(5, null, null, 0);
  n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n);
}
function of(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type;
      return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, $t = e, Ut = mr(t.firstChild), !0) : !1;
    case 6:
      return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, $t = e, Ut = null, !0) : !1;
    case 13:
      return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Wr !== null ? { id: Fn, overflow: Un } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = Zt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, $t = e, Ut = null, !0) : !1;
    default:
      return !1;
  }
}
function eu(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function tu(e) {
  if (Le) {
    var t = Ut;
    if (t) {
      var n = t;
      if (!of(e, t)) {
        if (eu(e)) throw Error(W(418));
        t = mr(n.nextSibling);
        var r = $t;
        t && of(e, t) ? Wp(r, n) : (e.flags = e.flags & -4097 | 2, Le = !1, $t = e);
      }
    } else {
      if (eu(e)) throw Error(W(418));
      e.flags = e.flags & -4097 | 2, Le = !1, $t = e;
    }
  }
}
function sf(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return;
  $t = e;
}
function wl(e) {
  if (e !== $t) return !1;
  if (!Le) return sf(e), Le = !0, !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !X0(e.type, e.memoizedProps)), t && (t = Ut)) {
    if (eu(e)) throw Kp(), Error(W(418));
    for (; t; ) Wp(e, t), t = mr(t.nextSibling);
  }
  if (sf(e), e.tag === 13) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(W(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data;
          if (n === "/$") {
            if (t === 0) {
              Ut = mr(e.nextSibling);
              break e;
            }
            t--;
          } else n !== "$" && n !== "$!" && n !== "$?" || t++;
        }
        e = e.nextSibling;
      }
      Ut = null;
    }
  } else Ut = $t ? mr(e.stateNode.nextSibling) : null;
  return !0;
}
function Kp() {
  for (var e = Ut; e; ) e = mr(e.nextSibling);
}
function Di() {
  Ut = $t = null, Le = !1;
}
function uc(e) {
  fn === null ? fn = [e] : fn.push(e);
}
var E5 = Zn.ReactCurrentBatchConfig;
function ra(e, t, n) {
  if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") {
    if (n._owner) {
      if (n = n._owner, n) {
        if (n.tag !== 1) throw Error(W(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(W(147, e));
      var i = r, a = "" + e;
      return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === a ? t.ref : (t = function(l) {
        var o = i.refs;
        l === null ? delete o[a] : o[a] = l;
      }, t._stringRef = a, t);
    }
    if (typeof e != "string") throw Error(W(284));
    if (!n._owner) throw Error(W(290, e));
  }
  return e;
}
function xl(e, t) {
  throw e = Object.prototype.toString.call(t), Error(W(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
}
function uf(e) {
  var t = e._init;
  return t(e._payload);
}
function Yp(e) {
  function t(y, v) {
    if (e) {
      var x = y.deletions;
      x === null ? (y.deletions = [v], y.flags |= 16) : x.push(v);
    }
  }
  function n(y, v) {
    if (!e) return null;
    for (; v !== null; ) t(y, v), v = v.sibling;
    return null;
  }
  function r(y, v) {
    for (y = /* @__PURE__ */ new Map(); v !== null; ) v.key !== null ? y.set(v.key, v) : y.set(v.index, v), v = v.sibling;
    return y;
  }
  function i(y, v) {
    return y = br(y, v), y.index = 0, y.sibling = null, y;
  }
  function a(y, v, x) {
    return y.index = x, e ? (x = y.alternate, x !== null ? (x = x.index, x < v ? (y.flags |= 2, v) : x) : (y.flags |= 2, v)) : (y.flags |= 1048576, v);
  }
  function l(y) {
    return e && y.alternate === null && (y.flags |= 2), y;
  }
  function o(y, v, x, C) {
    return v === null || v.tag !== 6 ? (v = Vs(x, y.mode, C), v.return = y, v) : (v = i(v, x), v.return = y, v);
  }
  function s(y, v, x, C) {
    var R = x.type;
    return R === hi ? c(y, v, x.props.children, C, x.key) : v !== null && (v.elementType === R || typeof R == "object" && R !== null && R.$$typeof === ir && uf(R) === v.type) ? (C = i(v, x.props), C.ref = ra(y, v, x), C.return = y, C) : (C = no(x.type, x.key, x.props, null, y.mode, C), C.ref = ra(y, v, x), C.return = y, C);
  }
  function u(y, v, x, C) {
    return v === null || v.tag !== 4 || v.stateNode.containerInfo !== x.containerInfo || v.stateNode.implementation !== x.implementation ? (v = Ws(x, y.mode, C), v.return = y, v) : (v = i(v, x.children || []), v.return = y, v);
  }
  function c(y, v, x, C, R) {
    return v === null || v.tag !== 7 ? (v = qr(x, y.mode, C, R), v.return = y, v) : (v = i(v, x), v.return = y, v);
  }
  function d(y, v, x) {
    if (typeof v == "string" && v !== "" || typeof v == "number") return v = Vs("" + v, y.mode, x), v.return = y, v;
    if (typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case cl:
          return x = no(v.type, v.key, v.props, null, y.mode, x), x.ref = ra(y, null, v), x.return = y, x;
        case fi:
          return v = Ws(v, y.mode, x), v.return = y, v;
        case ir:
          var C = v._init;
          return d(y, C(v._payload), x);
      }
      if (ca(v) || Qi(v)) return v = qr(v, y.mode, x, null), v.return = y, v;
      xl(y, v);
    }
    return null;
  }
  function h(y, v, x, C) {
    var R = v !== null ? v.key : null;
    if (typeof x == "string" && x !== "" || typeof x == "number") return R !== null ? null : o(y, v, "" + x, C);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case cl:
          return x.key === R ? s(y, v, x, C) : null;
        case fi:
          return x.key === R ? u(y, v, x, C) : null;
        case ir:
          return R = x._init, h(
            y,
            v,
            R(x._payload),
            C
          );
      }
      if (ca(x) || Qi(x)) return R !== null ? null : c(y, v, x, C, null);
      xl(y, x);
    }
    return null;
  }
  function p(y, v, x, C, R) {
    if (typeof C == "string" && C !== "" || typeof C == "number") return y = y.get(x) || null, o(v, y, "" + C, R);
    if (typeof C == "object" && C !== null) {
      switch (C.$$typeof) {
        case cl:
          return y = y.get(C.key === null ? x : C.key) || null, s(v, y, C, R);
        case fi:
          return y = y.get(C.key === null ? x : C.key) || null, u(v, y, C, R);
        case ir:
          var T = C._init;
          return p(y, v, x, T(C._payload), R);
      }
      if (ca(C) || Qi(C)) return y = y.get(x) || null, c(v, y, C, R, null);
      xl(v, C);
    }
    return null;
  }
  function g(y, v, x, C) {
    for (var R = null, T = null, z = v, P = v = 0, U = null; z !== null && P < x.length; P++) {
      z.index > P ? (U = z, z = null) : U = z.sibling;
      var O = h(y, z, x[P], C);
      if (O === null) {
        z === null && (z = U);
        break;
      }
      e && z && O.alternate === null && t(y, z), v = a(O, v, P), T === null ? R = O : T.sibling = O, T = O, z = U;
    }
    if (P === x.length) return n(y, z), Le && Lr(y, P), R;
    if (z === null) {
      for (; P < x.length; P++) z = d(y, x[P], C), z !== null && (v = a(z, v, P), T === null ? R = z : T.sibling = z, T = z);
      return Le && Lr(y, P), R;
    }
    for (z = r(y, z); P < x.length; P++) U = p(z, y, P, x[P], C), U !== null && (e && U.alternate !== null && z.delete(U.key === null ? P : U.key), v = a(U, v, P), T === null ? R = U : T.sibling = U, T = U);
    return e && z.forEach(function(V) {
      return t(y, V);
    }), Le && Lr(y, P), R;
  }
  function w(y, v, x, C) {
    var R = Qi(x);
    if (typeof R != "function") throw Error(W(150));
    if (x = R.call(x), x == null) throw Error(W(151));
    for (var T = R = null, z = v, P = v = 0, U = null, O = x.next(); z !== null && !O.done; P++, O = x.next()) {
      z.index > P ? (U = z, z = null) : U = z.sibling;
      var V = h(y, z, O.value, C);
      if (V === null) {
        z === null && (z = U);
        break;
      }
      e && z && V.alternate === null && t(y, z), v = a(V, v, P), T === null ? R = V : T.sibling = V, T = V, z = U;
    }
    if (O.done) return n(
      y,
      z
    ), Le && Lr(y, P), R;
    if (z === null) {
      for (; !O.done; P++, O = x.next()) O = d(y, O.value, C), O !== null && (v = a(O, v, P), T === null ? R = O : T.sibling = O, T = O);
      return Le && Lr(y, P), R;
    }
    for (z = r(y, z); !O.done; P++, O = x.next()) O = p(z, y, P, O.value, C), O !== null && (e && O.alternate !== null && z.delete(O.key === null ? P : O.key), v = a(O, v, P), T === null ? R = O : T.sibling = O, T = O);
    return e && z.forEach(function(K) {
      return t(y, K);
    }), Le && Lr(y, P), R;
  }
  function S(y, v, x, C) {
    if (typeof x == "object" && x !== null && x.type === hi && x.key === null && (x = x.props.children), typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case cl:
          e: {
            for (var R = x.key, T = v; T !== null; ) {
              if (T.key === R) {
                if (R = x.type, R === hi) {
                  if (T.tag === 7) {
                    n(y, T.sibling), v = i(T, x.props.children), v.return = y, y = v;
                    break e;
                  }
                } else if (T.elementType === R || typeof R == "object" && R !== null && R.$$typeof === ir && uf(R) === T.type) {
                  n(y, T.sibling), v = i(T, x.props), v.ref = ra(y, T, x), v.return = y, y = v;
                  break e;
                }
                n(y, T);
                break;
              } else t(y, T);
              T = T.sibling;
            }
            x.type === hi ? (v = qr(x.props.children, y.mode, C, x.key), v.return = y, y = v) : (C = no(x.type, x.key, x.props, null, y.mode, C), C.ref = ra(y, v, x), C.return = y, y = C);
          }
          return l(y);
        case fi:
          e: {
            for (T = x.key; v !== null; ) {
              if (v.key === T) if (v.tag === 4 && v.stateNode.containerInfo === x.containerInfo && v.stateNode.implementation === x.implementation) {
                n(y, v.sibling), v = i(v, x.children || []), v.return = y, y = v;
                break e;
              } else {
                n(y, v);
                break;
              }
              else t(y, v);
              v = v.sibling;
            }
            v = Ws(x, y.mode, C), v.return = y, y = v;
          }
          return l(y);
        case ir:
          return T = x._init, S(y, v, T(x._payload), C);
      }
      if (ca(x)) return g(y, v, x, C);
      if (Qi(x)) return w(y, v, x, C);
      xl(y, x);
    }
    return typeof x == "string" && x !== "" || typeof x == "number" ? (x = "" + x, v !== null && v.tag === 6 ? (n(y, v.sibling), v = i(v, x), v.return = y, y = v) : (n(y, v), v = Vs(x, y.mode, C), v.return = y, y = v), l(y)) : n(y, v);
  }
  return S;
}
var zi = Yp(!0), jp = Yp(!1), xo = Tr(null), ko = null, xi = null, cc = null;
function dc() {
  cc = xi = ko = null;
}
function fc(e) {
  var t = xo.current;
  ze(xo), e._currentValue = t;
}
function nu(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate;
    if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
    e = e.return;
  }
}
function Ai(e, t) {
  ko = e, cc = xi = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Mt = !0), e.firstContext = null);
}
function tn(e) {
  var t = e._currentValue;
  if (cc !== e) if (e = { context: e, memoizedValue: t, next: null }, xi === null) {
    if (ko === null) throw Error(W(308));
    xi = e, ko.dependencies = { lanes: 0, firstContext: e };
  } else xi = xi.next = e;
  return t;
}
var Ur = null;
function hc(e) {
  Ur === null ? Ur = [e] : Ur.push(e);
}
function Xp(e, t, n, r) {
  var i = t.interleaved;
  return i === null ? (n.next = n, hc(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Wn(e, r);
}
function Wn(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; ) e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return;
  return n.tag === 3 ? n.stateNode : null;
}
var ar = !1;
function pc(e) {
  e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function Zp(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects });
}
function $n(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null };
}
function gr(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (r = r.shared, ke & 2) {
    var i = r.pending;
    return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Wn(e, n);
  }
  return i = r.interleaved, i === null ? (t.next = t, hc(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Wn(e, n);
}
function Xl(e, t, n) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, Ju(e, n);
  }
}
function cf(e, t) {
  var n = e.updateQueue, r = e.alternate;
  if (r !== null && (r = r.updateQueue, n === r)) {
    var i = null, a = null;
    if (n = n.firstBaseUpdate, n !== null) {
      do {
        var l = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null };
        a === null ? i = a = l : a = a.next = l, n = n.next;
      } while (n !== null);
      a === null ? i = a = t : a = a.next = t;
    } else i = a = t;
    n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: a, shared: r.shared, effects: r.effects }, e.updateQueue = n;
    return;
  }
  e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
}
function Eo(e, t, n, r) {
  var i = e.updateQueue;
  ar = !1;
  var a = i.firstBaseUpdate, l = i.lastBaseUpdate, o = i.shared.pending;
  if (o !== null) {
    i.shared.pending = null;
    var s = o, u = s.next;
    s.next = null, l === null ? a = u : l.next = u, l = s;
    var c = e.alternate;
    c !== null && (c = c.updateQueue, o = c.lastBaseUpdate, o !== l && (o === null ? c.firstBaseUpdate = u : o.next = u, c.lastBaseUpdate = s));
  }
  if (a !== null) {
    var d = i.baseState;
    l = 0, c = u = s = null, o = a;
    do {
      var h = o.lane, p = o.eventTime;
      if ((r & h) === h) {
        c !== null && (c = c.next = {
          eventTime: p,
          lane: 0,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null
        });
        e: {
          var g = e, w = o;
          switch (h = t, p = n, w.tag) {
            case 1:
              if (g = w.payload, typeof g == "function") {
                d = g.call(p, d, h);
                break e;
              }
              d = g;
              break e;
            case 3:
              g.flags = g.flags & -65537 | 128;
            case 0:
              if (g = w.payload, h = typeof g == "function" ? g.call(p, d, h) : g, h == null) break e;
              d = He({}, d, h);
              break e;
            case 2:
              ar = !0;
          }
        }
        o.callback !== null && o.lane !== 0 && (e.flags |= 64, h = i.effects, h === null ? i.effects = [o] : h.push(o));
      } else p = { eventTime: p, lane: h, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, c === null ? (u = c = p, s = d) : c = c.next = p, l |= h;
      if (o = o.next, o === null) {
        if (o = i.shared.pending, o === null) break;
        h = o, o = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null;
      }
    } while (!0);
    if (c === null && (s = d), i.baseState = s, i.firstBaseUpdate = u, i.lastBaseUpdate = c, t = i.shared.interleaved, t !== null) {
      i = t;
      do
        l |= i.lane, i = i.next;
      while (i !== t);
    } else a === null && (i.shared.lanes = 0);
    Yr |= l, e.lanes = l, e.memoizedState = d;
  }
}
function df(e, t, n) {
  if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) {
    var r = e[t], i = r.callback;
    if (i !== null) {
      if (r.callback = null, r = n, typeof i != "function") throw Error(W(191, i));
      i.call(r);
    }
  }
}
var tl = {}, An = Tr(tl), Ba = Tr(tl), Fa = Tr(tl);
function $r(e) {
  if (e === tl) throw Error(W(174));
  return e;
}
function mc(e, t) {
  switch (Re(Fa, t), Re(Ba, e), Re(An, tl), e = t.nodeType, e) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : L0(null, "");
      break;
    default:
      e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = L0(t, e);
  }
  ze(An), Re(An, t);
}
function Li() {
  ze(An), ze(Ba), ze(Fa);
}
function Qp(e) {
  $r(Fa.current);
  var t = $r(An.current), n = L0(t, e.type);
  t !== n && (Re(Ba, e), Re(An, n));
}
function gc(e) {
  Ba.current === e && (ze(An), ze(Ba));
}
var Fe = Tr(0);
function So(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
  return null;
}
var Fs = [];
function vc() {
  for (var e = 0; e < Fs.length; e++) Fs[e]._workInProgressVersionPrimary = null;
  Fs.length = 0;
}
var Zl = Zn.ReactCurrentDispatcher, Us = Zn.ReactCurrentBatchConfig, Kr = 0, $e = null, et = null, rt = null, _o = !1, ba = !1, Ua = 0, S5 = 0;
function ct() {
  throw Error(W(321));
}
function yc(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++) if (!gn(e[n], t[n])) return !1;
  return !0;
}
function bc(e, t, n, r, i, a) {
  if (Kr = a, $e = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Zl.current = e === null || e.memoizedState === null ? A5 : C5, e = n(r, i), ba) {
    a = 0;
    do {
      if (ba = !1, Ua = 0, 25 <= a) throw Error(W(301));
      a += 1, rt = et = null, t.updateQueue = null, Zl.current = M5, e = n(r, i);
    } while (ba);
  }
  if (Zl.current = To, t = et !== null && et.next !== null, Kr = 0, rt = et = $e = null, _o = !1, t) throw Error(W(300));
  return e;
}
function wc() {
  var e = Ua !== 0;
  return Ua = 0, e;
}
function kn() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return rt === null ? $e.memoizedState = rt = e : rt = rt.next = e, rt;
}
function nn() {
  if (et === null) {
    var e = $e.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = et.next;
  var t = rt === null ? $e.memoizedState : rt.next;
  if (t !== null) rt = t, et = e;
  else {
    if (e === null) throw Error(W(310));
    et = e, e = { memoizedState: et.memoizedState, baseState: et.baseState, baseQueue: et.baseQueue, queue: et.queue, next: null }, rt === null ? $e.memoizedState = rt = e : rt = rt.next = e;
  }
  return rt;
}
function $a(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function $s(e) {
  var t = nn(), n = t.queue;
  if (n === null) throw Error(W(311));
  n.lastRenderedReducer = e;
  var r = et, i = r.baseQueue, a = n.pending;
  if (a !== null) {
    if (i !== null) {
      var l = i.next;
      i.next = a.next, a.next = l;
    }
    r.baseQueue = i = a, n.pending = null;
  }
  if (i !== null) {
    a = i.next, r = r.baseState;
    var o = l = null, s = null, u = a;
    do {
      var c = u.lane;
      if ((Kr & c) === c) s !== null && (s = s.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action);
      else {
        var d = {
          lane: c,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null
        };
        s === null ? (o = s = d, l = r) : s = s.next = d, $e.lanes |= c, Yr |= c;
      }
      u = u.next;
    } while (u !== null && u !== a);
    s === null ? l = r : s.next = o, gn(r, t.memoizedState) || (Mt = !0), t.memoizedState = r, t.baseState = l, t.baseQueue = s, n.lastRenderedState = r;
  }
  if (e = n.interleaved, e !== null) {
    i = e;
    do
      a = i.lane, $e.lanes |= a, Yr |= a, i = i.next;
    while (i !== e);
  } else i === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch];
}
function Hs(e) {
  var t = nn(), n = t.queue;
  if (n === null) throw Error(W(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch, i = n.pending, a = t.memoizedState;
  if (i !== null) {
    n.pending = null;
    var l = i = i.next;
    do
      a = e(a, l.action), l = l.next;
    while (l !== i);
    gn(a, t.memoizedState) || (Mt = !0), t.memoizedState = a, t.baseQueue === null && (t.baseState = a), n.lastRenderedState = a;
  }
  return [a, r];
}
function Jp() {
}
function em(e, t) {
  var n = $e, r = nn(), i = t(), a = !gn(r.memoizedState, i);
  if (a && (r.memoizedState = i, Mt = !0), r = r.queue, xc(rm.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || rt !== null && rt.memoizedState.tag & 1) {
    if (n.flags |= 2048, Ha(9, nm.bind(null, n, r, i, t), void 0, null), it === null) throw Error(W(349));
    Kr & 30 || tm(n, t, i);
  }
  return i;
}
function tm(e, t, n) {
  e.flags |= 16384, e = { getSnapshot: t, value: n }, t = $e.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, $e.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e));
}
function nm(e, t, n, r) {
  t.value = n, t.getSnapshot = r, im(t) && am(e);
}
function rm(e, t, n) {
  return n(function() {
    im(t) && am(e);
  });
}
function im(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !gn(e, n);
  } catch {
    return !0;
  }
}
function am(e) {
  var t = Wn(e, 1);
  t !== null && pn(t, e, 1, -1);
}
function ff(e) {
  var t = kn();
  return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: $a, lastRenderedState: e }, t.queue = e, e = e.dispatch = N5.bind(null, $e, e), [t.memoizedState, e];
}
function Ha(e, t, n, r) {
  return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = $e.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, $e.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e;
}
function lm() {
  return nn().memoizedState;
}
function Ql(e, t, n, r) {
  var i = kn();
  $e.flags |= e, i.memoizedState = Ha(1 | t, n, void 0, r === void 0 ? null : r);
}
function Zo(e, t, n, r) {
  var i = nn();
  r = r === void 0 ? null : r;
  var a = void 0;
  if (et !== null) {
    var l = et.memoizedState;
    if (a = l.destroy, r !== null && yc(r, l.deps)) {
      i.memoizedState = Ha(t, n, a, r);
      return;
    }
  }
  $e.flags |= e, i.memoizedState = Ha(1 | t, n, a, r);
}
function hf(e, t) {
  return Ql(8390656, 8, e, t);
}
function xc(e, t) {
  return Zo(2048, 8, e, t);
}
function om(e, t) {
  return Zo(4, 2, e, t);
}
function sm(e, t) {
  return Zo(4, 4, e, t);
}
function um(e, t) {
  if (typeof t == "function") return e = e(), t(e), function() {
    t(null);
  };
  if (t != null) return e = e(), t.current = e, function() {
    t.current = null;
  };
}
function cm(e, t, n) {
  return n = n != null ? n.concat([e]) : null, Zo(4, 4, um.bind(null, t, e), n);
}
function kc() {
}
function dm(e, t) {
  var n = nn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && yc(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e);
}
function fm(e, t) {
  var n = nn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && yc(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e);
}
function hm(e, t, n) {
  return Kr & 21 ? (gn(n, t) || (n = yp(), $e.lanes |= n, Yr |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Mt = !0), e.memoizedState = n);
}
function _5(e, t) {
  var n = _e;
  _e = n !== 0 && 4 > n ? n : 4, e(!0);
  var r = Us.transition;
  Us.transition = {};
  try {
    e(!1), t();
  } finally {
    _e = n, Us.transition = r;
  }
}
function pm() {
  return nn().memoizedState;
}
function T5(e, t, n) {
  var r = yr(e);
  if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, mm(e)) gm(t, n);
  else if (n = Xp(e, t, n, r), n !== null) {
    var i = Et();
    pn(n, e, r, i), vm(n, t, r);
  }
}
function N5(e, t, n) {
  var r = yr(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (mm(e)) gm(t, i);
  else {
    var a = e.alternate;
    if (e.lanes === 0 && (a === null || a.lanes === 0) && (a = t.lastRenderedReducer, a !== null)) try {
      var l = t.lastRenderedState, o = a(l, n);
      if (i.hasEagerState = !0, i.eagerState = o, gn(o, l)) {
        var s = t.interleaved;
        s === null ? (i.next = i, hc(t)) : (i.next = s.next, s.next = i), t.interleaved = i;
        return;
      }
    } catch {
    } finally {
    }
    n = Xp(e, t, i, r), n !== null && (i = Et(), pn(n, e, r, i), vm(n, t, r));
  }
}
function mm(e) {
  var t = e.alternate;
  return e === $e || t !== null && t === $e;
}
function gm(e, t) {
  ba = _o = !0;
  var n = e.pending;
  n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
}
function vm(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, Ju(e, n);
  }
}
var To = { readContext: tn, useCallback: ct, useContext: ct, useEffect: ct, useImperativeHandle: ct, useInsertionEffect: ct, useLayoutEffect: ct, useMemo: ct, useReducer: ct, useRef: ct, useState: ct, useDebugValue: ct, useDeferredValue: ct, useTransition: ct, useMutableSource: ct, useSyncExternalStore: ct, useId: ct, unstable_isNewReconciler: !1 }, A5 = { readContext: tn, useCallback: function(e, t) {
  return kn().memoizedState = [e, t === void 0 ? null : t], e;
}, useContext: tn, useEffect: hf, useImperativeHandle: function(e, t, n) {
  return n = n != null ? n.concat([e]) : null, Ql(
    4194308,
    4,
    um.bind(null, t, e),
    n
  );
}, useLayoutEffect: function(e, t) {
  return Ql(4194308, 4, e, t);
}, useInsertionEffect: function(e, t) {
  return Ql(4, 2, e, t);
}, useMemo: function(e, t) {
  var n = kn();
  return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e;
}, useReducer: function(e, t, n) {
  var r = kn();
  return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = T5.bind(null, $e, e), [r.memoizedState, e];
}, useRef: function(e) {
  var t = kn();
  return e = { current: e }, t.memoizedState = e;
}, useState: ff, useDebugValue: kc, useDeferredValue: function(e) {
  return kn().memoizedState = e;
}, useTransition: function() {
  var e = ff(!1), t = e[0];
  return e = _5.bind(null, e[1]), kn().memoizedState = e, [t, e];
}, useMutableSource: function() {
}, useSyncExternalStore: function(e, t, n) {
  var r = $e, i = kn();
  if (Le) {
    if (n === void 0) throw Error(W(407));
    n = n();
  } else {
    if (n = t(), it === null) throw Error(W(349));
    Kr & 30 || tm(r, t, n);
  }
  i.memoizedState = n;
  var a = { value: n, getSnapshot: t };
  return i.queue = a, hf(rm.bind(
    null,
    r,
    a,
    e
  ), [e]), r.flags |= 2048, Ha(9, nm.bind(null, r, a, n, t), void 0, null), n;
}, useId: function() {
  var e = kn(), t = it.identifierPrefix;
  if (Le) {
    var n = Un, r = Fn;
    n = (r & ~(1 << 32 - hn(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Ua++, 0 < n && (t += "H" + n.toString(32)), t += ":";
  } else n = S5++, t = ":" + t + "r" + n.toString(32) + ":";
  return e.memoizedState = t;
}, unstable_isNewReconciler: !1 }, C5 = {
  readContext: tn,
  useCallback: dm,
  useContext: tn,
  useEffect: xc,
  useImperativeHandle: cm,
  useInsertionEffect: om,
  useLayoutEffect: sm,
  useMemo: fm,
  useReducer: $s,
  useRef: lm,
  useState: function() {
    return $s($a);
  },
  useDebugValue: kc,
  useDeferredValue: function(e) {
    var t = nn();
    return hm(t, et.memoizedState, e);
  },
  useTransition: function() {
    var e = $s($a)[0], t = nn().memoizedState;
    return [e, t];
  },
  useMutableSource: Jp,
  useSyncExternalStore: em,
  useId: pm,
  unstable_isNewReconciler: !1
}, M5 = { readContext: tn, useCallback: dm, useContext: tn, useEffect: xc, useImperativeHandle: cm, useInsertionEffect: om, useLayoutEffect: sm, useMemo: fm, useReducer: Hs, useRef: lm, useState: function() {
  return Hs($a);
}, useDebugValue: kc, useDeferredValue: function(e) {
  var t = nn();
  return et === null ? t.memoizedState = e : hm(t, et.memoizedState, e);
}, useTransition: function() {
  var e = Hs($a)[0], t = nn().memoizedState;
  return [e, t];
}, useMutableSource: Jp, useSyncExternalStore: em, useId: pm, unstable_isNewReconciler: !1 };
function un(e, t) {
  if (e && e.defaultProps) {
    t = He({}, t), e = e.defaultProps;
    for (var n in e) t[n] === void 0 && (t[n] = e[n]);
    return t;
  }
  return t;
}
function ru(e, t, n, r) {
  t = e.memoizedState, n = n(r, t), n = n == null ? t : He({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n);
}
var Qo = { isMounted: function(e) {
  return (e = e._reactInternals) ? Qr(e) === e : !1;
}, enqueueSetState: function(e, t, n) {
  e = e._reactInternals;
  var r = Et(), i = yr(e), a = $n(r, i);
  a.payload = t, n != null && (a.callback = n), t = gr(e, a, i), t !== null && (pn(t, e, i, r), Xl(t, e, i));
}, enqueueReplaceState: function(e, t, n) {
  e = e._reactInternals;
  var r = Et(), i = yr(e), a = $n(r, i);
  a.tag = 1, a.payload = t, n != null && (a.callback = n), t = gr(e, a, i), t !== null && (pn(t, e, i, r), Xl(t, e, i));
}, enqueueForceUpdate: function(e, t) {
  e = e._reactInternals;
  var n = Et(), r = yr(e), i = $n(n, r);
  i.tag = 2, t != null && (i.callback = t), t = gr(e, i, r), t !== null && (pn(t, e, r, n), Xl(t, e, r));
} };
function pf(e, t, n, r, i, a, l) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, a, l) : t.prototype && t.prototype.isPureReactComponent ? !Da(n, r) || !Da(i, a) : !0;
}
function ym(e, t, n) {
  var r = !1, i = xr, a = t.contextType;
  return typeof a == "object" && a !== null ? a = tn(a) : (i = Rt(t) ? Vr : pt.current, r = t.contextTypes, a = (r = r != null) ? Ii(e, i) : xr), t = new t(n, a), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Qo, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = a), t;
}
function mf(e, t, n, r) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Qo.enqueueReplaceState(t, t.state, null);
}
function iu(e, t, n, r) {
  var i = e.stateNode;
  i.props = n, i.state = e.memoizedState, i.refs = {}, pc(e);
  var a = t.contextType;
  typeof a == "object" && a !== null ? i.context = tn(a) : (a = Rt(t) ? Vr : pt.current, i.context = Ii(e, a)), i.state = e.memoizedState, a = t.getDerivedStateFromProps, typeof a == "function" && (ru(e, t, a, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Qo.enqueueReplaceState(i, i.state, null), Eo(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308);
}
function Pi(e, t) {
  try {
    var n = "", r = t;
    do
      n += i3(r), r = r.return;
    while (r);
    var i = n;
  } catch (a) {
    i = `
Error generating stack: ` + a.message + `
` + a.stack;
  }
  return { value: e, source: t, stack: i, digest: null };
}
function qs(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null };
}
function au(e, t) {
  try {
    console.error(t.value);
  } catch (n) {
    setTimeout(function() {
      throw n;
    });
  }
}
var O5 = typeof WeakMap == "function" ? WeakMap : Map;
function bm(e, t, n) {
  n = $n(-1, n), n.tag = 3, n.payload = { element: null };
  var r = t.value;
  return n.callback = function() {
    Ao || (Ao = !0, mu = r), au(e, t);
  }, n;
}
function wm(e, t, n) {
  n = $n(-1, n), n.tag = 3;
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = t.value;
    n.payload = function() {
      return r(i);
    }, n.callback = function() {
      au(e, t);
    };
  }
  var a = e.stateNode;
  return a !== null && typeof a.componentDidCatch == "function" && (n.callback = function() {
    au(e, t), typeof r != "function" && (vr === null ? vr = /* @__PURE__ */ new Set([this]) : vr.add(this));
    var l = t.stack;
    this.componentDidCatch(t.value, { componentStack: l !== null ? l : "" });
  }), n;
}
function gf(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
    r = e.pingCache = new O5();
    var i = /* @__PURE__ */ new Set();
    r.set(t, i);
  } else i = r.get(t), i === void 0 && (i = /* @__PURE__ */ new Set(), r.set(t, i));
  i.has(n) || (i.add(n), e = V5.bind(null, e, t, n), t.then(e, e));
}
function vf(e) {
  do {
    var t;
    if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function yf(e, t, n, r, i) {
  return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = $n(-1, 1), t.tag = 2, gr(n, t, 1))), n.lanes |= 1), e);
}
var R5 = Zn.ReactCurrentOwner, Mt = !1;
function bt(e, t, n, r) {
  t.child = e === null ? jp(t, null, n, r) : zi(t, e.child, n, r);
}
function bf(e, t, n, r, i) {
  n = n.render;
  var a = t.ref;
  return Ai(t, i), r = bc(e, t, n, r, a, i), n = wc(), e !== null && !Mt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Kn(e, t, i)) : (Le && n && oc(t), t.flags |= 1, bt(e, t, r, i), t.child);
}
function wf(e, t, n, r, i) {
  if (e === null) {
    var a = n.type;
    return typeof a == "function" && !Mc(a) && a.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = a, xm(e, t, a, r, i)) : (e = no(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e);
  }
  if (a = e.child, !(e.lanes & i)) {
    var l = a.memoizedProps;
    if (n = n.compare, n = n !== null ? n : Da, n(l, r) && e.ref === t.ref) return Kn(e, t, i);
  }
  return t.flags |= 1, e = br(a, r), e.ref = t.ref, e.return = t, t.child = e;
}
function xm(e, t, n, r, i) {
  if (e !== null) {
    var a = e.memoizedProps;
    if (Da(a, r) && e.ref === t.ref) if (Mt = !1, t.pendingProps = r = a, (e.lanes & i) !== 0) e.flags & 131072 && (Mt = !0);
    else return t.lanes = e.lanes, Kn(e, t, i);
  }
  return lu(e, t, n, r, i);
}
function km(e, t, n) {
  var r = t.pendingProps, i = r.children, a = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Re(Ei, Bt), Bt |= n;
  else {
    if (!(n & 1073741824)) return e = a !== null ? a.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Re(Ei, Bt), Bt |= e, null;
    t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = a !== null ? a.baseLanes : n, Re(Ei, Bt), Bt |= r;
  }
  else a !== null ? (r = a.baseLanes | n, t.memoizedState = null) : r = n, Re(Ei, Bt), Bt |= r;
  return bt(e, t, i, n), t.child;
}
function Em(e, t) {
  var n = t.ref;
  (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152);
}
function lu(e, t, n, r, i) {
  var a = Rt(n) ? Vr : pt.current;
  return a = Ii(t, a), Ai(t, i), n = bc(e, t, n, r, a, i), r = wc(), e !== null && !Mt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Kn(e, t, i)) : (Le && r && oc(t), t.flags |= 1, bt(e, t, n, i), t.child);
}
function xf(e, t, n, r, i) {
  if (Rt(n)) {
    var a = !0;
    yo(t);
  } else a = !1;
  if (Ai(t, i), t.stateNode === null) Jl(e, t), ym(t, n, r), iu(t, n, r, i), r = !0;
  else if (e === null) {
    var l = t.stateNode, o = t.memoizedProps;
    l.props = o;
    var s = l.context, u = n.contextType;
    typeof u == "object" && u !== null ? u = tn(u) : (u = Rt(n) ? Vr : pt.current, u = Ii(t, u));
    var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof l.getSnapshotBeforeUpdate == "function";
    d || typeof l.UNSAFE_componentWillReceiveProps != "function" && typeof l.componentWillReceiveProps != "function" || (o !== r || s !== u) && mf(t, l, r, u), ar = !1;
    var h = t.memoizedState;
    l.state = h, Eo(t, r, l, i), s = t.memoizedState, o !== r || h !== s || Ot.current || ar ? (typeof c == "function" && (ru(t, n, c, r), s = t.memoizedState), (o = ar || pf(t, n, o, r, h, s, u)) ? (d || typeof l.UNSAFE_componentWillMount != "function" && typeof l.componentWillMount != "function" || (typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount()), typeof l.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof l.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = s), l.props = r, l.state = s, l.context = u, r = o) : (typeof l.componentDidMount == "function" && (t.flags |= 4194308), r = !1);
  } else {
    l = t.stateNode, Zp(e, t), o = t.memoizedProps, u = t.type === t.elementType ? o : un(t.type, o), l.props = u, d = t.pendingProps, h = l.context, s = n.contextType, typeof s == "object" && s !== null ? s = tn(s) : (s = Rt(n) ? Vr : pt.current, s = Ii(t, s));
    var p = n.getDerivedStateFromProps;
    (c = typeof p == "function" || typeof l.getSnapshotBeforeUpdate == "function") || typeof l.UNSAFE_componentWillReceiveProps != "function" && typeof l.componentWillReceiveProps != "function" || (o !== d || h !== s) && mf(t, l, r, s), ar = !1, h = t.memoizedState, l.state = h, Eo(t, r, l, i);
    var g = t.memoizedState;
    o !== d || h !== g || Ot.current || ar ? (typeof p == "function" && (ru(t, n, p, r), g = t.memoizedState), (u = ar || pf(t, n, u, r, h, g, s) || !1) ? (c || typeof l.UNSAFE_componentWillUpdate != "function" && typeof l.componentWillUpdate != "function" || (typeof l.componentWillUpdate == "function" && l.componentWillUpdate(r, g, s), typeof l.UNSAFE_componentWillUpdate == "function" && l.UNSAFE_componentWillUpdate(r, g, s)), typeof l.componentDidUpdate == "function" && (t.flags |= 4), typeof l.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof l.componentDidUpdate != "function" || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof l.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = g), l.props = r, l.state = g, l.context = s, r = u) : (typeof l.componentDidUpdate != "function" || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof l.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1);
  }
  return ou(e, t, n, r, a, i);
}
function ou(e, t, n, r, i, a) {
  Em(e, t);
  var l = (t.flags & 128) !== 0;
  if (!r && !l) return i && lf(t, n, !1), Kn(e, t, a);
  r = t.stateNode, R5.current = t;
  var o = l && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return t.flags |= 1, e !== null && l ? (t.child = zi(t, e.child, null, a), t.child = zi(t, null, o, a)) : bt(e, t, o, a), t.memoizedState = r.state, i && lf(t, n, !0), t.child;
}
function Sm(e) {
  var t = e.stateNode;
  t.pendingContext ? af(e, t.pendingContext, t.pendingContext !== t.context) : t.context && af(e, t.context, !1), mc(e, t.containerInfo);
}
function kf(e, t, n, r, i) {
  return Di(), uc(i), t.flags |= 256, bt(e, t, n, r), t.child;
}
var su = { dehydrated: null, treeContext: null, retryLane: 0 };
function uu(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function _m(e, t, n) {
  var r = t.pendingProps, i = Fe.current, a = !1, l = (t.flags & 128) !== 0, o;
  if ((o = l) || (o = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), o ? (a = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Re(Fe, i & 1), e === null)
    return tu(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (l = r.children, e = r.fallback, a ? (r = t.mode, a = t.child, l = { mode: "hidden", children: l }, !(r & 1) && a !== null ? (a.childLanes = 0, a.pendingProps = l) : a = ts(l, r, 0, null), e = qr(e, r, n, null), a.return = t, e.return = t, a.sibling = e, t.child = a, t.child.memoizedState = uu(n), t.memoizedState = su, e) : Ec(t, l));
  if (i = e.memoizedState, i !== null && (o = i.dehydrated, o !== null)) return I5(e, t, l, r, o, i, n);
  if (a) {
    a = r.fallback, l = t.mode, i = e.child, o = i.sibling;
    var s = { mode: "hidden", children: r.children };
    return !(l & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = s, t.deletions = null) : (r = br(i, s), r.subtreeFlags = i.subtreeFlags & 14680064), o !== null ? a = br(o, a) : (a = qr(a, l, n, null), a.flags |= 2), a.return = t, r.return = t, r.sibling = a, t.child = r, r = a, a = t.child, l = e.child.memoizedState, l = l === null ? uu(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, a.memoizedState = l, a.childLanes = e.childLanes & ~n, t.memoizedState = su, r;
  }
  return a = e.child, e = a.sibling, r = br(a, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r;
}
function Ec(e, t) {
  return t = ts({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t;
}
function kl(e, t, n, r) {
  return r !== null && uc(r), zi(t, e.child, null, n), e = Ec(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
}
function I5(e, t, n, r, i, a, l) {
  if (n)
    return t.flags & 256 ? (t.flags &= -257, r = qs(Error(W(422))), kl(e, t, l, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = ts({ mode: "visible", children: r.children }, i, 0, null), a = qr(a, i, l, null), a.flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, t.mode & 1 && zi(t, e.child, null, l), t.child.memoizedState = uu(l), t.memoizedState = su, a);
  if (!(t.mode & 1)) return kl(e, t, l, null);
  if (i.data === "$!") {
    if (r = i.nextSibling && i.nextSibling.dataset, r) var o = r.dgst;
    return r = o, a = Error(W(419)), r = qs(a, r, void 0), kl(e, t, l, r);
  }
  if (o = (l & e.childLanes) !== 0, Mt || o) {
    if (r = it, r !== null) {
      switch (l & -l) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      i = i & (r.suspendedLanes | l) ? 0 : i, i !== 0 && i !== a.retryLane && (a.retryLane = i, Wn(e, i), pn(r, e, i, -1));
    }
    return Cc(), r = qs(Error(W(421))), kl(e, t, l, r);
  }
  return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = W5.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, Ut = mr(i.nextSibling), $t = t, Le = !0, fn = null, e !== null && (Kt[Yt++] = Fn, Kt[Yt++] = Un, Kt[Yt++] = Wr, Fn = e.id, Un = e.overflow, Wr = t), t = Ec(t, r.children), t.flags |= 4096, t);
}
function Ef(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), nu(e.return, t, n);
}
function Gs(e, t, n, r, i) {
  var a = e.memoizedState;
  a === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = r, a.tail = n, a.tailMode = i);
}
function Tm(e, t, n) {
  var r = t.pendingProps, i = r.revealOrder, a = r.tail;
  if (bt(e, t, r.children, n), r = Fe.current, r & 2) r = r & 1 | 2, t.flags |= 128;
  else {
    if (e !== null && e.flags & 128) e: for (e = t.child; e !== null; ) {
      if (e.tag === 13) e.memoizedState !== null && Ef(e, n, t);
      else if (e.tag === 19) Ef(e, n, t);
      else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t) break e;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) break e;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    r &= 1;
  }
  if (Re(Fe, r), !(t.mode & 1)) t.memoizedState = null;
  else switch (i) {
    case "forwards":
      for (n = t.child, i = null; n !== null; ) e = n.alternate, e !== null && So(e) === null && (i = n), n = n.sibling;
      n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Gs(t, !1, i, n, a);
      break;
    case "backwards":
      for (n = null, i = t.child, t.child = null; i !== null; ) {
        if (e = i.alternate, e !== null && So(e) === null) {
          t.child = i;
          break;
        }
        e = i.sibling, i.sibling = n, n = i, i = e;
      }
      Gs(t, !0, n, null, a);
      break;
    case "together":
      Gs(t, !1, null, null, void 0);
      break;
    default:
      t.memoizedState = null;
  }
  return t.child;
}
function Jl(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2);
}
function Kn(e, t, n) {
  if (e !== null && (t.dependencies = e.dependencies), Yr |= t.lanes, !(n & t.childLanes)) return null;
  if (e !== null && t.child !== e.child) throw Error(W(153));
  if (t.child !== null) {
    for (e = t.child, n = br(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; ) e = e.sibling, n = n.sibling = br(e, e.pendingProps), n.return = t;
    n.sibling = null;
  }
  return t.child;
}
function D5(e, t, n) {
  switch (t.tag) {
    case 3:
      Sm(t), Di();
      break;
    case 5:
      Qp(t);
      break;
    case 1:
      Rt(t.type) && yo(t);
      break;
    case 4:
      mc(t, t.stateNode.containerInfo);
      break;
    case 10:
      var r = t.type._context, i = t.memoizedProps.value;
      Re(xo, r._currentValue), r._currentValue = i;
      break;
    case 13:
      if (r = t.memoizedState, r !== null)
        return r.dehydrated !== null ? (Re(Fe, Fe.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? _m(e, t, n) : (Re(Fe, Fe.current & 1), e = Kn(e, t, n), e !== null ? e.sibling : null);
      Re(Fe, Fe.current & 1);
      break;
    case 19:
      if (r = (n & t.childLanes) !== 0, e.flags & 128) {
        if (r) return Tm(e, t, n);
        t.flags |= 128;
      }
      if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Re(Fe, Fe.current), r) break;
      return null;
    case 22:
    case 23:
      return t.lanes = 0, km(e, t, n);
  }
  return Kn(e, t, n);
}
var Nm, cu, Am, Cm;
Nm = function(e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      n.child.return = n, n = n.child;
      continue;
    }
    if (n === t) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return;
      n = n.return;
    }
    n.sibling.return = n.return, n = n.sibling;
  }
};
cu = function() {
};
Am = function(e, t, n, r) {
  var i = e.memoizedProps;
  if (i !== r) {
    e = t.stateNode, $r(An.current);
    var a = null;
    switch (n) {
      case "input":
        i = R0(e, i), r = R0(e, r), a = [];
        break;
      case "select":
        i = He({}, i, { value: void 0 }), r = He({}, r, { value: void 0 }), a = [];
        break;
      case "textarea":
        i = z0(e, i), r = z0(e, r), a = [];
        break;
      default:
        typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = go);
    }
    P0(n, r);
    var l;
    n = null;
    for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") {
      var o = i[u];
      for (l in o) o.hasOwnProperty(l) && (n || (n = {}), n[l] = "");
    } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Na.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null));
    for (u in r) {
      var s = r[u];
      if (o = i != null ? i[u] : void 0, r.hasOwnProperty(u) && s !== o && (s != null || o != null)) if (u === "style") if (o) {
        for (l in o) !o.hasOwnProperty(l) || s && s.hasOwnProperty(l) || (n || (n = {}), n[l] = "");
        for (l in s) s.hasOwnProperty(l) && o[l] !== s[l] && (n || (n = {}), n[l] = s[l]);
      } else n || (a || (a = []), a.push(
        u,
        n
      )), n = s;
      else u === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, o = o ? o.__html : void 0, s != null && o !== s && (a = a || []).push(u, s)) : u === "children" ? typeof s != "string" && typeof s != "number" || (a = a || []).push(u, "" + s) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Na.hasOwnProperty(u) ? (s != null && u === "onScroll" && De("scroll", e), a || o === s || (a = [])) : (a = a || []).push(u, s));
    }
    n && (a = a || []).push("style", n);
    var u = a;
    (t.updateQueue = u) && (t.flags |= 4);
  }
};
Cm = function(e, t, n, r) {
  n !== r && (t.flags |= 4);
};
function ia(e, t) {
  if (!Le) switch (e.tailMode) {
    case "hidden":
      t = e.tail;
      for (var n = null; t !== null; ) t.alternate !== null && (n = t), t = t.sibling;
      n === null ? e.tail = null : n.sibling = null;
      break;
    case "collapsed":
      n = e.tail;
      for (var r = null; n !== null; ) n.alternate !== null && (r = n), n = n.sibling;
      r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null;
  }
}
function dt(e) {
  var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0;
  if (t) for (var i = e.child; i !== null; ) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling;
  else for (i = e.child; i !== null; ) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
  return e.subtreeFlags |= r, e.childLanes = n, t;
}
function z5(e, t, n) {
  var r = t.pendingProps;
  switch (sc(t), t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return dt(t), null;
    case 1:
      return Rt(t.type) && vo(), dt(t), null;
    case 3:
      return r = t.stateNode, Li(), ze(Ot), ze(pt), vc(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (wl(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, fn !== null && (yu(fn), fn = null))), cu(e, t), dt(t), null;
    case 5:
      gc(t);
      var i = $r(Fa.current);
      if (n = t.type, e !== null && t.stateNode != null) Am(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(W(166));
          return dt(t), null;
        }
        if (e = $r(An.current), wl(t)) {
          r = t.stateNode, n = t.type;
          var a = t.memoizedProps;
          switch (r[_n] = t, r[Pa] = a, e = (t.mode & 1) !== 0, n) {
            case "dialog":
              De("cancel", r), De("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              De("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < fa.length; i++) De(fa[i], r);
              break;
            case "source":
              De("error", r);
              break;
            case "img":
            case "image":
            case "link":
              De(
                "error",
                r
              ), De("load", r);
              break;
            case "details":
              De("toggle", r);
              break;
            case "input":
              Od(r, a), De("invalid", r);
              break;
            case "select":
              r._wrapperState = { wasMultiple: !!a.multiple }, De("invalid", r);
              break;
            case "textarea":
              Id(r, a), De("invalid", r);
          }
          P0(n, a), i = null;
          for (var l in a) if (a.hasOwnProperty(l)) {
            var o = a[l];
            l === "children" ? typeof o == "string" ? r.textContent !== o && (a.suppressHydrationWarning !== !0 && bl(r.textContent, o, e), i = ["children", o]) : typeof o == "number" && r.textContent !== "" + o && (a.suppressHydrationWarning !== !0 && bl(
              r.textContent,
              o,
              e
            ), i = ["children", "" + o]) : Na.hasOwnProperty(l) && o != null && l === "onScroll" && De("scroll", r);
          }
          switch (n) {
            case "input":
              dl(r), Rd(r, a, !0);
              break;
            case "textarea":
              dl(r), Dd(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof a.onClick == "function" && (r.onclick = go);
          }
          r = i, t.updateQueue = r, r !== null && (t.flags |= 4);
        } else {
          l = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = rp(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = l.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), n === "select" && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[_n] = t, e[Pa] = r, Nm(e, t, !1, !1), t.stateNode = e;
          e: {
            switch (l = B0(n, r), n) {
              case "dialog":
                De("cancel", e), De("close", e), i = r;
                break;
              case "iframe":
              case "object":
              case "embed":
                De("load", e), i = r;
                break;
              case "video":
              case "audio":
                for (i = 0; i < fa.length; i++) De(fa[i], e);
                i = r;
                break;
              case "source":
                De("error", e), i = r;
                break;
              case "img":
              case "image":
              case "link":
                De(
                  "error",
                  e
                ), De("load", e), i = r;
                break;
              case "details":
                De("toggle", e), i = r;
                break;
              case "input":
                Od(e, r), i = R0(e, r), De("invalid", e);
                break;
              case "option":
                i = r;
                break;
              case "select":
                e._wrapperState = { wasMultiple: !!r.multiple }, i = He({}, r, { value: void 0 }), De("invalid", e);
                break;
              case "textarea":
                Id(e, r), i = z0(e, r), De("invalid", e);
                break;
              default:
                i = r;
            }
            P0(n, i), o = i;
            for (a in o) if (o.hasOwnProperty(a)) {
              var s = o[a];
              a === "style" ? lp(e, s) : a === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, s != null && ip(e, s)) : a === "children" ? typeof s == "string" ? (n !== "textarea" || s !== "") && Aa(e, s) : typeof s == "number" && Aa(e, "" + s) : a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && a !== "autoFocus" && (Na.hasOwnProperty(a) ? s != null && a === "onScroll" && De("scroll", e) : s != null && Ku(e, a, s, l));
            }
            switch (n) {
              case "input":
                dl(e), Rd(e, r, !1);
                break;
              case "textarea":
                dl(e), Dd(e);
                break;
              case "option":
                r.value != null && e.setAttribute("value", "" + wr(r.value));
                break;
              case "select":
                e.multiple = !!r.multiple, a = r.value, a != null ? Si(e, !!r.multiple, a, !1) : r.defaultValue != null && Si(
                  e,
                  !!r.multiple,
                  r.defaultValue,
                  !0
                );
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = go);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (t.flags |= 4);
        }
        t.ref !== null && (t.flags |= 512, t.flags |= 2097152);
      }
      return dt(t), null;
    case 6:
      if (e && t.stateNode != null) Cm(e, t, e.memoizedProps, r);
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(W(166));
        if (n = $r(Fa.current), $r(An.current), wl(t)) {
          if (r = t.stateNode, n = t.memoizedProps, r[_n] = t, (a = r.nodeValue !== n) && (e = $t, e !== null)) switch (e.tag) {
            case 3:
              bl(r.nodeValue, n, (e.mode & 1) !== 0);
              break;
            case 5:
              e.memoizedProps.suppressHydrationWarning !== !0 && bl(r.nodeValue, n, (e.mode & 1) !== 0);
          }
          a && (t.flags |= 4);
        } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[_n] = t, t.stateNode = r;
      }
      return dt(t), null;
    case 13:
      if (ze(Fe), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
        if (Le && Ut !== null && t.mode & 1 && !(t.flags & 128)) Kp(), Di(), t.flags |= 98560, a = !1;
        else if (a = wl(t), r !== null && r.dehydrated !== null) {
          if (e === null) {
            if (!a) throw Error(W(318));
            if (a = t.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(W(317));
            a[_n] = t;
          } else Di(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          dt(t), a = !1;
        } else fn !== null && (yu(fn), fn = null), a = !0;
        if (!a) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Fe.current & 1 ? tt === 0 && (tt = 3) : Cc())), t.updateQueue !== null && (t.flags |= 4), dt(t), null);
    case 4:
      return Li(), cu(e, t), e === null && za(t.stateNode.containerInfo), dt(t), null;
    case 10:
      return fc(t.type._context), dt(t), null;
    case 17:
      return Rt(t.type) && vo(), dt(t), null;
    case 19:
      if (ze(Fe), a = t.memoizedState, a === null) return dt(t), null;
      if (r = (t.flags & 128) !== 0, l = a.rendering, l === null) if (r) ia(a, !1);
      else {
        if (tt !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null; ) {
          if (l = So(e), l !== null) {
            for (t.flags |= 128, ia(a, !1), r = l.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null; ) a = n, e = r, a.flags &= 14680066, l = a.alternate, l === null ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling;
            return Re(Fe, Fe.current & 1 | 2), t.child;
          }
          e = e.sibling;
        }
        a.tail !== null && Ye() > Bi && (t.flags |= 128, r = !0, ia(a, !1), t.lanes = 4194304);
      }
      else {
        if (!r) if (e = So(l), e !== null) {
          if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), ia(a, !0), a.tail === null && a.tailMode === "hidden" && !l.alternate && !Le) return dt(t), null;
        } else 2 * Ye() - a.renderingStartTime > Bi && n !== 1073741824 && (t.flags |= 128, r = !0, ia(a, !1), t.lanes = 4194304);
        a.isBackwards ? (l.sibling = t.child, t.child = l) : (n = a.last, n !== null ? n.sibling = l : t.child = l, a.last = l);
      }
      return a.tail !== null ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Ye(), t.sibling = null, n = Fe.current, Re(Fe, r ? n & 1 | 2 : n & 1), t) : (dt(t), null);
    case 22:
    case 23:
      return Ac(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Bt & 1073741824 && (dt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : dt(t), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(W(156, t.tag));
}
function L5(e, t) {
  switch (sc(t), t.tag) {
    case 1:
      return Rt(t.type) && vo(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 3:
      return Li(), ze(Ot), ze(pt), vc(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
    case 5:
      return gc(t), null;
    case 13:
      if (ze(Fe), e = t.memoizedState, e !== null && e.dehydrated !== null) {
        if (t.alternate === null) throw Error(W(340));
        Di();
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 19:
      return ze(Fe), null;
    case 4:
      return Li(), null;
    case 10:
      return fc(t.type._context), null;
    case 22:
    case 23:
      return Ac(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var El = !1, ft = !1, P5 = typeof WeakSet == "function" ? WeakSet : Set, ne = null;
function ki(e, t) {
  var n = e.ref;
  if (n !== null) if (typeof n == "function") try {
    n(null);
  } catch (r) {
    We(e, t, r);
  }
  else n.current = null;
}
function du(e, t, n) {
  try {
    n();
  } catch (r) {
    We(e, t, r);
  }
}
var Sf = !1;
function B5(e, t) {
  if (Y0 = ho, e = Dp(), lc(e)) {
    if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd };
    else e: {
      n = (n = e.ownerDocument) && n.defaultView || window;
      var r = n.getSelection && n.getSelection();
      if (r && r.rangeCount !== 0) {
        n = r.anchorNode;
        var i = r.anchorOffset, a = r.focusNode;
        r = r.focusOffset;
        try {
          n.nodeType, a.nodeType;
        } catch {
          n = null;
          break e;
        }
        var l = 0, o = -1, s = -1, u = 0, c = 0, d = e, h = null;
        t: for (; ; ) {
          for (var p; d !== n || i !== 0 && d.nodeType !== 3 || (o = l + i), d !== a || r !== 0 && d.nodeType !== 3 || (s = l + r), d.nodeType === 3 && (l += d.nodeValue.length), (p = d.firstChild) !== null; )
            h = d, d = p;
          for (; ; ) {
            if (d === e) break t;
            if (h === n && ++u === i && (o = l), h === a && ++c === r && (s = l), (p = d.nextSibling) !== null) break;
            d = h, h = d.parentNode;
          }
          d = p;
        }
        n = o === -1 || s === -1 ? null : { start: o, end: s };
      } else n = null;
    }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (j0 = { focusedElem: e, selectionRange: n }, ho = !1, ne = t; ne !== null; ) if (t = ne, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, ne = e;
  else for (; ne !== null; ) {
    t = ne;
    try {
      var g = t.alternate;
      if (t.flags & 1024) switch (t.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (g !== null) {
            var w = g.memoizedProps, S = g.memoizedState, y = t.stateNode, v = y.getSnapshotBeforeUpdate(t.elementType === t.type ? w : un(t.type, w), S);
            y.__reactInternalSnapshotBeforeUpdate = v;
          }
          break;
        case 3:
          var x = t.stateNode.containerInfo;
          x.nodeType === 1 ? x.textContent = "" : x.nodeType === 9 && x.documentElement && x.removeChild(x.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(W(163));
      }
    } catch (C) {
      We(t, t.return, C);
    }
    if (e = t.sibling, e !== null) {
      e.return = t.return, ne = e;
      break;
    }
    ne = t.return;
  }
  return g = Sf, Sf = !1, g;
}
function wa(e, t, n) {
  var r = t.updateQueue;
  if (r = r !== null ? r.lastEffect : null, r !== null) {
    var i = r = r.next;
    do {
      if ((i.tag & e) === e) {
        var a = i.destroy;
        i.destroy = void 0, a !== void 0 && du(t, n, a);
      }
      i = i.next;
    } while (i !== r);
  }
}
function Jo(e, t) {
  if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
    var n = t = t.next;
    do {
      if ((n.tag & e) === e) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== t);
  }
}
function fu(e) {
  var t = e.ref;
  if (t !== null) {
    var n = e.stateNode;
    switch (e.tag) {
      case 5:
        e = n;
        break;
      default:
        e = n;
    }
    typeof t == "function" ? t(e) : t.current = e;
  }
}
function Mm(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, Mm(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[_n], delete t[Pa], delete t[Q0], delete t[w5], delete t[x5])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
}
function Om(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function _f(e) {
  e: for (; ; ) {
    for (; e.sibling === null; ) {
      if (e.return === null || Om(e.return)) return null;
      e = e.return;
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      e.child.return = e, e = e.child;
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function hu(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = go));
  else if (r !== 4 && (e = e.child, e !== null)) for (hu(e, t, n), e = e.sibling; e !== null; ) hu(e, t, n), e = e.sibling;
}
function pu(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && (e = e.child, e !== null)) for (pu(e, t, n), e = e.sibling; e !== null; ) pu(e, t, n), e = e.sibling;
}
var lt = null, cn = !1;
function er(e, t, n) {
  for (n = n.child; n !== null; ) Rm(e, t, n), n = n.sibling;
}
function Rm(e, t, n) {
  if (Nn && typeof Nn.onCommitFiberUnmount == "function") try {
    Nn.onCommitFiberUnmount(Vo, n);
  } catch {
  }
  switch (n.tag) {
    case 5:
      ft || ki(n, t);
    case 6:
      var r = lt, i = cn;
      lt = null, er(e, t, n), lt = r, cn = i, lt !== null && (cn ? (e = lt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : lt.removeChild(n.stateNode));
      break;
    case 18:
      lt !== null && (cn ? (e = lt, n = n.stateNode, e.nodeType === 8 ? Ps(e.parentNode, n) : e.nodeType === 1 && Ps(e, n), Ra(e)) : Ps(lt, n.stateNode));
      break;
    case 4:
      r = lt, i = cn, lt = n.stateNode.containerInfo, cn = !0, er(e, t, n), lt = r, cn = i;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!ft && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
        i = r = r.next;
        do {
          var a = i, l = a.destroy;
          a = a.tag, l !== void 0 && (a & 2 || a & 4) && du(n, t, l), i = i.next;
        } while (i !== r);
      }
      er(e, t, n);
      break;
    case 1:
      if (!ft && (ki(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
        r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount();
      } catch (o) {
        We(n, t, o);
      }
      er(e, t, n);
      break;
    case 21:
      er(e, t, n);
      break;
    case 22:
      n.mode & 1 ? (ft = (r = ft) || n.memoizedState !== null, er(e, t, n), ft = r) : er(e, t, n);
      break;
    default:
      er(e, t, n);
  }
}
function Tf(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var n = e.stateNode;
    n === null && (n = e.stateNode = new P5()), t.forEach(function(r) {
      var i = K5.bind(null, e, r);
      n.has(r) || (n.add(r), r.then(i, i));
    });
  }
}
function sn(e, t) {
  var n = t.deletions;
  if (n !== null) for (var r = 0; r < n.length; r++) {
    var i = n[r];
    try {
      var a = e, l = t, o = l;
      e: for (; o !== null; ) {
        switch (o.tag) {
          case 5:
            lt = o.stateNode, cn = !1;
            break e;
          case 3:
            lt = o.stateNode.containerInfo, cn = !0;
            break e;
          case 4:
            lt = o.stateNode.containerInfo, cn = !0;
            break e;
        }
        o = o.return;
      }
      if (lt === null) throw Error(W(160));
      Rm(a, l, i), lt = null, cn = !1;
      var s = i.alternate;
      s !== null && (s.return = null), i.return = null;
    } catch (u) {
      We(i, t, u);
    }
  }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) Im(t, e), t = t.sibling;
}
function Im(e, t) {
  var n = e.alternate, r = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (sn(t, e), wn(e), r & 4) {
        try {
          wa(3, e, e.return), Jo(3, e);
        } catch (w) {
          We(e, e.return, w);
        }
        try {
          wa(5, e, e.return);
        } catch (w) {
          We(e, e.return, w);
        }
      }
      break;
    case 1:
      sn(t, e), wn(e), r & 512 && n !== null && ki(n, n.return);
      break;
    case 5:
      if (sn(t, e), wn(e), r & 512 && n !== null && ki(n, n.return), e.flags & 32) {
        var i = e.stateNode;
        try {
          Aa(i, "");
        } catch (w) {
          We(e, e.return, w);
        }
      }
      if (r & 4 && (i = e.stateNode, i != null)) {
        var a = e.memoizedProps, l = n !== null ? n.memoizedProps : a, o = e.type, s = e.updateQueue;
        if (e.updateQueue = null, s !== null) try {
          o === "input" && a.type === "radio" && a.name != null && tp(i, a), B0(o, l);
          var u = B0(o, a);
          for (l = 0; l < s.length; l += 2) {
            var c = s[l], d = s[l + 1];
            c === "style" ? lp(i, d) : c === "dangerouslySetInnerHTML" ? ip(i, d) : c === "children" ? Aa(i, d) : Ku(i, c, d, u);
          }
          switch (o) {
            case "input":
              I0(i, a);
              break;
            case "textarea":
              np(i, a);
              break;
            case "select":
              var h = i._wrapperState.wasMultiple;
              i._wrapperState.wasMultiple = !!a.multiple;
              var p = a.value;
              p != null ? Si(i, !!a.multiple, p, !1) : h !== !!a.multiple && (a.defaultValue != null ? Si(
                i,
                !!a.multiple,
                a.defaultValue,
                !0
              ) : Si(i, !!a.multiple, a.multiple ? [] : "", !1));
          }
          i[Pa] = a;
        } catch (w) {
          We(e, e.return, w);
        }
      }
      break;
    case 6:
      if (sn(t, e), wn(e), r & 4) {
        if (e.stateNode === null) throw Error(W(162));
        i = e.stateNode, a = e.memoizedProps;
        try {
          i.nodeValue = a;
        } catch (w) {
          We(e, e.return, w);
        }
      }
      break;
    case 3:
      if (sn(t, e), wn(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
        Ra(t.containerInfo);
      } catch (w) {
        We(e, e.return, w);
      }
      break;
    case 4:
      sn(t, e), wn(e);
      break;
    case 13:
      sn(t, e), wn(e), i = e.child, i.flags & 8192 && (a = i.memoizedState !== null, i.stateNode.isHidden = a, !a || i.alternate !== null && i.alternate.memoizedState !== null || (Tc = Ye())), r & 4 && Tf(e);
      break;
    case 22:
      if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (ft = (u = ft) || c, sn(t, e), ft = u) : sn(t, e), wn(e), r & 8192) {
        if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (ne = e, c = e.child; c !== null; ) {
          for (d = ne = c; ne !== null; ) {
            switch (h = ne, p = h.child, h.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                wa(4, h, h.return);
                break;
              case 1:
                ki(h, h.return);
                var g = h.stateNode;
                if (typeof g.componentWillUnmount == "function") {
                  r = h, n = h.return;
                  try {
                    t = r, g.props = t.memoizedProps, g.state = t.memoizedState, g.componentWillUnmount();
                  } catch (w) {
                    We(r, n, w);
                  }
                }
                break;
              case 5:
                ki(h, h.return);
                break;
              case 22:
                if (h.memoizedState !== null) {
                  Af(d);
                  continue;
                }
            }
            p !== null ? (p.return = h, ne = p) : Af(d);
          }
          c = c.sibling;
        }
        e: for (c = null, d = e; ; ) {
          if (d.tag === 5) {
            if (c === null) {
              c = d;
              try {
                i = d.stateNode, u ? (a = i.style, typeof a.setProperty == "function" ? a.setProperty("display", "none", "important") : a.display = "none") : (o = d.stateNode, s = d.memoizedProps.style, l = s != null && s.hasOwnProperty("display") ? s.display : null, o.style.display = ap("display", l));
              } catch (w) {
                We(e, e.return, w);
              }
            }
          } else if (d.tag === 6) {
            if (c === null) try {
              d.stateNode.nodeValue = u ? "" : d.memoizedProps;
            } catch (w) {
              We(e, e.return, w);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === e) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e;
            c === d && (c = null), d = d.return;
          }
          c === d && (c = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      sn(t, e), wn(e), r & 4 && Tf(e);
      break;
    case 21:
      break;
    default:
      sn(
        t,
        e
      ), wn(e);
  }
}
function wn(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (Om(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(W(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (Aa(i, ""), r.flags &= -33);
          var a = _f(e);
          pu(e, a, i);
          break;
        case 3:
        case 4:
          var l = r.stateNode.containerInfo, o = _f(e);
          hu(e, o, l);
          break;
        default:
          throw Error(W(161));
      }
    } catch (s) {
      We(e, e.return, s);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function F5(e, t, n) {
  ne = e, Dm(e);
}
function Dm(e, t, n) {
  for (var r = (e.mode & 1) !== 0; ne !== null; ) {
    var i = ne, a = i.child;
    if (i.tag === 22 && r) {
      var l = i.memoizedState !== null || El;
      if (!l) {
        var o = i.alternate, s = o !== null && o.memoizedState !== null || ft;
        o = El;
        var u = ft;
        if (El = l, (ft = s) && !u) for (ne = i; ne !== null; ) l = ne, s = l.child, l.tag === 22 && l.memoizedState !== null ? Cf(i) : s !== null ? (s.return = l, ne = s) : Cf(i);
        for (; a !== null; ) ne = a, Dm(a), a = a.sibling;
        ne = i, El = o, ft = u;
      }
      Nf(e);
    } else i.subtreeFlags & 8772 && a !== null ? (a.return = i, ne = a) : Nf(e);
  }
}
function Nf(e) {
  for (; ne !== null; ) {
    var t = ne;
    if (t.flags & 8772) {
      var n = t.alternate;
      try {
        if (t.flags & 8772) switch (t.tag) {
          case 0:
          case 11:
          case 15:
            ft || Jo(5, t);
            break;
          case 1:
            var r = t.stateNode;
            if (t.flags & 4 && !ft) if (n === null) r.componentDidMount();
            else {
              var i = t.elementType === t.type ? n.memoizedProps : un(t.type, n.memoizedProps);
              r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
            }
            var a = t.updateQueue;
            a !== null && df(t, a, r);
            break;
          case 3:
            var l = t.updateQueue;
            if (l !== null) {
              if (n = null, t.child !== null) switch (t.child.tag) {
                case 5:
                  n = t.child.stateNode;
                  break;
                case 1:
                  n = t.child.stateNode;
              }
              df(t, l, n);
            }
            break;
          case 5:
            var o = t.stateNode;
            if (n === null && t.flags & 4) {
              n = o;
              var s = t.memoizedProps;
              switch (t.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  s.autoFocus && n.focus();
                  break;
                case "img":
                  s.src && (n.src = s.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (t.memoizedState === null) {
              var u = t.alternate;
              if (u !== null) {
                var c = u.memoizedState;
                if (c !== null) {
                  var d = c.dehydrated;
                  d !== null && Ra(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(W(163));
        }
        ft || t.flags & 512 && fu(t);
      } catch (h) {
        We(t, t.return, h);
      }
    }
    if (t === e) {
      ne = null;
      break;
    }
    if (n = t.sibling, n !== null) {
      n.return = t.return, ne = n;
      break;
    }
    ne = t.return;
  }
}
function Af(e) {
  for (; ne !== null; ) {
    var t = ne;
    if (t === e) {
      ne = null;
      break;
    }
    var n = t.sibling;
    if (n !== null) {
      n.return = t.return, ne = n;
      break;
    }
    ne = t.return;
  }
}
function Cf(e) {
  for (; ne !== null; ) {
    var t = ne;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return;
          try {
            Jo(4, t);
          } catch (s) {
            We(t, n, s);
          }
          break;
        case 1:
          var r = t.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = t.return;
            try {
              r.componentDidMount();
            } catch (s) {
              We(t, i, s);
            }
          }
          var a = t.return;
          try {
            fu(t);
          } catch (s) {
            We(t, a, s);
          }
          break;
        case 5:
          var l = t.return;
          try {
            fu(t);
          } catch (s) {
            We(t, l, s);
          }
      }
    } catch (s) {
      We(t, t.return, s);
    }
    if (t === e) {
      ne = null;
      break;
    }
    var o = t.sibling;
    if (o !== null) {
      o.return = t.return, ne = o;
      break;
    }
    ne = t.return;
  }
}
var U5 = Math.ceil, No = Zn.ReactCurrentDispatcher, Sc = Zn.ReactCurrentOwner, Jt = Zn.ReactCurrentBatchConfig, ke = 0, it = null, Ze = null, ot = 0, Bt = 0, Ei = Tr(0), tt = 0, qa = null, Yr = 0, es = 0, _c = 0, xa = null, Ct = null, Tc = 0, Bi = 1 / 0, Ln = null, Ao = !1, mu = null, vr = null, Sl = !1, ur = null, Co = 0, ka = 0, gu = null, eo = -1, to = 0;
function Et() {
  return ke & 6 ? Ye() : eo !== -1 ? eo : eo = Ye();
}
function yr(e) {
  return e.mode & 1 ? ke & 2 && ot !== 0 ? ot & -ot : E5.transition !== null ? (to === 0 && (to = yp()), to) : (e = _e, e !== 0 || (e = window.event, e = e === void 0 ? 16 : _p(e.type)), e) : 1;
}
function pn(e, t, n, r) {
  if (50 < ka) throw ka = 0, gu = null, Error(W(185));
  Qa(e, n, r), (!(ke & 2) || e !== it) && (e === it && (!(ke & 2) && (es |= n), tt === 4 && or(e, ot)), It(e, r), n === 1 && ke === 0 && !(t.mode & 1) && (Bi = Ye() + 500, Xo && Nr()));
}
function It(e, t) {
  var n = e.callbackNode;
  E3(e, t);
  var r = fo(e, e === it ? ot : 0);
  if (r === 0) n !== null && Pd(n), e.callbackNode = null, e.callbackPriority = 0;
  else if (t = r & -r, e.callbackPriority !== t) {
    if (n != null && Pd(n), t === 1) e.tag === 0 ? k5(Mf.bind(null, e)) : Gp(Mf.bind(null, e)), y5(function() {
      !(ke & 6) && Nr();
    }), n = null;
    else {
      switch (bp(r)) {
        case 1:
          n = Qu;
          break;
        case 4:
          n = gp;
          break;
        case 16:
          n = co;
          break;
        case 536870912:
          n = vp;
          break;
        default:
          n = co;
      }
      n = Hm(n, zm.bind(null, e));
    }
    e.callbackPriority = t, e.callbackNode = n;
  }
}
function zm(e, t) {
  if (eo = -1, to = 0, ke & 6) throw Error(W(327));
  var n = e.callbackNode;
  if (Ci() && e.callbackNode !== n) return null;
  var r = fo(e, e === it ? ot : 0);
  if (r === 0) return null;
  if (r & 30 || r & e.expiredLanes || t) t = Mo(e, r);
  else {
    t = r;
    var i = ke;
    ke |= 2;
    var a = Pm();
    (it !== e || ot !== t) && (Ln = null, Bi = Ye() + 500, Hr(e, t));
    do
      try {
        q5();
        break;
      } catch (o) {
        Lm(e, o);
      }
    while (!0);
    dc(), No.current = a, ke = i, Ze !== null ? t = 0 : (it = null, ot = 0, t = tt);
  }
  if (t !== 0) {
    if (t === 2 && (i = q0(e), i !== 0 && (r = i, t = vu(e, i))), t === 1) throw n = qa, Hr(e, 0), or(e, r), It(e, Ye()), n;
    if (t === 6) or(e, r);
    else {
      if (i = e.current.alternate, !(r & 30) && !$5(i) && (t = Mo(e, r), t === 2 && (a = q0(e), a !== 0 && (r = a, t = vu(e, a))), t === 1)) throw n = qa, Hr(e, 0), or(e, r), It(e, Ye()), n;
      switch (e.finishedWork = i, e.finishedLanes = r, t) {
        case 0:
        case 1:
          throw Error(W(345));
        case 2:
          Pr(e, Ct, Ln);
          break;
        case 3:
          if (or(e, r), (r & 130023424) === r && (t = Tc + 500 - Ye(), 10 < t)) {
            if (fo(e, 0) !== 0) break;
            if (i = e.suspendedLanes, (i & r) !== r) {
              Et(), e.pingedLanes |= e.suspendedLanes & i;
              break;
            }
            e.timeoutHandle = Z0(Pr.bind(null, e, Ct, Ln), t);
            break;
          }
          Pr(e, Ct, Ln);
          break;
        case 4:
          if (or(e, r), (r & 4194240) === r) break;
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var l = 31 - hn(r);
            a = 1 << l, l = t[l], l > i && (i = l), r &= ~a;
          }
          if (r = i, r = Ye() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * U5(r / 1960)) - r, 10 < r) {
            e.timeoutHandle = Z0(Pr.bind(null, e, Ct, Ln), r);
            break;
          }
          Pr(e, Ct, Ln);
          break;
        case 5:
          Pr(e, Ct, Ln);
          break;
        default:
          throw Error(W(329));
      }
    }
  }
  return It(e, Ye()), e.callbackNode === n ? zm.bind(null, e) : null;
}
function vu(e, t) {
  var n = xa;
  return e.current.memoizedState.isDehydrated && (Hr(e, t).flags |= 256), e = Mo(e, t), e !== 2 && (t = Ct, Ct = n, t !== null && yu(t)), e;
}
function yu(e) {
  Ct === null ? Ct = e : Ct.push.apply(Ct, e);
}
function $5(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue;
      if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) {
        var i = n[r], a = i.getSnapshot;
        i = i.value;
        try {
          if (!gn(a(), i)) return !1;
        } catch {
          return !1;
        }
      }
    }
    if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
  }
  return !0;
}
function or(e, t) {
  for (t &= ~_c, t &= ~es, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t; ) {
    var n = 31 - hn(t), r = 1 << n;
    e[n] = -1, t &= ~r;
  }
}
function Mf(e) {
  if (ke & 6) throw Error(W(327));
  Ci();
  var t = fo(e, 0);
  if (!(t & 1)) return It(e, Ye()), null;
  var n = Mo(e, t);
  if (e.tag !== 0 && n === 2) {
    var r = q0(e);
    r !== 0 && (t = r, n = vu(e, r));
  }
  if (n === 1) throw n = qa, Hr(e, 0), or(e, t), It(e, Ye()), n;
  if (n === 6) throw Error(W(345));
  return e.finishedWork = e.current.alternate, e.finishedLanes = t, Pr(e, Ct, Ln), It(e, Ye()), null;
}
function Nc(e, t) {
  var n = ke;
  ke |= 1;
  try {
    return e(t);
  } finally {
    ke = n, ke === 0 && (Bi = Ye() + 500, Xo && Nr());
  }
}
function jr(e) {
  ur !== null && ur.tag === 0 && !(ke & 6) && Ci();
  var t = ke;
  ke |= 1;
  var n = Jt.transition, r = _e;
  try {
    if (Jt.transition = null, _e = 1, e) return e();
  } finally {
    _e = r, Jt.transition = n, ke = t, !(ke & 6) && Nr();
  }
}
function Ac() {
  Bt = Ei.current, ze(Ei);
}
function Hr(e, t) {
  e.finishedWork = null, e.finishedLanes = 0;
  var n = e.timeoutHandle;
  if (n !== -1 && (e.timeoutHandle = -1, v5(n)), Ze !== null) for (n = Ze.return; n !== null; ) {
    var r = n;
    switch (sc(r), r.tag) {
      case 1:
        r = r.type.childContextTypes, r != null && vo();
        break;
      case 3:
        Li(), ze(Ot), ze(pt), vc();
        break;
      case 5:
        gc(r);
        break;
      case 4:
        Li();
        break;
      case 13:
        ze(Fe);
        break;
      case 19:
        ze(Fe);
        break;
      case 10:
        fc(r.type._context);
        break;
      case 22:
      case 23:
        Ac();
    }
    n = n.return;
  }
  if (it = e, Ze = e = br(e.current, null), ot = Bt = t, tt = 0, qa = null, _c = es = Yr = 0, Ct = xa = null, Ur !== null) {
    for (t = 0; t < Ur.length; t++) if (n = Ur[t], r = n.interleaved, r !== null) {
      n.interleaved = null;
      var i = r.next, a = n.pending;
      if (a !== null) {
        var l = a.next;
        a.next = i, r.next = l;
      }
      n.pending = r;
    }
    Ur = null;
  }
  return e;
}
function Lm(e, t) {
  do {
    var n = Ze;
    try {
      if (dc(), Zl.current = To, _o) {
        for (var r = $e.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), r = r.next;
        }
        _o = !1;
      }
      if (Kr = 0, rt = et = $e = null, ba = !1, Ua = 0, Sc.current = null, n === null || n.return === null) {
        tt = 1, qa = t, Ze = null;
        break;
      }
      e: {
        var a = e, l = n.return, o = n, s = t;
        if (t = ot, o.flags |= 32768, s !== null && typeof s == "object" && typeof s.then == "function") {
          var u = s, c = o, d = c.tag;
          if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var h = c.alternate;
            h ? (c.updateQueue = h.updateQueue, c.memoizedState = h.memoizedState, c.lanes = h.lanes) : (c.updateQueue = null, c.memoizedState = null);
          }
          var p = vf(l);
          if (p !== null) {
            p.flags &= -257, yf(p, l, o, a, t), p.mode & 1 && gf(a, u, t), t = p, s = u;
            var g = t.updateQueue;
            if (g === null) {
              var w = /* @__PURE__ */ new Set();
              w.add(s), t.updateQueue = w;
            } else g.add(s);
            break e;
          } else {
            if (!(t & 1)) {
              gf(a, u, t), Cc();
              break e;
            }
            s = Error(W(426));
          }
        } else if (Le && o.mode & 1) {
          var S = vf(l);
          if (S !== null) {
            !(S.flags & 65536) && (S.flags |= 256), yf(S, l, o, a, t), uc(Pi(s, o));
            break e;
          }
        }
        a = s = Pi(s, o), tt !== 4 && (tt = 2), xa === null ? xa = [a] : xa.push(a), a = l;
        do {
          switch (a.tag) {
            case 3:
              a.flags |= 65536, t &= -t, a.lanes |= t;
              var y = bm(a, s, t);
              cf(a, y);
              break e;
            case 1:
              o = s;
              var v = a.type, x = a.stateNode;
              if (!(a.flags & 128) && (typeof v.getDerivedStateFromError == "function" || x !== null && typeof x.componentDidCatch == "function" && (vr === null || !vr.has(x)))) {
                a.flags |= 65536, t &= -t, a.lanes |= t;
                var C = wm(a, o, t);
                cf(a, C);
                break e;
              }
          }
          a = a.return;
        } while (a !== null);
      }
      Fm(n);
    } catch (R) {
      t = R, Ze === n && n !== null && (Ze = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function Pm() {
  var e = No.current;
  return No.current = To, e === null ? To : e;
}
function Cc() {
  (tt === 0 || tt === 3 || tt === 2) && (tt = 4), it === null || !(Yr & 268435455) && !(es & 268435455) || or(it, ot);
}
function Mo(e, t) {
  var n = ke;
  ke |= 2;
  var r = Pm();
  (it !== e || ot !== t) && (Ln = null, Hr(e, t));
  do
    try {
      H5();
      break;
    } catch (i) {
      Lm(e, i);
    }
  while (!0);
  if (dc(), ke = n, No.current = r, Ze !== null) throw Error(W(261));
  return it = null, ot = 0, tt;
}
function H5() {
  for (; Ze !== null; ) Bm(Ze);
}
function q5() {
  for (; Ze !== null && !p3(); ) Bm(Ze);
}
function Bm(e) {
  var t = $m(e.alternate, e, Bt);
  e.memoizedProps = e.pendingProps, t === null ? Fm(e) : Ze = t, Sc.current = null;
}
function Fm(e) {
  var t = e;
  do {
    var n = t.alternate;
    if (e = t.return, t.flags & 32768) {
      if (n = L5(n, t), n !== null) {
        n.flags &= 32767, Ze = n;
        return;
      }
      if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
      else {
        tt = 6, Ze = null;
        return;
      }
    } else if (n = z5(n, t, Bt), n !== null) {
      Ze = n;
      return;
    }
    if (t = t.sibling, t !== null) {
      Ze = t;
      return;
    }
    Ze = t = e;
  } while (t !== null);
  tt === 0 && (tt = 5);
}
function Pr(e, t, n) {
  var r = _e, i = Jt.transition;
  try {
    Jt.transition = null, _e = 1, G5(e, t, n, r);
  } finally {
    Jt.transition = i, _e = r;
  }
  return null;
}
function G5(e, t, n, r) {
  do
    Ci();
  while (ur !== null);
  if (ke & 6) throw Error(W(327));
  n = e.finishedWork;
  var i = e.finishedLanes;
  if (n === null) return null;
  if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(W(177));
  e.callbackNode = null, e.callbackPriority = 0;
  var a = n.lanes | n.childLanes;
  if (S3(e, a), e === it && (Ze = it = null, ot = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Sl || (Sl = !0, Hm(co, function() {
    return Ci(), null;
  })), a = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || a) {
    a = Jt.transition, Jt.transition = null;
    var l = _e;
    _e = 1;
    var o = ke;
    ke |= 4, Sc.current = null, B5(e, n), Im(n, e), c5(j0), ho = !!Y0, j0 = Y0 = null, e.current = n, F5(n), m3(), ke = o, _e = l, Jt.transition = a;
  } else e.current = n;
  if (Sl && (Sl = !1, ur = e, Co = i), a = e.pendingLanes, a === 0 && (vr = null), y3(n.stateNode), It(e, Ye()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest });
  if (Ao) throw Ao = !1, e = mu, mu = null, e;
  return Co & 1 && e.tag !== 0 && Ci(), a = e.pendingLanes, a & 1 ? e === gu ? ka++ : (ka = 0, gu = e) : ka = 0, Nr(), null;
}
function Ci() {
  if (ur !== null) {
    var e = bp(Co), t = Jt.transition, n = _e;
    try {
      if (Jt.transition = null, _e = 16 > e ? 16 : e, ur === null) var r = !1;
      else {
        if (e = ur, ur = null, Co = 0, ke & 6) throw Error(W(331));
        var i = ke;
        for (ke |= 4, ne = e.current; ne !== null; ) {
          var a = ne, l = a.child;
          if (ne.flags & 16) {
            var o = a.deletions;
            if (o !== null) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                for (ne = u; ne !== null; ) {
                  var c = ne;
                  switch (c.tag) {
                    case 0:
                    case 11:
                    case 15:
                      wa(8, c, a);
                  }
                  var d = c.child;
                  if (d !== null) d.return = c, ne = d;
                  else for (; ne !== null; ) {
                    c = ne;
                    var h = c.sibling, p = c.return;
                    if (Mm(c), c === u) {
                      ne = null;
                      break;
                    }
                    if (h !== null) {
                      h.return = p, ne = h;
                      break;
                    }
                    ne = p;
                  }
                }
              }
              var g = a.alternate;
              if (g !== null) {
                var w = g.child;
                if (w !== null) {
                  g.child = null;
                  do {
                    var S = w.sibling;
                    w.sibling = null, w = S;
                  } while (w !== null);
                }
              }
              ne = a;
            }
          }
          if (a.subtreeFlags & 2064 && l !== null) l.return = a, ne = l;
          else e: for (; ne !== null; ) {
            if (a = ne, a.flags & 2048) switch (a.tag) {
              case 0:
              case 11:
              case 15:
                wa(9, a, a.return);
            }
            var y = a.sibling;
            if (y !== null) {
              y.return = a.return, ne = y;
              break e;
            }
            ne = a.return;
          }
        }
        var v = e.current;
        for (ne = v; ne !== null; ) {
          l = ne;
          var x = l.child;
          if (l.subtreeFlags & 2064 && x !== null) x.return = l, ne = x;
          else e: for (l = v; ne !== null; ) {
            if (o = ne, o.flags & 2048) try {
              switch (o.tag) {
                case 0:
                case 11:
                case 15:
                  Jo(9, o);
              }
            } catch (R) {
              We(o, o.return, R);
            }
            if (o === l) {
              ne = null;
              break e;
            }
            var C = o.sibling;
            if (C !== null) {
              C.return = o.return, ne = C;
              break e;
            }
            ne = o.return;
          }
        }
        if (ke = i, Nr(), Nn && typeof Nn.onPostCommitFiberRoot == "function") try {
          Nn.onPostCommitFiberRoot(Vo, e);
        } catch {
        }
        r = !0;
      }
      return r;
    } finally {
      _e = n, Jt.transition = t;
    }
  }
  return !1;
}
function Of(e, t, n) {
  t = Pi(n, t), t = bm(e, t, 1), e = gr(e, t, 1), t = Et(), e !== null && (Qa(e, 1, t), It(e, t));
}
function We(e, t, n) {
  if (e.tag === 3) Of(e, e, n);
  else for (; t !== null; ) {
    if (t.tag === 3) {
      Of(t, e, n);
      break;
    } else if (t.tag === 1) {
      var r = t.stateNode;
      if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (vr === null || !vr.has(r))) {
        e = Pi(n, e), e = wm(t, e, 1), t = gr(t, e, 1), e = Et(), t !== null && (Qa(t, 1, e), It(t, e));
        break;
      }
    }
    t = t.return;
  }
}
function V5(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t), t = Et(), e.pingedLanes |= e.suspendedLanes & n, it === e && (ot & n) === n && (tt === 4 || tt === 3 && (ot & 130023424) === ot && 500 > Ye() - Tc ? Hr(e, 0) : _c |= n), It(e, t);
}
function Um(e, t) {
  t === 0 && (e.mode & 1 ? (t = pl, pl <<= 1, !(pl & 130023424) && (pl = 4194304)) : t = 1);
  var n = Et();
  e = Wn(e, t), e !== null && (Qa(e, t, n), It(e, n));
}
function W5(e) {
  var t = e.memoizedState, n = 0;
  t !== null && (n = t.retryLane), Um(e, n);
}
function K5(e, t) {
  var n = 0;
  switch (e.tag) {
    case 13:
      var r = e.stateNode, i = e.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = e.stateNode;
      break;
    default:
      throw Error(W(314));
  }
  r !== null && r.delete(t), Um(e, n);
}
var $m;
$m = function(e, t, n) {
  if (e !== null) if (e.memoizedProps !== t.pendingProps || Ot.current) Mt = !0;
  else {
    if (!(e.lanes & n) && !(t.flags & 128)) return Mt = !1, D5(e, t, n);
    Mt = !!(e.flags & 131072);
  }
  else Mt = !1, Le && t.flags & 1048576 && Vp(t, wo, t.index);
  switch (t.lanes = 0, t.tag) {
    case 2:
      var r = t.type;
      Jl(e, t), e = t.pendingProps;
      var i = Ii(t, pt.current);
      Ai(t, n), i = bc(null, t, r, e, i, n);
      var a = wc();
      return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Rt(r) ? (a = !0, yo(t)) : a = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, pc(t), i.updater = Qo, t.stateNode = i, i._reactInternals = t, iu(t, r, e, n), t = ou(null, t, r, !0, a, n)) : (t.tag = 0, Le && a && oc(t), bt(null, t, i, n), t = t.child), t;
    case 16:
      r = t.elementType;
      e: {
        switch (Jl(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = j5(r), e = un(r, e), i) {
          case 0:
            t = lu(null, t, r, e, n);
            break e;
          case 1:
            t = xf(null, t, r, e, n);
            break e;
          case 11:
            t = bf(null, t, r, e, n);
            break e;
          case 14:
            t = wf(null, t, r, un(r.type, e), n);
            break e;
        }
        throw Error(W(
          306,
          r,
          ""
        ));
      }
      return t;
    case 0:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : un(r, i), lu(e, t, r, i, n);
    case 1:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : un(r, i), xf(e, t, r, i, n);
    case 3:
      e: {
        if (Sm(t), e === null) throw Error(W(387));
        r = t.pendingProps, a = t.memoizedState, i = a.element, Zp(e, t), Eo(t, r, null, n);
        var l = t.memoizedState;
        if (r = l.element, a.isDehydrated) if (a = { element: r, isDehydrated: !1, cache: l.cache, pendingSuspenseBoundaries: l.pendingSuspenseBoundaries, transitions: l.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, t.flags & 256) {
          i = Pi(Error(W(423)), t), t = kf(e, t, r, n, i);
          break e;
        } else if (r !== i) {
          i = Pi(Error(W(424)), t), t = kf(e, t, r, n, i);
          break e;
        } else for (Ut = mr(t.stateNode.containerInfo.firstChild), $t = t, Le = !0, fn = null, n = jp(t, null, r, n), t.child = n; n; ) n.flags = n.flags & -3 | 4096, n = n.sibling;
        else {
          if (Di(), r === i) {
            t = Kn(e, t, n);
            break e;
          }
          bt(e, t, r, n);
        }
        t = t.child;
      }
      return t;
    case 5:
      return Qp(t), e === null && tu(t), r = t.type, i = t.pendingProps, a = e !== null ? e.memoizedProps : null, l = i.children, X0(r, i) ? l = null : a !== null && X0(r, a) && (t.flags |= 32), Em(e, t), bt(e, t, l, n), t.child;
    case 6:
      return e === null && tu(t), null;
    case 13:
      return _m(e, t, n);
    case 4:
      return mc(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = zi(t, null, r, n) : bt(e, t, r, n), t.child;
    case 11:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : un(r, i), bf(e, t, r, i, n);
    case 7:
      return bt(e, t, t.pendingProps, n), t.child;
    case 8:
      return bt(e, t, t.pendingProps.children, n), t.child;
    case 12:
      return bt(e, t, t.pendingProps.children, n), t.child;
    case 10:
      e: {
        if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, l = i.value, Re(xo, r._currentValue), r._currentValue = l, a !== null) if (gn(a.value, l)) {
          if (a.children === i.children && !Ot.current) {
            t = Kn(e, t, n);
            break e;
          }
        } else for (a = t.child, a !== null && (a.return = t); a !== null; ) {
          var o = a.dependencies;
          if (o !== null) {
            l = a.child;
            for (var s = o.firstContext; s !== null; ) {
              if (s.context === r) {
                if (a.tag === 1) {
                  s = $n(-1, n & -n), s.tag = 2;
                  var u = a.updateQueue;
                  if (u !== null) {
                    u = u.shared;
                    var c = u.pending;
                    c === null ? s.next = s : (s.next = c.next, c.next = s), u.pending = s;
                  }
                }
                a.lanes |= n, s = a.alternate, s !== null && (s.lanes |= n), nu(
                  a.return,
                  n,
                  t
                ), o.lanes |= n;
                break;
              }
              s = s.next;
            }
          } else if (a.tag === 10) l = a.type === t.type ? null : a.child;
          else if (a.tag === 18) {
            if (l = a.return, l === null) throw Error(W(341));
            l.lanes |= n, o = l.alternate, o !== null && (o.lanes |= n), nu(l, n, t), l = a.sibling;
          } else l = a.child;
          if (l !== null) l.return = a;
          else for (l = a; l !== null; ) {
            if (l === t) {
              l = null;
              break;
            }
            if (a = l.sibling, a !== null) {
              a.return = l.return, l = a;
              break;
            }
            l = l.return;
          }
          a = l;
        }
        bt(e, t, i.children, n), t = t.child;
      }
      return t;
    case 9:
      return i = t.type, r = t.pendingProps.children, Ai(t, n), i = tn(i), r = r(i), t.flags |= 1, bt(e, t, r, n), t.child;
    case 14:
      return r = t.type, i = un(r, t.pendingProps), i = un(r.type, i), wf(e, t, r, i, n);
    case 15:
      return xm(e, t, t.type, t.pendingProps, n);
    case 17:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : un(r, i), Jl(e, t), t.tag = 1, Rt(r) ? (e = !0, yo(t)) : e = !1, Ai(t, n), ym(t, r, i), iu(t, r, i, n), ou(null, t, r, !0, e, n);
    case 19:
      return Tm(e, t, n);
    case 22:
      return km(e, t, n);
  }
  throw Error(W(156, t.tag));
};
function Hm(e, t) {
  return mp(e, t);
}
function Y5(e, t, n, r) {
  this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function Zt(e, t, n, r) {
  return new Y5(e, t, n, r);
}
function Mc(e) {
  return e = e.prototype, !(!e || !e.isReactComponent);
}
function j5(e) {
  if (typeof e == "function") return Mc(e) ? 1 : 0;
  if (e != null) {
    if (e = e.$$typeof, e === ju) return 11;
    if (e === Xu) return 14;
  }
  return 2;
}
function br(e, t) {
  var n = e.alternate;
  return n === null ? (n = Zt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n;
}
function no(e, t, n, r, i, a) {
  var l = 2;
  if (r = e, typeof e == "function") Mc(e) && (l = 1);
  else if (typeof e == "string") l = 5;
  else e: switch (e) {
    case hi:
      return qr(n.children, i, a, t);
    case Yu:
      l = 8, i |= 8;
      break;
    case A0:
      return e = Zt(12, n, t, i | 2), e.elementType = A0, e.lanes = a, e;
    case C0:
      return e = Zt(13, n, t, i), e.elementType = C0, e.lanes = a, e;
    case M0:
      return e = Zt(19, n, t, i), e.elementType = M0, e.lanes = a, e;
    case Qh:
      return ts(n, i, a, t);
    default:
      if (typeof e == "object" && e !== null) switch (e.$$typeof) {
        case Xh:
          l = 10;
          break e;
        case Zh:
          l = 9;
          break e;
        case ju:
          l = 11;
          break e;
        case Xu:
          l = 14;
          break e;
        case ir:
          l = 16, r = null;
          break e;
      }
      throw Error(W(130, e == null ? e : typeof e, ""));
  }
  return t = Zt(l, n, t, i), t.elementType = e, t.type = r, t.lanes = a, t;
}
function qr(e, t, n, r) {
  return e = Zt(7, e, r, t), e.lanes = n, e;
}
function ts(e, t, n, r) {
  return e = Zt(22, e, r, t), e.elementType = Qh, e.lanes = n, e.stateNode = { isHidden: !1 }, e;
}
function Vs(e, t, n) {
  return e = Zt(6, e, null, t), e.lanes = n, e;
}
function Ws(e, t, n) {
  return t = Zt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t;
}
function X5(e, t, n, r, i) {
  this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ts(0), this.expirationTimes = Ts(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ts(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
}
function Oc(e, t, n, r, i, a, l, o, s) {
  return e = new X5(e, t, n, o, s), t === 1 ? (t = 1, a === !0 && (t |= 8)) : t = 0, a = Zt(3, null, null, t), e.current = a, a.stateNode = e, a.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, pc(a), e;
}
function Z5(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: fi, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n };
}
function qm(e) {
  if (!e) return xr;
  e = e._reactInternals;
  e: {
    if (Qr(e) !== e || e.tag !== 1) throw Error(W(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (Rt(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(W(171));
  }
  if (e.tag === 1) {
    var n = e.type;
    if (Rt(n)) return qp(e, n, t);
  }
  return t;
}
function Gm(e, t, n, r, i, a, l, o, s) {
  return e = Oc(n, r, !0, e, i, a, l, o, s), e.context = qm(null), n = e.current, r = Et(), i = yr(n), a = $n(r, i), a.callback = t ?? null, gr(n, a, i), e.current.lanes = i, Qa(e, i, r), It(e, r), e;
}
function ns(e, t, n, r) {
  var i = t.current, a = Et(), l = yr(i);
  return n = qm(n), t.context === null ? t.context = n : t.pendingContext = n, t = $n(a, l), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = gr(i, t, l), e !== null && (pn(e, i, l, a), Xl(e, i, l)), l;
}
function Oo(e) {
  if (e = e.current, !e.child) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function Rf(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t;
  }
}
function Rc(e, t) {
  Rf(e, t), (e = e.alternate) && Rf(e, t);
}
function Q5() {
  return null;
}
var Vm = typeof reportError == "function" ? reportError : function(e) {
  console.error(e);
};
function Ic(e) {
  this._internalRoot = e;
}
rs.prototype.render = Ic.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null) throw Error(W(409));
  ns(e, t, null, null);
};
rs.prototype.unmount = Ic.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    jr(function() {
      ns(null, e, null, null);
    }), t[Vn] = null;
  }
};
function rs(e) {
  this._internalRoot = e;
}
rs.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
    var t = kp();
    e = { blockedOn: null, target: e, priority: t };
    for (var n = 0; n < lr.length && t !== 0 && t < lr[n].priority; n++) ;
    lr.splice(n, 0, e), n === 0 && Sp(e);
  }
};
function Dc(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
}
function is(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "));
}
function If() {
}
function J5(e, t, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var u = Oo(l);
        a.call(u);
      };
    }
    var l = Gm(t, r, e, 0, null, !1, !1, "", If);
    return e._reactRootContainer = l, e[Vn] = l.current, za(e.nodeType === 8 ? e.parentNode : e), jr(), l;
  }
  for (; i = e.lastChild; ) e.removeChild(i);
  if (typeof r == "function") {
    var o = r;
    r = function() {
      var u = Oo(s);
      o.call(u);
    };
  }
  var s = Oc(e, 0, !1, null, null, !1, !1, "", If);
  return e._reactRootContainer = s, e[Vn] = s.current, za(e.nodeType === 8 ? e.parentNode : e), jr(function() {
    ns(t, s, n, r);
  }), s;
}
function as(e, t, n, r, i) {
  var a = n._reactRootContainer;
  if (a) {
    var l = a;
    if (typeof i == "function") {
      var o = i;
      i = function() {
        var s = Oo(l);
        o.call(s);
      };
    }
    ns(t, l, e, i);
  } else l = J5(n, t, e, i, r);
  return Oo(l);
}
wp = function(e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var n = da(t.pendingLanes);
        n !== 0 && (Ju(t, n | 1), It(t, Ye()), !(ke & 6) && (Bi = Ye() + 500, Nr()));
      }
      break;
    case 13:
      jr(function() {
        var r = Wn(e, 1);
        if (r !== null) {
          var i = Et();
          pn(r, e, 1, i);
        }
      }), Rc(e, 1);
  }
};
ec = function(e) {
  if (e.tag === 13) {
    var t = Wn(e, 134217728);
    if (t !== null) {
      var n = Et();
      pn(t, e, 134217728, n);
    }
    Rc(e, 134217728);
  }
};
xp = function(e) {
  if (e.tag === 13) {
    var t = yr(e), n = Wn(e, t);
    if (n !== null) {
      var r = Et();
      pn(n, e, t, r);
    }
    Rc(e, t);
  }
};
kp = function() {
  return _e;
};
Ep = function(e, t) {
  var n = _e;
  try {
    return _e = e, t();
  } finally {
    _e = n;
  }
};
U0 = function(e, t, n) {
  switch (t) {
    case "input":
      if (I0(e, n), t = n.name, n.type === "radio" && t != null) {
        for (n = e; n.parentNode; ) n = n.parentNode;
        for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
          var r = n[t];
          if (r !== e && r.form === e.form) {
            var i = jo(r);
            if (!i) throw Error(W(90));
            ep(r), I0(r, i);
          }
        }
      }
      break;
    case "textarea":
      np(e, n);
      break;
    case "select":
      t = n.value, t != null && Si(e, !!n.multiple, t, !1);
  }
};
up = Nc;
cp = jr;
var e6 = { usingClientEntryPoint: !1, Events: [el, vi, jo, op, sp, Nc] }, aa = { findFiberByHostInstance: Fr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, t6 = { bundleType: aa.bundleType, version: aa.version, rendererPackageName: aa.rendererPackageName, rendererConfig: aa.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Zn.ReactCurrentDispatcher, findHostInstanceByFiber: function(e) {
  return e = hp(e), e === null ? null : e.stateNode;
}, findFiberByHostInstance: aa.findFiberByHostInstance || Q5, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var _l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!_l.isDisabled && _l.supportsFiber) try {
    Vo = _l.inject(t6), Nn = _l;
  } catch {
  }
}
Gt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = e6;
Gt.createPortal = function(e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Dc(t)) throw Error(W(200));
  return Z5(e, t, null, n);
};
Gt.createRoot = function(e, t) {
  if (!Dc(e)) throw Error(W(299));
  var n = !1, r = "", i = Vm;
  return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = Oc(e, 1, !1, null, null, n, !1, r, i), e[Vn] = t.current, za(e.nodeType === 8 ? e.parentNode : e), new Ic(t);
};
Gt.findDOMNode = function(e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function" ? Error(W(188)) : (e = Object.keys(e).join(","), Error(W(268, e)));
  return e = hp(t), e = e === null ? null : e.stateNode, e;
};
Gt.flushSync = function(e) {
  return jr(e);
};
Gt.hydrate = function(e, t, n) {
  if (!is(t)) throw Error(W(200));
  return as(null, e, t, !0, n);
};
Gt.hydrateRoot = function(e, t, n) {
  if (!Dc(e)) throw Error(W(405));
  var r = n != null && n.hydratedSources || null, i = !1, a = "", l = Vm;
  if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onRecoverableError !== void 0 && (l = n.onRecoverableError)), t = Gm(t, null, e, 1, n ?? null, i, !1, a, l), e[Vn] = t.current, za(e), r) for (e = 0; e < r.length; e++) n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(
    n,
    i
  );
  return new rs(t);
};
Gt.render = function(e, t, n) {
  if (!is(t)) throw Error(W(200));
  return as(null, e, t, !1, n);
};
Gt.unmountComponentAtNode = function(e) {
  if (!is(e)) throw Error(W(40));
  return e._reactRootContainer ? (jr(function() {
    as(null, null, e, !1, function() {
      e._reactRootContainer = null, e[Vn] = null;
    });
  }), !0) : !1;
};
Gt.unstable_batchedUpdates = Nc;
Gt.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
  if (!is(n)) throw Error(W(200));
  if (e == null || e._reactInternals === void 0) throw Error(W(38));
  return as(e, t, n, !1, r);
};
Gt.version = "18.3.1-next-f1338f8080-20240426";
function Wm() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Wm);
    } catch (e) {
      console.error(e);
    }
}
Wm(), Wh.exports = Gt;
var n6 = Wh.exports, Km, Df = n6;
Km = Df.createRoot, Df.hydrateRoot;
let Ym = xt.createContext(
  /** @type {any} */
  null
);
function r6() {
  let e = xt.useContext(Ym);
  if (!e) throw new Error("RenderContext not found");
  return e;
}
function i6() {
  return r6().model;
}
function zf(e) {
  let t = i6(), [n, r] = xt.useState(t.get(e));
  return xt.useEffect(() => {
    let i = () => r(t.get(e));
    return t.on(`change:${e}`, i), () => t.off(`change:${e}`, i);
  }, [t, e]), [
    n,
    (i) => {
      t.set(e, i), t.save_changes();
    }
  ];
}
function a6(e) {
  return ({ el: t, model: n, experimental: r }) => {
    let i = Km(t);
    return i.render(
      xt.createElement(
        xt.StrictMode,
        null,
        xt.createElement(
          Ym.Provider,
          { value: { model: n, experimental: r } },
          xt.createElement(e)
        )
      )
    ), () => i.unmount();
  };
}
function Lf(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), i = 0, a = !1;
  for (; !a; ) {
    r === -1 && (r = n.length, a = !0);
    const l = n.slice(i, r).trim();
    (l || !a) && t.push(l), i = r + 1, r = n.indexOf(",", i);
  }
  return t;
}
function l6(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const o6 = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, s6 = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, u6 = {};
function Pf(e, t) {
  return (u6.jsx ? s6 : o6).test(e);
}
const c6 = /[ \t\n\f\r]/g;
function d6(e) {
  return typeof e == "object" ? e.type === "text" ? Bf(e.value) : !1 : Bf(e);
}
function Bf(e) {
  return e.replace(c6, "") === "";
}
class nl {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
nl.prototype.property = {};
nl.prototype.normal = {};
nl.prototype.space = null;
function jm(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new nl(n, r, t);
}
function Ga(e) {
  return e.toLowerCase();
}
class ln {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
ln.prototype.space = null;
ln.prototype.boolean = !1;
ln.prototype.booleanish = !1;
ln.prototype.overloadedBoolean = !1;
ln.prototype.number = !1;
ln.prototype.commaSeparated = !1;
ln.prototype.spaceSeparated = !1;
ln.prototype.commaOrSpaceSeparated = !1;
ln.prototype.mustUseProperty = !1;
ln.prototype.defined = !1;
let f6 = 0;
const pe = Jr(), Xe = Jr(), Xm = Jr(), j = Jr(), Oe = Jr(), Mi = Jr(), Pt = Jr();
function Jr() {
  return 2 ** ++f6;
}
const bu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: pe,
  booleanish: Xe,
  commaOrSpaceSeparated: Pt,
  commaSeparated: Mi,
  number: j,
  overloadedBoolean: Xm,
  spaceSeparated: Oe
}, Symbol.toStringTag, { value: "Module" })), Ks = Object.keys(bu);
class zc extends ln {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), Ff(this, "space", i), typeof r == "number")
      for (; ++a < Ks.length; ) {
        const l = Ks[a];
        Ff(this, Ks[a], (r & bu[l]) === bu[l]);
      }
  }
}
zc.prototype.defined = !0;
function Ff(e, t, n) {
  n && (e[t] = n);
}
const h6 = {}.hasOwnProperty;
function Vi(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (h6.call(e.properties, r)) {
      const i = e.properties[r], a = new zc(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Ga(r)] = r, n[Ga(a.attribute)] = r;
    }
  return new nl(t, n, e.space);
}
const Zm = Vi({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Qm = Vi({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Jm(e, t) {
  return t in e ? e[t] : t;
}
function eg(e, t) {
  return Jm(e, t.toLowerCase());
}
const tg = Vi({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: eg,
  properties: { xmlns: null, xmlnsXLink: null }
}), ng = Vi({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Xe,
    ariaAutoComplete: null,
    ariaBusy: Xe,
    ariaChecked: Xe,
    ariaColCount: j,
    ariaColIndex: j,
    ariaColSpan: j,
    ariaControls: Oe,
    ariaCurrent: null,
    ariaDescribedBy: Oe,
    ariaDetails: null,
    ariaDisabled: Xe,
    ariaDropEffect: Oe,
    ariaErrorMessage: null,
    ariaExpanded: Xe,
    ariaFlowTo: Oe,
    ariaGrabbed: Xe,
    ariaHasPopup: null,
    ariaHidden: Xe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Oe,
    ariaLevel: j,
    ariaLive: null,
    ariaModal: Xe,
    ariaMultiLine: Xe,
    ariaMultiSelectable: Xe,
    ariaOrientation: null,
    ariaOwns: Oe,
    ariaPlaceholder: null,
    ariaPosInSet: j,
    ariaPressed: Xe,
    ariaReadOnly: Xe,
    ariaRelevant: null,
    ariaRequired: Xe,
    ariaRoleDescription: Oe,
    ariaRowCount: j,
    ariaRowIndex: j,
    ariaRowSpan: j,
    ariaSelected: Xe,
    ariaSetSize: j,
    ariaSort: null,
    ariaValueMax: j,
    ariaValueMin: j,
    ariaValueNow: j,
    ariaValueText: null,
    role: null
  }
}), p6 = Vi({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: eg,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Mi,
    acceptCharset: Oe,
    accessKey: Oe,
    action: null,
    allow: null,
    allowFullScreen: pe,
    allowPaymentRequest: pe,
    allowUserMedia: pe,
    alt: null,
    as: null,
    async: pe,
    autoCapitalize: null,
    autoComplete: Oe,
    autoFocus: pe,
    autoPlay: pe,
    blocking: Oe,
    capture: null,
    charSet: null,
    checked: pe,
    cite: null,
    className: Oe,
    cols: j,
    colSpan: null,
    content: null,
    contentEditable: Xe,
    controls: pe,
    controlsList: Oe,
    coords: j | Mi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: pe,
    defer: pe,
    dir: null,
    dirName: null,
    disabled: pe,
    download: Xm,
    draggable: Xe,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: pe,
    formTarget: null,
    headers: Oe,
    height: j,
    hidden: pe,
    high: j,
    href: null,
    hrefLang: null,
    htmlFor: Oe,
    httpEquiv: Oe,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: pe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: pe,
    itemId: null,
    itemProp: Oe,
    itemRef: Oe,
    itemScope: pe,
    itemType: Oe,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: pe,
    low: j,
    manifest: null,
    max: null,
    maxLength: j,
    media: null,
    method: null,
    min: null,
    minLength: j,
    multiple: pe,
    muted: pe,
    name: null,
    nonce: null,
    noModule: pe,
    noValidate: pe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: pe,
    optimum: j,
    pattern: null,
    ping: Oe,
    placeholder: null,
    playsInline: pe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: pe,
    referrerPolicy: null,
    rel: Oe,
    required: pe,
    reversed: pe,
    rows: j,
    rowSpan: j,
    sandbox: Oe,
    scope: null,
    scoped: pe,
    seamless: pe,
    selected: pe,
    shadowRootClonable: pe,
    shadowRootDelegatesFocus: pe,
    shadowRootMode: null,
    shape: null,
    size: j,
    sizes: null,
    slot: null,
    span: j,
    spellCheck: Xe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: j,
    step: null,
    style: null,
    tabIndex: j,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: pe,
    useMap: null,
    value: Xe,
    width: j,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Oe,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: j,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: j,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: pe,
    // Lists. Use CSS to reduce space between items instead
    declare: pe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: j,
    // `<img>` and `<object>`
    leftMargin: j,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: j,
    // `<body>`
    marginWidth: j,
    // `<body>`
    noResize: pe,
    // `<frame>`
    noHref: pe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: pe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: pe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: j,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Xe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: j,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: j,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: pe,
    disableRemotePlayback: pe,
    prefix: null,
    property: null,
    results: j,
    security: null,
    unselectable: null
  }
}), m6 = Vi({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Jm,
  properties: {
    about: Pt,
    accentHeight: j,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: j,
    amplitude: j,
    arabicForm: null,
    ascent: j,
    attributeName: null,
    attributeType: null,
    azimuth: j,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: j,
    by: null,
    calcMode: null,
    capHeight: j,
    className: Oe,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: j,
    diffuseConstant: j,
    direction: null,
    display: null,
    dur: null,
    divisor: j,
    dominantBaseline: null,
    download: pe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: j,
    enableBackground: null,
    end: null,
    event: null,
    exponent: j,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: j,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Mi,
    g2: Mi,
    glyphName: Mi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: j,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: j,
    horizOriginX: j,
    horizOriginY: j,
    id: null,
    ideographic: j,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: j,
    k: j,
    k1: j,
    k2: j,
    k3: j,
    k4: j,
    kernelMatrix: Pt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: j,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: j,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: j,
    overlineThickness: j,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: j,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Oe,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: j,
    pointsAtY: j,
    pointsAtZ: j,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Pt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Pt,
    rev: Pt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Pt,
    requiredFeatures: Pt,
    requiredFonts: Pt,
    requiredFormats: Pt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: j,
    specularExponent: j,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: j,
    strikethroughThickness: j,
    string: null,
    stroke: null,
    strokeDashArray: Pt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: j,
    strokeOpacity: j,
    strokeWidth: null,
    style: null,
    surfaceScale: j,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Pt,
    tabIndex: j,
    tableValues: null,
    target: null,
    targetX: j,
    targetY: j,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Pt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: j,
    underlineThickness: j,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: j,
    values: null,
    vAlphabetic: j,
    vMathematical: j,
    vectorEffect: null,
    vHanging: j,
    vIdeographic: j,
    version: null,
    vertAdvY: j,
    vertOriginX: j,
    vertOriginY: j,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: j,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), g6 = /^data[-\w.:]+$/i, Uf = /-[a-z]/g, v6 = /[A-Z]/g;
function rg(e, t) {
  const n = Ga(t);
  let r = t, i = ln;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && g6.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Uf, b6);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Uf.test(a)) {
        let l = a.replace(v6, y6);
        l.charAt(0) !== "-" && (l = "-" + l), t = "data" + l;
      }
    }
    i = zc;
  }
  return new i(r, t);
}
function y6(e) {
  return "-" + e.toLowerCase();
}
function b6(e) {
  return e.charAt(1).toUpperCase();
}
const w6 = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ig = jm([Qm, Zm, tg, ng, p6], "html"), ls = jm([Qm, Zm, tg, ng, m6], "svg");
function $f(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function x6(e) {
  return e.join(" ").trim();
}
var ag = {}, Hf = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, k6 = /\n/g, E6 = /^\s*/, S6 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, _6 = /^:\s*/, T6 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, N6 = /^[;\s]*/, A6 = /^\s+|\s+$/g, C6 = `
`, qf = "/", Gf = "*", Br = "", M6 = "comment", O6 = "declaration", R6 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(g) {
    var w = g.match(k6);
    w && (n += w.length);
    var S = g.lastIndexOf(C6);
    r = ~S ? g.length - S : r + g.length;
  }
  function a() {
    var g = { line: n, column: r };
    return function(w) {
      return w.position = new l(g), u(), w;
    };
  }
  function l(g) {
    this.start = g, this.end = { line: n, column: r }, this.source = t.source;
  }
  l.prototype.content = e;
  function o(g) {
    var w = new Error(
      t.source + ":" + n + ":" + r + ": " + g
    );
    if (w.reason = g, w.filename = t.source, w.line = n, w.column = r, w.source = e, !t.silent) throw w;
  }
  function s(g) {
    var w = g.exec(e);
    if (w) {
      var S = w[0];
      return i(S), e = e.slice(S.length), w;
    }
  }
  function u() {
    s(E6);
  }
  function c(g) {
    var w;
    for (g = g || []; w = d(); )
      w !== !1 && g.push(w);
    return g;
  }
  function d() {
    var g = a();
    if (!(qf != e.charAt(0) || Gf != e.charAt(1))) {
      for (var w = 2; Br != e.charAt(w) && (Gf != e.charAt(w) || qf != e.charAt(w + 1)); )
        ++w;
      if (w += 2, Br === e.charAt(w - 1))
        return o("End of comment missing");
      var S = e.slice(2, w - 2);
      return r += 2, i(S), e = e.slice(w), r += 2, g({
        type: M6,
        comment: S
      });
    }
  }
  function h() {
    var g = a(), w = s(S6);
    if (w) {
      if (d(), !s(_6)) return o("property missing ':'");
      var S = s(T6), y = g({
        type: O6,
        property: Vf(w[0].replace(Hf, Br)),
        value: S ? Vf(S[0].replace(Hf, Br)) : Br
      });
      return s(N6), y;
    }
  }
  function p() {
    var g = [];
    c(g);
    for (var w; w = h(); )
      w !== !1 && (g.push(w), c(g));
    return g;
  }
  return u(), p();
};
function Vf(e) {
  return e ? e.replace(A6, Br) : Br;
}
var I6 = Sd && Sd.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ag, "__esModule", { value: !0 });
var Wf = ag.default = z6, D6 = I6(R6);
function z6(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, D6.default)(e), i = typeof t == "function";
  return r.forEach(function(a) {
    if (a.type === "declaration") {
      var l = a.property, o = a.value;
      i ? t(l, o, a) : o && (n = n || {}, n[l] = o);
    }
  }), n;
}
const L6 = Wf.default || Wf, lg = og("end"), Lc = og("start");
function og(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function P6(e) {
  const t = Lc(e), n = lg(e);
  if (t && n)
    return { start: t, end: n };
}
function Ea(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Kf(e.position) : "start" in e || "end" in e ? Kf(e) : "line" in e || "column" in e ? wu(e) : "";
}
function wu(e) {
  return Yf(e && e.line) + ":" + Yf(e && e.column);
}
function Kf(e) {
  return wu(e && e.start) + "-" + wu(e && e.end);
}
function Yf(e) {
  return e && typeof e == "number" ? e : 1;
}
class mt extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, l = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (l = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const s = r.indexOf(":");
      s === -1 ? a.ruleId = r : (a.source = r.slice(0, s), a.ruleId = r.slice(s + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const s = a.ancestors[a.ancestors.length - 1];
      s && (a.place = s.position);
    }
    const o = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = o ? o.line : void 0, this.name = Ea(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = l && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
mt.prototype.file = "";
mt.prototype.name = "";
mt.prototype.reason = "";
mt.prototype.message = "";
mt.prototype.stack = "";
mt.prototype.column = void 0;
mt.prototype.line = void 0;
mt.prototype.ancestors = void 0;
mt.prototype.cause = void 0;
mt.prototype.fatal = void 0;
mt.prototype.place = void 0;
mt.prototype.ruleId = void 0;
mt.prototype.source = void 0;
const Pc = {}.hasOwnProperty, B6 = /* @__PURE__ */ new Map(), F6 = /[A-Z]/g, U6 = /-([a-z])/g, $6 = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), H6 = /* @__PURE__ */ new Set(["td", "th"]), sg = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function q6(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Z6(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = X6(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? ls : ig,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = ug(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function ug(e, t, n) {
  if (t.type === "element")
    return G6(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return V6(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return K6(e, t, n);
  if (t.type === "mdxjsEsm")
    return W6(e, t);
  if (t.type === "root")
    return Y6(e, t, n);
  if (t.type === "text")
    return j6(e, t);
}
function G6(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = ls, e.schema = i), e.ancestors.push(t);
  const a = dg(e, t.tagName, !1), l = Q6(e, t);
  let o = Fc(e, t);
  return $6.has(t.tagName) && (o = o.filter(function(s) {
    return typeof s == "string" ? !d6(s) : !0;
  })), cg(e, l, a, t), Bc(l, o), e.ancestors.pop(), e.schema = r, e.create(t, a, l, n);
}
function V6(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Va(e, t.position);
}
function W6(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Va(e, t.position);
}
function K6(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = ls, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : dg(e, t.name, !0), l = J6(e, t), o = Fc(e, t);
  return cg(e, l, a, t), Bc(l, o), e.ancestors.pop(), e.schema = r, e.create(t, a, l, n);
}
function Y6(e, t, n) {
  const r = {};
  return Bc(r, Fc(e, t)), e.create(t, e.Fragment, r, n);
}
function j6(e, t) {
  return t.value;
}
function cg(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function Bc(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function X6(e, t, n) {
  return r;
  function r(i, a, l, o) {
    const u = Array.isArray(l.children) ? n : t;
    return o ? u(a, l, o) : u(a, l);
  }
}
function Z6(e, t) {
  return n;
  function n(r, i, a, l) {
    const o = Array.isArray(a.children), s = Lc(r);
    return t(
      i,
      a,
      l,
      o,
      {
        columnNumber: s ? s.column - 1 : void 0,
        fileName: e,
        lineNumber: s ? s.line : void 0
      },
      void 0
    );
  }
}
function Q6(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && Pc.call(t.properties, i)) {
      const a = e7(e, i, t.properties[i]);
      if (a) {
        const [l, o] = a;
        e.tableCellAlignToStyle && l === "align" && typeof o == "string" && H6.has(t.tagName) ? r = o : n[l] = o;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function J6(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const l = a.expression;
        l.type;
        const o = l.properties[0];
        o.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        Va(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, a = e.evaluater.evaluateExpression(o.expression);
        } else
          Va(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function Fc(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : B6;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let l;
    if (e.passKeys) {
      const s = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (s) {
        const u = i.get(s) || 0;
        l = s + "-" + u, i.set(s, u + 1);
      }
    }
    const o = ug(e, a, l);
    o !== void 0 && n.push(o);
  }
  return n;
}
function e7(e, t, n) {
  const r = rg(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? l6(n) : x6(n)), r.property === "style") {
      let i = typeof n == "object" ? n : t7(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = n7(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? w6[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function t7(e, t) {
  const n = {};
  try {
    L6(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const a = (
        /** @type {Error} */
        i
      ), l = new mt("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: a,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw l.file = e.filePath || void 0, l.url = sg + "#cannot-parse-style-attribute", l;
    }
  }
  return n;
  function r(i, a) {
    let l = i;
    l.slice(0, 2) !== "--" && (l.slice(0, 4) === "-ms-" && (l = "ms-" + l.slice(4)), l = l.replace(U6, i7)), n[l] = a;
  }
}
function dg(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, l;
    for (; ++a < i.length; ) {
      const o = Pf(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      l = l ? {
        type: "MemberExpression",
        object: l,
        property: o,
        computed: !!(a && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = l;
  } else
    r = Pf(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return Pc.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Va(e);
}
function Va(e, t) {
  const n = new mt(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = sg + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function n7(e) {
  const t = {};
  let n;
  for (n in e)
    Pc.call(e, n) && (t[r7(n)] = e[n]);
  return t;
}
function r7(e) {
  let t = e.replace(F6, a7);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function i7(e, t) {
  return t.toUpperCase();
}
function a7(e) {
  return "-" + e.toLowerCase();
}
const Ys = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
var fg = { exports: {} }, os = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l7 = xt, o7 = Symbol.for("react.element"), s7 = Symbol.for("react.fragment"), u7 = Object.prototype.hasOwnProperty, c7 = l7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d7 = { key: !0, ref: !0, __self: !0, __source: !0 };
function hg(e, t, n) {
  var r, i = {}, a = null, l = null;
  n !== void 0 && (a = "" + n), t.key !== void 0 && (a = "" + t.key), t.ref !== void 0 && (l = t.ref);
  for (r in t) u7.call(t, r) && !d7.hasOwnProperty(r) && (i[r] = t[r]);
  if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]);
  return { $$typeof: o7, type: e, key: a, ref: l, props: i, _owner: c7.current };
}
os.Fragment = s7;
os.jsx = hg;
os.jsxs = hg;
fg.exports = os;
var js = fg.exports;
const f7 = {};
function Uc(e, t) {
  const n = f7, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return pg(e, r, i);
}
function pg(e, t, n) {
  if (h7(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return jf(e.children, t, n);
  }
  return Array.isArray(e) ? jf(e, t, n) : "";
}
function jf(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = pg(e[i], t, n);
  return r.join("");
}
function h7(e) {
  return !!(e && typeof e == "object");
}
const Xf = document.createElement("i");
function $c(e) {
  const t = "&" + e + ";";
  Xf.innerHTML = t;
  const n = Xf.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Ht(e, t, n, r) {
  const i = e.length;
  let a = 0, l;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    l = Array.from(r), l.unshift(t, n), e.splice(...l);
  else
    for (n && e.splice(t, n); a < r.length; )
      l = r.slice(a, a + 1e4), l.unshift(t, 0), e.splice(...l), a += 1e4, t += 1e4;
}
function jt(e, t) {
  return e.length > 0 ? (Ht(e, e.length, 0, t), e) : t;
}
const Zf = {}.hasOwnProperty;
function mg(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    p7(t, e[n]);
  return t;
}
function p7(e, t) {
  let n;
  for (n in t) {
    const i = (Zf.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let l;
    if (a)
      for (l in a) {
        Zf.call(i, l) || (i[l] = []);
        const o = a[l];
        m7(
          // @ts-expect-error Looks like a list.
          i[l],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function m7(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Ht(e, 0, 0, r);
}
function gg(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function mn(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const wt = Ar(/[A-Za-z]/), ht = Ar(/[\dA-Za-z]/), g7 = Ar(/[#-'*+\--9=?A-Z^-~]/);
function Ro(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const xu = Ar(/\d/), v7 = Ar(/[\dA-Fa-f]/), y7 = Ar(/[!-/:-@[-`{-~]/);
function le(e) {
  return e !== null && e < -2;
}
function Ce(e) {
  return e !== null && (e < 0 || e === 32);
}
function be(e) {
  return e === -2 || e === -1 || e === 32;
}
const ss = Ar(new RegExp("\\p{P}|\\p{S}", "u")), Xr = Ar(/\s/);
function Ar(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Wi(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let l = "";
    if (a === 37 && ht(e.charCodeAt(n + 1)) && ht(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (l = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (l = String.fromCharCode(a, o), i = 1) : l = "";
    } else
      l = String.fromCharCode(a);
    l && (t.push(e.slice(r, n), encodeURIComponent(l)), r = n + i + 1, l = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function ve(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return l;
  function l(s) {
    return be(s) ? (e.enter(n), o(s)) : t(s);
  }
  function o(s) {
    return be(s) && a++ < i ? (e.consume(s), o) : (e.exit(n), t(s));
  }
}
const b7 = {
  tokenize: w7
};
function w7(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), ve(e, t, "linePrefix");
  }
  function i(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const s = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = s), n = s, l(o);
  }
  function l(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return le(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), l);
  }
}
const x7 = {
  tokenize: k7
}, Qf = {
  tokenize: E7
};
function k7(e) {
  const t = this, n = [];
  let r = 0, i, a, l;
  return o;
  function o(x) {
    if (r < n.length) {
      const C = n[r];
      return t.containerState = C[1], e.attempt(C[0].continuation, s, u)(x);
    }
    return u(x);
  }
  function s(x) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && v();
      const C = t.events.length;
      let R = C, T;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          T = t.events[R][1].end;
          break;
        }
      y(r);
      let z = C;
      for (; z < t.events.length; )
        t.events[z][1].end = {
          ...T
        }, z++;
      return Ht(t.events, R + 1, 0, t.events.slice(C)), t.events.length = z, u(x);
    }
    return o(x);
  }
  function u(x) {
    if (r === n.length) {
      if (!i)
        return h(x);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return g(x);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Qf, c, d)(x);
  }
  function c(x) {
    return i && v(), y(r), h(x);
  }
  function d(x) {
    return t.parser.lazy[t.now().line] = r !== n.length, l = t.now().offset, g(x);
  }
  function h(x) {
    return t.containerState = {}, e.attempt(Qf, p, g)(x);
  }
  function p(x) {
    return r++, n.push([t.currentConstruct, t.containerState]), h(x);
  }
  function g(x) {
    if (x === null) {
      i && v(), y(0), e.consume(x);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: a
    }), w(x);
  }
  function w(x) {
    if (x === null) {
      S(e.exit("chunkFlow"), !0), y(0), e.consume(x);
      return;
    }
    return le(x) ? (e.consume(x), S(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(x), w);
  }
  function S(x, C) {
    const R = t.sliceStream(x);
    if (C && R.push(null), x.previous = a, a && (a.next = x), a = x, i.defineSkip(x.start), i.write(R), t.parser.lazy[x.start.line]) {
      let T = i.events.length;
      for (; T--; )
        if (
          // The token starts before the line ending
          i.events[T][1].start.offset < l && // and either is not ended yet
          (!i.events[T][1].end || // or ends after it.
          i.events[T][1].end.offset > l)
        )
          return;
      const z = t.events.length;
      let P = z, U, O;
      for (; P--; )
        if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
          if (U) {
            O = t.events[P][1].end;
            break;
          }
          U = !0;
        }
      for (y(r), T = z; T < t.events.length; )
        t.events[T][1].end = {
          ...O
        }, T++;
      Ht(t.events, P + 1, 0, t.events.slice(z)), t.events.length = T;
    }
  }
  function y(x) {
    let C = n.length;
    for (; C-- > x; ) {
      const R = n[C];
      t.containerState = R[1], R[0].exit.call(t, e);
    }
    n.length = x;
  }
  function v() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function E7(e, t, n) {
  return ve(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Fi(e) {
  if (e === null || Ce(e) || Xr(e))
    return 1;
  if (ss(e))
    return 2;
}
function us(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const ku = {
  name: "attention",
  resolveAll: S7,
  tokenize: _7
};
function S7(e, t) {
  let n = -1, r, i, a, l, o, s, u, c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          s = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...e[r][1].end
          }, h = {
            ...e[n][1].start
          };
          Jf(d, -s), Jf(h, s), l = {
            type: s > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...e[r][1].end
            }
          }, o = {
            type: s > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: h
          }, a = {
            type: s > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: s > 1 ? "strong" : "emphasis",
            start: {
              ...l.start
            },
            end: {
              ...o.end
            }
          }, e[r][1].end = {
            ...l.start
          }, e[n][1].start = {
            ...o.end
          }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = jt(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = jt(u, [["enter", i, t], ["enter", l, t], ["exit", l, t], ["enter", a, t]]), u = jt(u, us(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = jt(u, [["exit", a, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, u = jt(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : c = 0, Ht(e, r - 1, n - r + 3, u), n = r + u.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function _7(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Fi(r);
  let a;
  return l;
  function l(s) {
    return a = s, e.enter("attentionSequence"), o(s);
  }
  function o(s) {
    if (s === a)
      return e.consume(s), o;
    const u = e.exit("attentionSequence"), c = Fi(s), d = !c || c === 2 && i || n.includes(s), h = !i || i === 2 && c || n.includes(r);
    return u._open = !!(a === 42 ? d : d && (i || !h)), u._close = !!(a === 42 ? h : h && (c || !d)), t(s);
  }
}
function Jf(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const T7 = {
  name: "autolink",
  tokenize: N7
};
function N7(e, t, n) {
  let r = 0;
  return i;
  function i(p) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(p) {
    return wt(p) ? (e.consume(p), l) : p === 64 ? n(p) : u(p);
  }
  function l(p) {
    return p === 43 || p === 45 || p === 46 || ht(p) ? (r = 1, o(p)) : u(p);
  }
  function o(p) {
    return p === 58 ? (e.consume(p), r = 0, s) : (p === 43 || p === 45 || p === 46 || ht(p)) && r++ < 32 ? (e.consume(p), o) : (r = 0, u(p));
  }
  function s(p) {
    return p === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : p === null || p === 32 || p === 60 || Ro(p) ? n(p) : (e.consume(p), s);
  }
  function u(p) {
    return p === 64 ? (e.consume(p), c) : g7(p) ? (e.consume(p), u) : n(p);
  }
  function c(p) {
    return ht(p) ? d(p) : n(p);
  }
  function d(p) {
    return p === 46 ? (e.consume(p), r = 0, c) : p === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(p);
  }
  function h(p) {
    if ((p === 45 || ht(p)) && r++ < 63) {
      const g = p === 45 ? h : d;
      return e.consume(p), g;
    }
    return n(p);
  }
}
const rl = {
  partial: !0,
  tokenize: A7
};
function A7(e, t, n) {
  return r;
  function r(a) {
    return be(a) ? ve(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || le(a) ? t(a) : n(a);
  }
}
const vg = {
  continuation: {
    tokenize: M7
  },
  exit: O7,
  name: "blockQuote",
  tokenize: C7
};
function C7(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    if (l === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(l), e.exit("blockQuoteMarker"), a;
    }
    return n(l);
  }
  function a(l) {
    return be(l) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(l), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(l));
  }
}
function M7(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return be(l) ? ve(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) : a(l);
  }
  function a(l) {
    return e.attempt(vg, t, n)(l);
  }
}
function O7(e) {
  e.exit("blockQuote");
}
const yg = {
  name: "characterEscape",
  tokenize: R7
};
function R7(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return y7(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const bg = {
  name: "characterReference",
  tokenize: I7
};
function I7(e, t, n) {
  const r = this;
  let i = 0, a, l;
  return o;
  function o(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), s;
  }
  function s(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), a = 31, l = ht, c(d));
  }
  function u(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, l = v7, c) : (e.enter("characterReferenceValue"), a = 7, l = xu, c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const h = e.exit("characterReferenceValue");
      return l === ht && !$c(r.sliceSerialize(h)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return l(d) && i++ < a ? (e.consume(d), c) : n(d);
  }
}
const e1 = {
  partial: !0,
  tokenize: z7
}, t1 = {
  concrete: !0,
  name: "codeFenced",
  tokenize: D7
};
function D7(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: R
  };
  let a = 0, l = 0, o;
  return s;
  function s(T) {
    return u(T);
  }
  function u(T) {
    const z = r.events[r.events.length - 1];
    return a = z && z[1].type === "linePrefix" ? z[2].sliceSerialize(z[1], !0).length : 0, o = T, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(T);
  }
  function c(T) {
    return T === o ? (l++, e.consume(T), c) : l < 3 ? n(T) : (e.exit("codeFencedFenceSequence"), be(T) ? ve(e, d, "whitespace")(T) : d(T));
  }
  function d(T) {
    return T === null || le(T) ? (e.exit("codeFencedFence"), r.interrupt ? t(T) : e.check(e1, w, C)(T)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), h(T));
  }
  function h(T) {
    return T === null || le(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(T)) : be(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ve(e, p, "whitespace")(T)) : T === 96 && T === o ? n(T) : (e.consume(T), h);
  }
  function p(T) {
    return T === null || le(T) ? d(T) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), g(T));
  }
  function g(T) {
    return T === null || le(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(T)) : T === 96 && T === o ? n(T) : (e.consume(T), g);
  }
  function w(T) {
    return e.attempt(i, C, S)(T);
  }
  function S(T) {
    return e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), y;
  }
  function y(T) {
    return a > 0 && be(T) ? ve(e, v, "linePrefix", a + 1)(T) : v(T);
  }
  function v(T) {
    return T === null || le(T) ? e.check(e1, w, C)(T) : (e.enter("codeFlowValue"), x(T));
  }
  function x(T) {
    return T === null || le(T) ? (e.exit("codeFlowValue"), v(T)) : (e.consume(T), x);
  }
  function C(T) {
    return e.exit("codeFenced"), t(T);
  }
  function R(T, z, P) {
    let U = 0;
    return O;
    function O(re) {
      return T.enter("lineEnding"), T.consume(re), T.exit("lineEnding"), V;
    }
    function V(re) {
      return T.enter("codeFencedFence"), be(re) ? ve(T, K, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(re) : K(re);
    }
    function K(re) {
      return re === o ? (T.enter("codeFencedFenceSequence"), ae(re)) : P(re);
    }
    function ae(re) {
      return re === o ? (U++, T.consume(re), ae) : U >= l ? (T.exit("codeFencedFenceSequence"), be(re) ? ve(T, ie, "whitespace")(re) : ie(re)) : P(re);
    }
    function ie(re) {
      return re === null || le(re) ? (T.exit("codeFencedFence"), z(re)) : P(re);
    }
  }
}
function z7(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return l === null ? n(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a);
  }
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
const Xs = {
  name: "codeIndented",
  tokenize: P7
}, L7 = {
  partial: !0,
  tokenize: B7
};
function P7(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), ve(e, a, "linePrefix", 5)(u);
  }
  function a(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? l(u) : n(u);
  }
  function l(u) {
    return u === null ? s(u) : le(u) ? e.attempt(L7, l, s)(u) : (e.enter("codeFlowValue"), o(u));
  }
  function o(u) {
    return u === null || le(u) ? (e.exit("codeFlowValue"), l(u)) : (e.consume(u), o);
  }
  function s(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function B7(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return r.parser.lazy[r.now().line] ? n(l) : le(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), i) : ve(e, a, "linePrefix", 5)(l);
  }
  function a(l) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(l) : le(l) ? i(l) : n(l);
  }
}
const F7 = {
  name: "codeText",
  previous: $7,
  resolve: U7,
  tokenize: H7
};
function U7(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function $7(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function H7(e, t, n) {
  let r = 0, i, a;
  return l;
  function l(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (e.consume(d), r++, o) : (e.exit("codeTextSequence"), s(d));
  }
  function s(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), s) : d === 96 ? (a = e.enter("codeTextSequence"), i = 0, c(d)) : le(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), s) : (e.enter("codeTextData"), u(d));
  }
  function u(d) {
    return d === null || d === 32 || d === 96 || le(d) ? (e.exit("codeTextData"), s(d)) : (e.consume(d), u);
  }
  function c(d) {
    return d === 96 ? (e.consume(d), i++, c) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (a.type = "codeTextData", u(d));
  }
}
class q7 {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && la(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), la(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), la(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        la(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        la(this.left, n.reverse());
      }
  }
}
function la(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function wg(e) {
  const t = {};
  let n = -1, r, i, a, l, o, s, u;
  const c = new q7(e);
  for (; ++n < c.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = c.get(n), n && r[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (s = r[1]._tokenizer.events, a = 0, a < s.length && s[a][1].type === "lineEndingBlank" && (a += 2), a < s.length && s[a][1].type === "content"))
      for (; ++a < s.length && s[a][1].type !== "content"; )
        s[a][1].type === "chunkText" && (s[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, G7(c, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a-- && (l = c.get(a), l[1].type === "lineEnding" || l[1].type === "lineEndingBlank"); )
        l[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), l[1].type = "lineEnding", i = a);
      i && (r[1].end = {
        ...c.get(i)[1].start
      }, o = c.slice(i, n), o.unshift(r), c.splice(i, n - i + 1, o));
    }
  }
  return Ht(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function G7(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [], l = n._tokenizer || r.parser[n.contentType](n.start), o = l.events, s = [], u = {};
  let c, d, h = -1, p = n, g = 0, w = 0;
  const S = [w];
  for (; p; ) {
    for (; e.get(++i)[1] !== p; )
      ;
    a.push(i), p._tokenizer || (c = r.sliceStream(p), p.next || c.push(null), d && l.defineSkip(p.start), p._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = !0), l.write(c), p._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = void 0)), d = p, p = p.next;
  }
  for (p = n; ++h < o.length; )
    // Find a void token that includes a break.
    o[h][0] === "exit" && o[h - 1][0] === "enter" && o[h][1].type === o[h - 1][1].type && o[h][1].start.line !== o[h][1].end.line && (w = h + 1, S.push(w), p._tokenizer = void 0, p.previous = void 0, p = p.next);
  for (l.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : S.pop(), h = S.length; h--; ) {
    const y = o.slice(S[h], S[h + 1]), v = a.pop();
    s.push([v, v + y.length - 1]), e.splice(v, 2, y);
  }
  for (s.reverse(), h = -1; ++h < s.length; )
    u[g + s[h][0]] = g + s[h][1], g += s[h][1] - s[h][0] - 1;
  return u;
}
const V7 = {
  resolve: K7,
  tokenize: Y7
}, W7 = {
  partial: !0,
  tokenize: j7
};
function K7(e) {
  return wg(e), e;
}
function Y7(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(o);
  }
  function i(o) {
    return o === null ? a(o) : le(o) ? e.check(W7, l, a)(o) : (e.consume(o), i);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function l(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function j7(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), ve(e, a, "linePrefix");
  }
  function a(l) {
    if (l === null || le(l))
      return n(l);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(l) : e.interrupt(r.parser.constructs.flow, n, t)(l);
  }
}
function xg(e, t, n, r, i, a, l, o, s) {
  const u = s || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(y) {
    return y === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(y), e.exit(a), h) : y === null || y === 32 || y === 41 || Ro(y) ? n(y) : (e.enter(r), e.enter(l), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), w(y));
  }
  function h(y) {
    return y === 62 ? (e.enter(a), e.consume(y), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === 62 ? (e.exit("chunkString"), e.exit(o), h(y)) : y === null || y === 60 || le(y) ? n(y) : (e.consume(y), y === 92 ? g : p);
  }
  function g(y) {
    return y === 60 || y === 62 || y === 92 ? (e.consume(y), p) : p(y);
  }
  function w(y) {
    return !c && (y === null || y === 41 || Ce(y)) ? (e.exit("chunkString"), e.exit(o), e.exit(l), e.exit(r), t(y)) : c < u && y === 40 ? (e.consume(y), c++, w) : y === 41 ? (e.consume(y), c--, w) : y === null || y === 32 || y === 40 || Ro(y) ? n(y) : (e.consume(y), y === 92 ? S : w);
  }
  function S(y) {
    return y === 40 || y === 41 || y === 92 ? (e.consume(y), w) : w(y);
  }
}
function kg(e, t, n, r, i, a) {
  const l = this;
  let o = 0, s;
  return u;
  function u(p) {
    return e.enter(r), e.enter(i), e.consume(p), e.exit(i), e.enter(a), c;
  }
  function c(p) {
    return o > 999 || p === null || p === 91 || p === 93 && !s || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    p === 94 && !o && "_hiddenFootnoteSupport" in l.parser.constructs ? n(p) : p === 93 ? (e.exit(a), e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : le(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), d(p));
  }
  function d(p) {
    return p === null || p === 91 || p === 93 || le(p) || o++ > 999 ? (e.exit("chunkString"), c(p)) : (e.consume(p), s || (s = !be(p)), p === 92 ? h : d);
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), o++, d) : d(p);
  }
}
function Eg(e, t, n, r, i, a) {
  let l;
  return o;
  function o(h) {
    return h === 34 || h === 39 || h === 40 ? (e.enter(r), e.enter(i), e.consume(h), e.exit(i), l = h === 40 ? 41 : h, s) : n(h);
  }
  function s(h) {
    return h === l ? (e.enter(i), e.consume(h), e.exit(i), e.exit(r), t) : (e.enter(a), u(h));
  }
  function u(h) {
    return h === l ? (e.exit(a), s(l)) : h === null ? n(h) : le(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), ve(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(h));
  }
  function c(h) {
    return h === l || h === null || le(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? d : c);
  }
  function d(h) {
    return h === l || h === 92 ? (e.consume(h), c) : c(h);
  }
}
function Sa(e, t) {
  let n;
  return r;
  function r(i) {
    return le(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : be(i) ? ve(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const X7 = {
  name: "definition",
  tokenize: Q7
}, Z7 = {
  partial: !0,
  tokenize: J7
};
function Q7(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(p) {
    return e.enter("definition"), l(p);
  }
  function l(p) {
    return kg.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(p);
  }
  function o(p) {
    return i = mn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), s) : n(p);
  }
  function s(p) {
    return Ce(p) ? Sa(e, u)(p) : u(p);
  }
  function u(p) {
    return xg(
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(p);
  }
  function c(p) {
    return e.attempt(Z7, d, d)(p);
  }
  function d(p) {
    return be(p) ? ve(e, h, "whitespace")(p) : h(p);
  }
  function h(p) {
    return p === null || le(p) ? (e.exit("definition"), r.parser.defined.push(i), t(p)) : n(p);
  }
}
function J7(e, t, n) {
  return r;
  function r(o) {
    return Ce(o) ? Sa(e, i)(o) : n(o);
  }
  function i(o) {
    return Eg(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function a(o) {
    return be(o) ? ve(e, l, "whitespace")(o) : l(o);
  }
  function l(o) {
    return o === null || le(o) ? t(o) : n(o);
  }
}
const ev = {
  name: "hardBreakEscape",
  tokenize: tv
};
function tv(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return le(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const nv = {
  name: "headingAtx",
  resolve: rv,
  tokenize: iv
};
function rv(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Ht(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function iv(e, t, n) {
  let r = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), a(c);
  }
  function a(c) {
    return e.enter("atxHeadingSequence"), l(c);
  }
  function l(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), l) : c === null || Ce(c) ? (e.exit("atxHeadingSequence"), o(c)) : n(c);
  }
  function o(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), s(c)) : c === null || le(c) ? (e.exit("atxHeading"), t(c)) : be(c) ? ve(e, o, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function s(c) {
    return c === 35 ? (e.consume(c), s) : (e.exit("atxHeadingSequence"), o(c));
  }
  function u(c) {
    return c === null || c === 35 || Ce(c) ? (e.exit("atxHeadingText"), o(c)) : (e.consume(c), u);
  }
}
const av = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], n1 = ["pre", "script", "style", "textarea"], lv = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: uv,
  tokenize: cv
}, ov = {
  partial: !0,
  tokenize: fv
}, sv = {
  partial: !0,
  tokenize: dv
};
function uv(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function cv(e, t, n) {
  const r = this;
  let i, a, l, o, s;
  return u;
  function u(A) {
    return c(A);
  }
  function c(A) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(A), d;
  }
  function d(A) {
    return A === 33 ? (e.consume(A), h) : A === 47 ? (e.consume(A), a = !0, w) : A === 63 ? (e.consume(A), i = 3, r.interrupt ? t : E) : wt(A) ? (e.consume(A), l = String.fromCharCode(A), S) : n(A);
  }
  function h(A) {
    return A === 45 ? (e.consume(A), i = 2, p) : A === 91 ? (e.consume(A), i = 5, o = 0, g) : wt(A) ? (e.consume(A), i = 4, r.interrupt ? t : E) : n(A);
  }
  function p(A) {
    return A === 45 ? (e.consume(A), r.interrupt ? t : E) : n(A);
  }
  function g(A) {
    const Se = "CDATA[";
    return A === Se.charCodeAt(o++) ? (e.consume(A), o === Se.length ? r.interrupt ? t : K : g) : n(A);
  }
  function w(A) {
    return wt(A) ? (e.consume(A), l = String.fromCharCode(A), S) : n(A);
  }
  function S(A) {
    if (A === null || A === 47 || A === 62 || Ce(A)) {
      const Se = A === 47, xe = l.toLowerCase();
      return !Se && !a && n1.includes(xe) ? (i = 1, r.interrupt ? t(A) : K(A)) : av.includes(l.toLowerCase()) ? (i = 6, Se ? (e.consume(A), y) : r.interrupt ? t(A) : K(A)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(A) : a ? v(A) : x(A));
    }
    return A === 45 || ht(A) ? (e.consume(A), l += String.fromCharCode(A), S) : n(A);
  }
  function y(A) {
    return A === 62 ? (e.consume(A), r.interrupt ? t : K) : n(A);
  }
  function v(A) {
    return be(A) ? (e.consume(A), v) : O(A);
  }
  function x(A) {
    return A === 47 ? (e.consume(A), O) : A === 58 || A === 95 || wt(A) ? (e.consume(A), C) : be(A) ? (e.consume(A), x) : O(A);
  }
  function C(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || ht(A) ? (e.consume(A), C) : R(A);
  }
  function R(A) {
    return A === 61 ? (e.consume(A), T) : be(A) ? (e.consume(A), R) : x(A);
  }
  function T(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), s = A, z) : be(A) ? (e.consume(A), T) : P(A);
  }
  function z(A) {
    return A === s ? (e.consume(A), s = null, U) : A === null || le(A) ? n(A) : (e.consume(A), z);
  }
  function P(A) {
    return A === null || A === 34 || A === 39 || A === 47 || A === 60 || A === 61 || A === 62 || A === 96 || Ce(A) ? R(A) : (e.consume(A), P);
  }
  function U(A) {
    return A === 47 || A === 62 || be(A) ? x(A) : n(A);
  }
  function O(A) {
    return A === 62 ? (e.consume(A), V) : n(A);
  }
  function V(A) {
    return A === null || le(A) ? K(A) : be(A) ? (e.consume(A), V) : n(A);
  }
  function K(A) {
    return A === 45 && i === 2 ? (e.consume(A), ge) : A === 60 && i === 1 ? (e.consume(A), B) : A === 62 && i === 4 ? (e.consume(A), Z) : A === 63 && i === 3 ? (e.consume(A), E) : A === 93 && i === 5 ? (e.consume(A), $) : le(A) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(ov, ee, ae)(A)) : A === null || le(A) ? (e.exit("htmlFlowData"), ae(A)) : (e.consume(A), K);
  }
  function ae(A) {
    return e.check(sv, ie, ee)(A);
  }
  function ie(A) {
    return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), re;
  }
  function re(A) {
    return A === null || le(A) ? ae(A) : (e.enter("htmlFlowData"), K(A));
  }
  function ge(A) {
    return A === 45 ? (e.consume(A), E) : K(A);
  }
  function B(A) {
    return A === 47 ? (e.consume(A), l = "", I) : K(A);
  }
  function I(A) {
    if (A === 62) {
      const Se = l.toLowerCase();
      return n1.includes(Se) ? (e.consume(A), Z) : K(A);
    }
    return wt(A) && l.length < 8 ? (e.consume(A), l += String.fromCharCode(A), I) : K(A);
  }
  function $(A) {
    return A === 93 ? (e.consume(A), E) : K(A);
  }
  function E(A) {
    return A === 62 ? (e.consume(A), Z) : A === 45 && i === 2 ? (e.consume(A), E) : K(A);
  }
  function Z(A) {
    return A === null || le(A) ? (e.exit("htmlFlowData"), ee(A)) : (e.consume(A), Z);
  }
  function ee(A) {
    return e.exit("htmlFlow"), t(A);
  }
}
function dv(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return le(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a) : n(l);
  }
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
function fv(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(rl, t, n);
  }
}
const hv = {
  name: "htmlText",
  tokenize: pv
};
function pv(e, t, n) {
  const r = this;
  let i, a, l;
  return o;
  function o(E) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(E), s;
  }
  function s(E) {
    return E === 33 ? (e.consume(E), u) : E === 47 ? (e.consume(E), R) : E === 63 ? (e.consume(E), x) : wt(E) ? (e.consume(E), P) : n(E);
  }
  function u(E) {
    return E === 45 ? (e.consume(E), c) : E === 91 ? (e.consume(E), a = 0, g) : wt(E) ? (e.consume(E), v) : n(E);
  }
  function c(E) {
    return E === 45 ? (e.consume(E), p) : n(E);
  }
  function d(E) {
    return E === null ? n(E) : E === 45 ? (e.consume(E), h) : le(E) ? (l = d, B(E)) : (e.consume(E), d);
  }
  function h(E) {
    return E === 45 ? (e.consume(E), p) : d(E);
  }
  function p(E) {
    return E === 62 ? ge(E) : E === 45 ? h(E) : d(E);
  }
  function g(E) {
    const Z = "CDATA[";
    return E === Z.charCodeAt(a++) ? (e.consume(E), a === Z.length ? w : g) : n(E);
  }
  function w(E) {
    return E === null ? n(E) : E === 93 ? (e.consume(E), S) : le(E) ? (l = w, B(E)) : (e.consume(E), w);
  }
  function S(E) {
    return E === 93 ? (e.consume(E), y) : w(E);
  }
  function y(E) {
    return E === 62 ? ge(E) : E === 93 ? (e.consume(E), y) : w(E);
  }
  function v(E) {
    return E === null || E === 62 ? ge(E) : le(E) ? (l = v, B(E)) : (e.consume(E), v);
  }
  function x(E) {
    return E === null ? n(E) : E === 63 ? (e.consume(E), C) : le(E) ? (l = x, B(E)) : (e.consume(E), x);
  }
  function C(E) {
    return E === 62 ? ge(E) : x(E);
  }
  function R(E) {
    return wt(E) ? (e.consume(E), T) : n(E);
  }
  function T(E) {
    return E === 45 || ht(E) ? (e.consume(E), T) : z(E);
  }
  function z(E) {
    return le(E) ? (l = z, B(E)) : be(E) ? (e.consume(E), z) : ge(E);
  }
  function P(E) {
    return E === 45 || ht(E) ? (e.consume(E), P) : E === 47 || E === 62 || Ce(E) ? U(E) : n(E);
  }
  function U(E) {
    return E === 47 ? (e.consume(E), ge) : E === 58 || E === 95 || wt(E) ? (e.consume(E), O) : le(E) ? (l = U, B(E)) : be(E) ? (e.consume(E), U) : ge(E);
  }
  function O(E) {
    return E === 45 || E === 46 || E === 58 || E === 95 || ht(E) ? (e.consume(E), O) : V(E);
  }
  function V(E) {
    return E === 61 ? (e.consume(E), K) : le(E) ? (l = V, B(E)) : be(E) ? (e.consume(E), V) : U(E);
  }
  function K(E) {
    return E === null || E === 60 || E === 61 || E === 62 || E === 96 ? n(E) : E === 34 || E === 39 ? (e.consume(E), i = E, ae) : le(E) ? (l = K, B(E)) : be(E) ? (e.consume(E), K) : (e.consume(E), ie);
  }
  function ae(E) {
    return E === i ? (e.consume(E), i = void 0, re) : E === null ? n(E) : le(E) ? (l = ae, B(E)) : (e.consume(E), ae);
  }
  function ie(E) {
    return E === null || E === 34 || E === 39 || E === 60 || E === 61 || E === 96 ? n(E) : E === 47 || E === 62 || Ce(E) ? U(E) : (e.consume(E), ie);
  }
  function re(E) {
    return E === 47 || E === 62 || Ce(E) ? U(E) : n(E);
  }
  function ge(E) {
    return E === 62 ? (e.consume(E), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(E);
  }
  function B(E) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), I;
  }
  function I(E) {
    return be(E) ? ve(e, $, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(E) : $(E);
  }
  function $(E) {
    return e.enter("htmlTextData"), l(E);
  }
}
const Hc = {
  name: "labelEnd",
  resolveAll: yv,
  resolveTo: bv,
  tokenize: wv
}, mv = {
  tokenize: xv
}, gv = {
  tokenize: kv
}, vv = {
  tokenize: Ev
};
function yv(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && Ht(e, 0, e.length, n), e;
}
function bv(e, t) {
  let n = e.length, r = 0, i, a, l, o;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (l) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (l = n);
  const s = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, u = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[l][1].end
    }
  }, c = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[l - 2][1].start
    }
  };
  return o = [["enter", s, t], ["enter", u, t]], o = jt(o, e.slice(a + 1, a + r + 3)), o = jt(o, [["enter", c, t]]), o = jt(o, us(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, l - 3), t)), o = jt(o, [["exit", c, t], e[l - 2], e[l - 1], ["exit", u, t]]), o = jt(o, e.slice(l + 1)), o = jt(o, [["exit", s, t]]), Ht(e, a, e.length, o), e;
}
function wv(e, t, n) {
  const r = this;
  let i = r.events.length, a, l;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return o;
  function o(h) {
    return a ? a._inactive ? d(h) : (l = r.parser.defined.includes(mn(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(h), e.exit("labelMarker"), e.exit("labelEnd"), s) : n(h);
  }
  function s(h) {
    return h === 40 ? e.attempt(mv, c, l ? c : d)(h) : h === 91 ? e.attempt(gv, c, l ? u : d)(h) : l ? c(h) : d(h);
  }
  function u(h) {
    return e.attempt(vv, c, d)(h);
  }
  function c(h) {
    return t(h);
  }
  function d(h) {
    return a._balanced = !0, n(h);
  }
}
function xv(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Ce(d) ? Sa(e, a)(d) : a(d);
  }
  function a(d) {
    return d === 41 ? c(d) : xg(e, l, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function l(d) {
    return Ce(d) ? Sa(e, s)(d) : c(d);
  }
  function o(d) {
    return n(d);
  }
  function s(d) {
    return d === 34 || d === 39 || d === 40 ? Eg(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function u(d) {
    return Ce(d) ? Sa(e, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function kv(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return kg.call(r, e, a, l, "reference", "referenceMarker", "referenceString")(o);
  }
  function a(o) {
    return r.parser.defined.includes(mn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(o) : n(o);
  }
  function l(o) {
    return n(o);
  }
}
function Ev(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const Sv = {
  name: "labelStartImage",
  resolveAll: Hc.resolveAll,
  tokenize: _v
};
function _v(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), l) : n(o);
  }
  function l(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const Tv = {
  name: "labelStartLink",
  resolveAll: Hc.resolveAll,
  tokenize: Nv
};
function Nv(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : t(l);
  }
}
const Zs = {
  name: "lineEnding",
  tokenize: Av
};
function Av(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), ve(e, t, "linePrefix");
  }
}
const ro = {
  name: "thematicBreak",
  tokenize: Cv
};
function Cv(e, t, n) {
  let r = 0, i;
  return a;
  function a(u) {
    return e.enter("thematicBreak"), l(u);
  }
  function l(u) {
    return i = u, o(u);
  }
  function o(u) {
    return u === i ? (e.enter("thematicBreakSequence"), s(u)) : r >= 3 && (u === null || le(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function s(u) {
    return u === i ? (e.consume(u), r++, s) : (e.exit("thematicBreakSequence"), be(u) ? ve(e, o, "whitespace")(u) : o(u));
  }
}
const Nt = {
  continuation: {
    tokenize: Iv
  },
  exit: zv,
  name: "list",
  tokenize: Rv
}, Mv = {
  partial: !0,
  tokenize: Lv
}, Ov = {
  partial: !0,
  tokenize: Dv
};
function Rv(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, l = 0;
  return o;
  function o(p) {
    const g = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered");
    if (g === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : xu(p)) {
      if (r.containerState.type || (r.containerState.type = g, e.enter(g, {
        _container: !0
      })), g === "listUnordered")
        return e.enter("listItemPrefix"), p === 42 || p === 45 ? e.check(ro, n, u)(p) : u(p);
      if (!r.interrupt || p === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), s(p);
    }
    return n(p);
  }
  function s(p) {
    return xu(p) && ++l < 10 ? (e.consume(p), s) : (!r.interrupt || l < 2) && (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46) ? (e.exit("listItemValue"), u(p)) : n(p);
  }
  function u(p) {
    return e.enter("listItemMarker"), e.consume(p), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || p, e.check(
      rl,
      // Cant be empty when interrupting.
      r.interrupt ? n : c,
      e.attempt(Mv, h, d)
    );
  }
  function c(p) {
    return r.containerState.initialBlankLine = !0, a++, h(p);
  }
  function d(p) {
    return be(p) ? (e.enter("listItemPrefixWhitespace"), e.consume(p), e.exit("listItemPrefixWhitespace"), h) : n(p);
  }
  function h(p) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(p);
  }
}
function Iv(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(rl, i, a);
  function i(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, ve(e, t, "listItemIndent", r.containerState.size + 1)(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !be(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, l(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Ov, t, l)(o));
  }
  function l(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, ve(e, e.attempt(Nt, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function Dv(e, t, n) {
  const r = this;
  return ve(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "listItemIndent" && l[2].sliceSerialize(l[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function zv(e) {
  e.exit(this.containerState.type);
}
function Lv(e, t, n) {
  const r = this;
  return ve(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const l = r.events[r.events.length - 1];
    return !be(a) && l && l[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const r1 = {
  name: "setextUnderline",
  resolveTo: Pv,
  tokenize: Bv
};
function Pv(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const l = {
    type: "setextHeading",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", l, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = l, e.push(["exit", l, t]), e;
}
function Bv(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(u) {
    let c = r.events.length, d;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        d = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), i = u, l(u)) : n(u);
  }
  function l(u) {
    return e.enter("setextHeadingLineSequence"), o(u);
  }
  function o(u) {
    return u === i ? (e.consume(u), o) : (e.exit("setextHeadingLineSequence"), be(u) ? ve(e, s, "lineSuffix")(u) : s(u));
  }
  function s(u) {
    return u === null || le(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const Fv = {
  tokenize: Uv
};
function Uv(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    rl,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, ve(e, e.attempt(this.parser.constructs.flow, i, e.attempt(V7, i)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const $v = {
  resolveAll: _g()
}, Hv = Sg("string"), qv = Sg("text");
function Sg(e) {
  return {
    resolveAll: _g(e === "text" ? Gv : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, l, o);
    return l;
    function l(c) {
      return u(c) ? a(c) : o(c);
    }
    function o(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), s;
    }
    function s(c) {
      return u(c) ? (n.exit("data"), a(c)) : (n.consume(c), s);
    }
    function u(c) {
      if (c === null)
        return !0;
      const d = i[c];
      let h = -1;
      if (d)
        for (; ++h < d.length; ) {
          const p = d[h];
          if (!p.previous || p.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function _g(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function Gv(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, l = -1, o = 0, s;
      for (; a--; ) {
        const u = i[a];
        if (typeof u == "string") {
          for (l = u.length; u.charCodeAt(l - 1) === 32; )
            o++, l--;
          if (l) break;
          l = -1;
        } else if (u === -2)
          s = !0, o++;
        else if (u !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const u = {
          type: n === e.length || s || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? l : r.start._bufferIndex + l,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...u.start
        }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
      }
      n++;
    }
  return e;
}
const Vv = {
  42: Nt,
  43: Nt,
  45: Nt,
  48: Nt,
  49: Nt,
  50: Nt,
  51: Nt,
  52: Nt,
  53: Nt,
  54: Nt,
  55: Nt,
  56: Nt,
  57: Nt,
  62: vg
}, Wv = {
  91: X7
}, Kv = {
  [-2]: Xs,
  [-1]: Xs,
  32: Xs
}, Yv = {
  35: nv,
  42: ro,
  45: [r1, ro],
  60: lv,
  61: r1,
  95: ro,
  96: t1,
  126: t1
}, jv = {
  38: bg,
  92: yg
}, Xv = {
  [-5]: Zs,
  [-4]: Zs,
  [-3]: Zs,
  33: Sv,
  38: bg,
  42: ku,
  60: [T7, hv],
  91: Tv,
  92: [ev, yg],
  93: Hc,
  95: ku,
  96: F7
}, Zv = {
  null: [ku, $v]
}, Qv = {
  null: [42, 95]
}, Jv = {
  null: []
}, ey = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Qv,
  contentInitial: Wv,
  disable: Jv,
  document: Vv,
  flow: Yv,
  flowInitial: Kv,
  insideSpan: Zv,
  string: jv,
  text: Xv
}, Symbol.toStringTag, { value: "Module" }));
function ty(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, a = [];
  let l = [], o = [];
  const s = {
    attempt: z(R),
    check: z(T),
    consume: v,
    enter: x,
    exit: C,
    interrupt: z(T, {
      interrupt: !0
    })
  }, u = {
    code: null,
    containerState: {},
    defineSkip: w,
    events: [],
    now: g,
    parser: e,
    previous: null,
    sliceSerialize: h,
    sliceStream: p,
    write: d
  };
  let c = t.tokenize.call(u, s);
  return t.resolveAll && a.push(t), u;
  function d(V) {
    return l = jt(l, V), S(), l[l.length - 1] !== null ? [] : (P(t, 0), u.events = us(a, u.events, u), u.events);
  }
  function h(V, K) {
    return ry(p(V), K);
  }
  function p(V) {
    return ny(l, V);
  }
  function g() {
    const {
      _bufferIndex: V,
      _index: K,
      line: ae,
      column: ie,
      offset: re
    } = r;
    return {
      _bufferIndex: V,
      _index: K,
      line: ae,
      column: ie,
      offset: re
    };
  }
  function w(V) {
    i[V.line] = V.column, O();
  }
  function S() {
    let V;
    for (; r._index < l.length; ) {
      const K = l[r._index];
      if (typeof K == "string")
        for (V = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === V && r._bufferIndex < K.length; )
          y(K.charCodeAt(r._bufferIndex));
      else
        y(K);
    }
  }
  function y(V) {
    c = c(V);
  }
  function v(V) {
    le(V) ? (r.line++, r.column = 1, r.offset += V === -3 ? 2 : 1, O()) : V !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    l[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = V;
  }
  function x(V, K) {
    const ae = K || {};
    return ae.type = V, ae.start = g(), u.events.push(["enter", ae, u]), o.push(ae), ae;
  }
  function C(V) {
    const K = o.pop();
    return K.end = g(), u.events.push(["exit", K, u]), K;
  }
  function R(V, K) {
    P(V, K.from);
  }
  function T(V, K) {
    K.restore();
  }
  function z(V, K) {
    return ae;
    function ae(ie, re, ge) {
      let B, I, $, E;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        ee(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        ee([
          /** @type {Construct} */
          ie
        ])
      ) : Z(ie);
      function Z(he) {
        return qe;
        function qe(Ke) {
          const ut = Ke !== null && he[Ke], gt = Ke !== null && he.null, vn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ut) ? ut : ut ? [ut] : [],
            ...Array.isArray(gt) ? gt : gt ? [gt] : []
          ];
          return ee(vn)(Ke);
        }
      }
      function ee(he) {
        return B = he, I = 0, he.length === 0 ? ge : A(he[I]);
      }
      function A(he) {
        return qe;
        function qe(Ke) {
          return E = U(), $ = he, he.partial || (u.currentConstruct = he), he.name && u.parser.constructs.disable.null.includes(he.name) ? xe() : he.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            K ? Object.assign(Object.create(u), K) : u,
            s,
            Se,
            xe
          )(Ke);
        }
      }
      function Se(he) {
        return V($, E), re;
      }
      function xe(he) {
        return E.restore(), ++I < B.length ? A(B[I]) : ge;
      }
    }
  }
  function P(V, K) {
    V.resolveAll && !a.includes(V) && a.push(V), V.resolve && Ht(u.events, K, u.events.length - K, V.resolve(u.events.slice(K), u)), V.resolveTo && (u.events = V.resolveTo(u.events, u));
  }
  function U() {
    const V = g(), K = u.previous, ae = u.currentConstruct, ie = u.events.length, re = Array.from(o);
    return {
      from: ie,
      restore: ge
    };
    function ge() {
      r = V, u.previous = K, u.currentConstruct = ae, u.events.length = ie, o = re, O();
    }
  }
  function O() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function ny(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let l;
  if (n === i)
    l = [e[n].slice(r, a)];
  else {
    if (l = e.slice(n, i), r > -1) {
      const o = l[0];
      typeof o == "string" ? l[0] = o.slice(r) : l.shift();
    }
    a > 0 && l.push(e[i].slice(0, a));
  }
  return l;
}
function ry(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let l;
    if (typeof a == "string")
      l = a;
    else switch (a) {
      case -5: {
        l = "\r";
        break;
      }
      case -4: {
        l = `
`;
        break;
      }
      case -3: {
        l = `\r
`;
        break;
      }
      case -2: {
        l = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        l = " ";
        break;
      }
      default:
        l = String.fromCharCode(a);
    }
    i = a === -2, r.push(l);
  }
  return r.join("");
}
function iy(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      mg([ey, ...(e || {}).extensions || []])
    ),
    content: i(b7),
    defined: [],
    document: i(x7),
    flow: i(Fv),
    lazy: {},
    string: i(Hv),
    text: i(qv)
  };
  return r;
  function i(a) {
    return l;
    function l(o) {
      return ty(r, a, o);
    }
  }
}
function ay(e) {
  for (; !wg(e); )
    ;
  return e;
}
const i1 = /[\0\t\n\r]/g;
function ly() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, l, o) {
    const s = [];
    let u, c, d, h, p;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(l || void 0).decode(a)), d = 0, t = "", n && (a.charCodeAt(0) === 65279 && d++, n = void 0); d < a.length; ) {
      if (i1.lastIndex = d, u = i1.exec(a), h = u && u.index !== void 0 ? u.index : a.length, p = a.charCodeAt(h), !u) {
        t = a.slice(d);
        break;
      }
      if (p === 10 && d === h && r)
        s.push(-3), r = void 0;
      else
        switch (r && (s.push(-5), r = void 0), d < h && (s.push(a.slice(d, h)), e += h - d), p) {
          case 0: {
            s.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, s.push(-2); e++ < c; ) s.push(-1);
            break;
          }
          case 10: {
            s.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = h + 1;
    }
    return o && (r && s.push(-5), t && s.push(t), s.push(null)), s;
  }
}
const oy = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function sy(e) {
  return e.replace(oy, uy);
}
function uy(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return gg(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return $c(n) || e;
}
const Tg = {}.hasOwnProperty;
function cy(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), dy(n)(ay(iy(n).document().write(ly()(e, t, !0))));
}
function dy(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(de),
      autolinkProtocol: U,
      autolinkEmail: U,
      atxHeading: a(zt),
      blockQuote: a(gt),
      characterEscape: U,
      characterReference: U,
      codeFenced: a(vn),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: a(vn, l),
      codeText: a(Mr, l),
      codeTextData: U,
      data: U,
      codeFlowValue: U,
      definition: a(Or),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: a(ye),
      hardBreakEscape: a(Ge),
      hardBreakTrailing: a(Ge),
      htmlFlow: a(yn, l),
      htmlFlowData: U,
      htmlText: a(yn, l),
      htmlTextData: U,
      image: a(bn),
      label: l,
      link: a(de),
      listItem: a(Je),
      listItemValue: h,
      listOrdered: a(ji, d),
      listUnordered: a(ji),
      paragraph: a(Ae),
      reference: A,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: a(zt),
      strong: a(ri),
      thematicBreak: a(Xi)
    },
    exit: {
      atxHeading: s(),
      atxHeadingSequence: R,
      autolink: s(),
      autolinkEmail: ut,
      autolinkProtocol: Ke,
      blockQuote: s(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: xe,
      characterReferenceMarkerNumeric: xe,
      characterReferenceValue: he,
      characterReference: qe,
      codeFenced: s(S),
      codeFencedFence: w,
      codeFencedFenceInfo: p,
      codeFencedFenceMeta: g,
      codeFlowValue: O,
      codeIndented: s(y),
      codeText: s(re),
      codeTextData: O,
      data: O,
      definition: s(),
      definitionDestinationString: C,
      definitionLabelString: v,
      definitionTitleString: x,
      emphasis: s(),
      hardBreakEscape: s(K),
      hardBreakTrailing: s(K),
      htmlFlow: s(ae),
      htmlFlowData: O,
      htmlText: s(ie),
      htmlTextData: O,
      image: s(B),
      label: $,
      labelText: I,
      lineEnding: V,
      link: s(ge),
      listItem: s(),
      listOrdered: s(),
      listUnordered: s(),
      paragraph: s(),
      referenceString: Se,
      resourceDestinationString: E,
      resourceTitleString: Z,
      resource: ee,
      setextHeading: s(P),
      setextHeadingLineSequence: z,
      setextHeadingText: T,
      strong: s(),
      thematicBreak: s()
    }
  };
  Ng(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(F) {
    let L = {
      type: "root",
      children: []
    };
    const q = {
      stack: [L],
      tokenStack: [],
      config: t,
      enter: o,
      exit: u,
      buffer: l,
      resume: c,
      data: n
    }, Q = [];
    let oe = -1;
    for (; ++oe < F.length; )
      if (F[oe][1].type === "listOrdered" || F[oe][1].type === "listUnordered")
        if (F[oe][0] === "enter")
          Q.push(oe);
        else {
          const Te = Q.pop();
          oe = i(F, Te, oe);
        }
    for (oe = -1; ++oe < F.length; ) {
      const Te = t[F[oe][0]];
      Tg.call(Te, F[oe][1].type) && Te[F[oe][1].type].call(Object.assign({
        sliceSerialize: F[oe][2].sliceSerialize
      }, q), F[oe][1]);
    }
    if (q.tokenStack.length > 0) {
      const Te = q.tokenStack[q.tokenStack.length - 1];
      (Te[1] || a1).call(q, void 0, Te[0]);
    }
    for (L.position = {
      start: tr(F.length > 0 ? F[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: tr(F.length > 0 ? F[F.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, oe = -1; ++oe < t.transforms.length; )
      L = t.transforms[oe](L) || L;
    return L;
  }
  function i(F, L, q) {
    let Q = L - 1, oe = -1, Te = !1, at, on, Rr, Zi;
    for (; ++Q <= q; ) {
      const Lt = F[Q];
      switch (Lt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Lt[0] === "enter" ? oe++ : oe--, Zi = void 0;
          break;
        }
        case "lineEndingBlank": {
          Lt[0] === "enter" && (at && !Zi && !oe && !Rr && (Rr = Q), Zi = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Zi = void 0;
      }
      if (!oe && Lt[0] === "enter" && Lt[1].type === "listItemPrefix" || oe === -1 && Lt[0] === "exit" && (Lt[1].type === "listUnordered" || Lt[1].type === "listOrdered")) {
        if (at) {
          let ii = Q;
          for (on = void 0; ii--; ) {
            const Dn = F[ii];
            if (Dn[1].type === "lineEnding" || Dn[1].type === "lineEndingBlank") {
              if (Dn[0] === "exit") continue;
              on && (F[on][1].type = "lineEndingBlank", Te = !0), Dn[1].type = "lineEnding", on = ii;
            } else if (!(Dn[1].type === "linePrefix" || Dn[1].type === "blockQuotePrefix" || Dn[1].type === "blockQuotePrefixWhitespace" || Dn[1].type === "blockQuoteMarker" || Dn[1].type === "listItemIndent")) break;
          }
          Rr && (!on || Rr < on) && (at._spread = !0), at.end = Object.assign({}, on ? F[on][1].start : Lt[1].end), F.splice(on || Q, 0, ["exit", at, Lt[2]]), Q++, q++;
        }
        if (Lt[1].type === "listItemPrefix") {
          const ii = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Lt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          at = ii, F.splice(Q, 0, ["enter", ii, Lt[2]]), Q++, q++, Rr = void 0, Zi = !0;
        }
      }
    }
    return F[L][1]._spread = Te, q;
  }
  function a(F, L) {
    return q;
    function q(Q) {
      o.call(this, F(Q), Q), L && L.call(this, Q);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(F, L, q) {
    this.stack[this.stack.length - 1].children.push(F), this.stack.push(F), this.tokenStack.push([L, q || void 0]), F.position = {
      start: tr(L.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function s(F) {
    return L;
    function L(q) {
      F && F.call(this, q), u.call(this, q);
    }
  }
  function u(F, L) {
    const q = this.stack.pop(), Q = this.tokenStack.pop();
    if (Q)
      Q[0].type !== F.type && (L ? L.call(this, F, Q[0]) : (Q[1] || a1).call(this, F, Q[0]));
    else throw new Error("Cannot close `" + F.type + "` (" + Ea({
      start: F.start,
      end: F.end
    }) + "): its not open");
    q.position.end = tr(F.end);
  }
  function c() {
    return Uc(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function h(F) {
    if (this.data.expectingFirstListItemValue) {
      const L = this.stack[this.stack.length - 2];
      L.start = Number.parseInt(this.sliceSerialize(F), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function p() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.lang = F;
  }
  function g() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.meta = F;
  }
  function w() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function S() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.value = F.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function y() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.value = F.replace(/(\r?\n|\r)$/g, "");
  }
  function v(F) {
    const L = this.resume(), q = this.stack[this.stack.length - 1];
    q.label = L, q.identifier = mn(this.sliceSerialize(F)).toLowerCase();
  }
  function x() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.title = F;
  }
  function C() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.url = F;
  }
  function R(F) {
    const L = this.stack[this.stack.length - 1];
    if (!L.depth) {
      const q = this.sliceSerialize(F).length;
      L.depth = q;
    }
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function z(F) {
    const L = this.stack[this.stack.length - 1];
    L.depth = this.sliceSerialize(F).codePointAt(0) === 61 ? 1 : 2;
  }
  function P() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function U(F) {
    const q = this.stack[this.stack.length - 1].children;
    let Q = q[q.length - 1];
    (!Q || Q.type !== "text") && (Q = In(), Q.position = {
      start: tr(F.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, q.push(Q)), this.stack.push(Q);
  }
  function O(F) {
    const L = this.stack.pop();
    L.value += this.sliceSerialize(F), L.position.end = tr(F.end);
  }
  function V(F) {
    const L = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const q = L.children[L.children.length - 1];
      q.position.end = tr(F.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(L.type) && (U.call(this, F), O.call(this, F));
  }
  function K() {
    this.data.atHardBreak = !0;
  }
  function ae() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.value = F;
  }
  function ie() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.value = F;
  }
  function re() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.value = F;
  }
  function ge() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const L = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = L, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function B() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const L = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = L, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function I(F) {
    const L = this.sliceSerialize(F), q = this.stack[this.stack.length - 2];
    q.label = sy(L), q.identifier = mn(L).toLowerCase();
  }
  function $() {
    const F = this.stack[this.stack.length - 1], L = this.resume(), q = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, q.type === "link") {
      const Q = F.children;
      q.children = Q;
    } else
      q.alt = L;
  }
  function E() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.url = F;
  }
  function Z() {
    const F = this.resume(), L = this.stack[this.stack.length - 1];
    L.title = F;
  }
  function ee() {
    this.data.inReference = void 0;
  }
  function A() {
    this.data.referenceType = "collapsed";
  }
  function Se(F) {
    const L = this.resume(), q = this.stack[this.stack.length - 1];
    q.label = L, q.identifier = mn(this.sliceSerialize(F)).toLowerCase(), this.data.referenceType = "full";
  }
  function xe(F) {
    this.data.characterReferenceType = F.type;
  }
  function he(F) {
    const L = this.sliceSerialize(F), q = this.data.characterReferenceType;
    let Q;
    q ? (Q = gg(L, q === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Q = $c(L);
    const oe = this.stack[this.stack.length - 1];
    oe.value += Q;
  }
  function qe(F) {
    const L = this.stack.pop();
    L.position.end = tr(F.end);
  }
  function Ke(F) {
    O.call(this, F);
    const L = this.stack[this.stack.length - 1];
    L.url = this.sliceSerialize(F);
  }
  function ut(F) {
    O.call(this, F);
    const L = this.stack[this.stack.length - 1];
    L.url = "mailto:" + this.sliceSerialize(F);
  }
  function gt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function vn() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Mr() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Or() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ye() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function zt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ge() {
    return {
      type: "break"
    };
  }
  function yn() {
    return {
      type: "html",
      value: ""
    };
  }
  function bn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function de() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function ji(F) {
    return {
      type: "list",
      ordered: F.type === "listOrdered",
      start: null,
      spread: F._spread,
      children: []
    };
  }
  function Je(F) {
    return {
      type: "listItem",
      spread: F._spread,
      checked: null,
      children: []
    };
  }
  function Ae() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ri() {
    return {
      type: "strong",
      children: []
    };
  }
  function In() {
    return {
      type: "text",
      value: ""
    };
  }
  function Xi() {
    return {
      type: "thematicBreak"
    };
  }
}
function tr(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function Ng(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Ng(e, r) : fy(e, r);
  }
}
function fy(e, t) {
  let n;
  for (n in t)
    if (Tg.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function a1(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Ea({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Ea({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Ea({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function hy(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return cy(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function py(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function my(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function gy(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function vy(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function yy(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function by(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Wi(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let l, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), l = e.footnoteOrder.length) : l = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const s = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, s);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [s]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function wy(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function xy(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function Ag(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const l = i[i.length - 1];
  return l && l.type === "text" ? l.value += r : i.push({ type: "text", value: r }), i;
}
function ky(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return Ag(e, t);
  const i = { src: Wi(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function Ey(e, t) {
  const n = { src: Wi(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Sy(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function _y(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return Ag(e, t);
  const i = { href: Wi(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Ty(e, t) {
  const n = { href: Wi(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Ny(e, t, n) {
  const r = e.all(t), i = n ? Ay(n) : Cg(t), a = {}, l = [];
  if (typeof t.checked == "boolean") {
    const c = r[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const c = r[o];
    (i || o !== 0 || c.type !== "element" || c.tagName !== "p") && l.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? l.push(...c.children) : l.push(c);
  }
  const s = r[r.length - 1];
  s && (i || s.type !== "element" || s.tagName !== "p") && l.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: a, children: l };
  return e.patch(t, u), e.applyData(t, u);
}
function Ay(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = Cg(n[r]);
  }
  return t;
}
function Cg(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Cy(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const l = r[i];
    if (l.type === "element" && l.tagName === "li" && l.properties && Array.isArray(l.properties.className) && l.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function My(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Oy(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Ry(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Iy(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const l = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], l), i.push(l);
  }
  if (n.length > 0) {
    const l = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = Lc(t.children[1]), s = lg(t.children[t.children.length - 1]);
    o && s && (l.position = { start: o, end: s }), i.push(l);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Dy(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", l = n && n.type === "table" ? n.align : void 0, o = l ? l.length : t.children.length;
  let s = -1;
  const u = [];
  for (; ++s < o; ) {
    const d = t.children[s], h = {}, p = l ? l[s] : void 0;
    p && (h.align = p);
    let g = { type: "element", tagName: a, properties: h, children: [] };
    d && (g.children = e.all(d), e.patch(d, g), g = e.applyData(d, g)), u.push(g);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function zy(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const l1 = 9, o1 = 32;
function Ly(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      s1(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(s1(t.slice(i), i > 0, !1)), a.join("");
}
function s1(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === l1 || a === o1; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === l1 || a === o1; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function Py(e, t) {
  const n = { type: "text", value: Ly(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function By(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Fy = {
  blockquote: py,
  break: my,
  code: gy,
  delete: vy,
  emphasis: yy,
  footnoteReference: by,
  heading: wy,
  html: xy,
  imageReference: ky,
  image: Ey,
  inlineCode: Sy,
  linkReference: _y,
  link: Ty,
  listItem: Ny,
  list: Cy,
  paragraph: My,
  // @ts-expect-error: root is different, but hard to type.
  root: Oy,
  strong: Ry,
  table: Iy,
  tableCell: zy,
  tableRow: Dy,
  text: Py,
  thematicBreak: By,
  toml: Tl,
  yaml: Tl,
  definition: Tl,
  footnoteDefinition: Tl
};
function Tl() {
}
const Mg = -1, cs = 0, Io = 1, Do = 2, qc = 3, Gc = 4, Vc = 5, Wc = 6, Og = 7, Rg = 8, u1 = typeof self == "object" ? self : globalThis, Uy = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, l] = t[i];
    switch (a) {
      case cs:
      case Mg:
        return n(l, i);
      case Io: {
        const o = n([], i);
        for (const s of l)
          o.push(r(s));
        return o;
      }
      case Do: {
        const o = n({}, i);
        for (const [s, u] of l)
          o[r(s)] = r(u);
        return o;
      }
      case qc:
        return n(new Date(l), i);
      case Gc: {
        const { source: o, flags: s } = l;
        return n(new RegExp(o, s), i);
      }
      case Vc: {
        const o = n(/* @__PURE__ */ new Map(), i);
        for (const [s, u] of l)
          o.set(r(s), r(u));
        return o;
      }
      case Wc: {
        const o = n(/* @__PURE__ */ new Set(), i);
        for (const s of l)
          o.add(r(s));
        return o;
      }
      case Og: {
        const { name: o, message: s } = l;
        return n(new u1[o](s), i);
      }
      case Rg:
        return n(BigInt(l), i);
      case "BigInt":
        return n(Object(BigInt(l)), i);
    }
    return n(new u1[a](l), i);
  };
  return r;
}, c1 = (e) => Uy(/* @__PURE__ */ new Map(), e)(0), li = "", { toString: $y } = {}, { keys: Hy } = Object, oa = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [cs, t];
  const n = $y.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Io, li];
    case "Object":
      return [Do, li];
    case "Date":
      return [qc, li];
    case "RegExp":
      return [Gc, li];
    case "Map":
      return [Vc, li];
    case "Set":
      return [Wc, li];
  }
  return n.includes("Array") ? [Io, n] : n.includes("Error") ? [Og, n] : [Do, n];
}, Nl = ([e, t]) => e === cs && (t === "function" || t === "symbol"), qy = (e, t, n, r) => {
  const i = (l, o) => {
    const s = r.push(l) - 1;
    return n.set(o, s), s;
  }, a = (l) => {
    if (n.has(l))
      return n.get(l);
    let [o, s] = oa(l);
    switch (o) {
      case cs: {
        let c = l;
        switch (s) {
          case "bigint":
            o = Rg, c = l.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + s);
            c = null;
            break;
          case "undefined":
            return i([Mg], l);
        }
        return i([o, c], l);
      }
      case Io: {
        if (s)
          return i([s, [...l]], l);
        const c = [], d = i([o, c], l);
        for (const h of l)
          c.push(a(h));
        return d;
      }
      case Do: {
        if (s)
          switch (s) {
            case "BigInt":
              return i([s, l.toString()], l);
            case "Boolean":
            case "Number":
            case "String":
              return i([s, l.valueOf()], l);
          }
        if (t && "toJSON" in l)
          return a(l.toJSON());
        const c = [], d = i([o, c], l);
        for (const h of Hy(l))
          (e || !Nl(oa(l[h]))) && c.push([a(h), a(l[h])]);
        return d;
      }
      case qc:
        return i([o, l.toISOString()], l);
      case Gc: {
        const { source: c, flags: d } = l;
        return i([o, { source: c, flags: d }], l);
      }
      case Vc: {
        const c = [], d = i([o, c], l);
        for (const [h, p] of l)
          (e || !(Nl(oa(h)) || Nl(oa(p)))) && c.push([a(h), a(p)]);
        return d;
      }
      case Wc: {
        const c = [], d = i([o, c], l);
        for (const h of l)
          (e || !Nl(oa(h))) && c.push(a(h));
        return d;
      }
    }
    const { message: u } = l;
    return i([o, { name: s, message: u }], l);
  };
  return a;
}, d1 = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return qy(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, zo = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? c1(d1(e, t)) : structuredClone(e)
) : (e, t) => c1(d1(e, t));
function Gy(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function Vy(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function Wy(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || Gy, r = e.options.footnoteBackLabel || Vy, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", l = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let s = -1;
  for (; ++s < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[s]
    );
    if (!u)
      continue;
    const c = e.all(u), d = String(u.identifier).toUpperCase(), h = Wi(d.toLowerCase());
    let p = 0;
    const g = [], w = e.footnoteCounts.get(d);
    for (; w !== void 0 && ++p <= w; ) {
      g.length > 0 && g.push({ type: "text", value: " " });
      let v = typeof n == "string" ? n : n(s, p);
      typeof v == "string" && (v = { type: "text", value: v }), g.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + h + (p > 1 ? "-" + p : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(s, p),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(v) ? v : [v]
      });
    }
    const S = c[c.length - 1];
    if (S && S.type === "element" && S.tagName === "p") {
      const v = S.children[S.children.length - 1];
      v && v.type === "text" ? v.value += " " : S.children.push({ type: "text", value: " " }), S.children.push(...g);
    } else
      c.push(...g);
    const y = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + h },
      children: e.wrap(c, !0)
    };
    e.patch(u, y), o.push(y);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...zo(l),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const il = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Xy;
    if (typeof e == "function")
      return ds(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Ky(e) : Yy(e);
    if (typeof e == "string")
      return jy(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Ky(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = il(e[n]);
  return ds(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function Yy(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return ds(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function jy(e) {
  return ds(t);
  function t(n) {
    return n && n.type === e;
  }
}
function ds(e) {
  return t;
  function t(n, r, i) {
    return !!(Zy(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function Xy() {
  return !0;
}
function Zy(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Ig = [], Qy = !0, Eu = !1, Dg = "skip";
function Kc(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = il(i), l = r ? -1 : 1;
  o(e, void 0, [])();
  function o(s, u, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      s && typeof s == "object" ? s : {}
    );
    if (typeof d.type == "string") {
      const p = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (s.type + (p ? "<" + p + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let p = Ig, g, w, S;
      if ((!t || a(s, u, c[c.length - 1] || void 0)) && (p = Jy(n(s, c)), p[0] === Eu))
        return p;
      if ("children" in s && s.children) {
        const y = (
          /** @type {UnistParent} */
          s
        );
        if (y.children && p[0] !== Dg)
          for (w = (r ? y.children.length : -1) + l, S = c.concat(y); w > -1 && w < y.children.length; ) {
            const v = y.children[w];
            if (g = o(v, w, S)(), g[0] === Eu)
              return g;
            w = typeof g[1] == "number" ? g[1] : w + l;
          }
      }
      return p;
    }
  }
}
function Jy(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Qy, e] : e == null ? Ig : [e];
}
function fs(e, t, n, r) {
  let i, a, l;
  typeof t == "function" && typeof n != "function" ? (a = void 0, l = t, i = n) : (a = t, l = n, i = r), Kc(e, a, o, i);
  function o(s, u) {
    const c = u[u.length - 1], d = c ? c.children.indexOf(s) : void 0;
    return l(s, d, c);
  }
}
const Su = {}.hasOwnProperty, e8 = {};
function t8(e, t) {
  const n = t || e8, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = { ...Fy, ...n.handlers }, o = {
    all: u,
    applyData: r8,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: l,
    one: s,
    options: n,
    patch: n8,
    wrap: a8
  };
  return fs(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? r : i, h = String(c.identifier).toUpperCase();
      d.has(h) || d.set(h, c);
    }
  }), o;
  function s(c, d) {
    const h = c.type, p = o.handlers[h];
    if (Su.call(o.handlers, h) && p)
      return p(o, c, d);
    if (o.options.passThrough && o.options.passThrough.includes(h)) {
      if ("children" in c) {
        const { children: w, ...S } = c, y = zo(S);
        return y.children = o.all(c), y;
      }
      return zo(c);
    }
    return (o.options.unknownHandler || i8)(o, c, d);
  }
  function u(c) {
    const d = [];
    if ("children" in c) {
      const h = c.children;
      let p = -1;
      for (; ++p < h.length; ) {
        const g = o.one(h[p], c);
        if (g) {
          if (p && h[p - 1].type === "break" && (!Array.isArray(g) && g.type === "text" && (g.value = f1(g.value)), !Array.isArray(g) && g.type === "element")) {
            const w = g.children[0];
            w && w.type === "text" && (w.value = f1(w.value));
          }
          Array.isArray(g) ? d.push(...g) : d.push(g);
        }
      }
    }
    return d;
  }
}
function n8(e, t) {
  e.position && (t.position = P6(e));
}
function r8(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const l = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: l };
      }
    n.type === "element" && a && Object.assign(n.properties, zo(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function i8(e, t) {
  const n = t.data || {}, r = "value" in t && !(Su.call(n, "hProperties") || Su.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function a8(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function f1(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function h1(e, t) {
  const n = t8(e, t), r = n.one(e, void 0), i = Wy(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function l8(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      h1(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      h1(n, { file: r, ...e || t })
    );
  };
}
function p1(e) {
  if (e)
    throw e;
}
var io = Object.prototype.hasOwnProperty, zg = Object.prototype.toString, m1 = Object.defineProperty, g1 = Object.getOwnPropertyDescriptor, v1 = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : zg.call(t) === "[object Array]";
}, y1 = function(t) {
  if (!t || zg.call(t) !== "[object Object]")
    return !1;
  var n = io.call(t, "constructor"), r = t.constructor && t.constructor.prototype && io.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || io.call(t, i);
}, b1 = function(t, n) {
  m1 && n.name === "__proto__" ? m1(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, w1 = function(t, n) {
  if (n === "__proto__")
    if (io.call(t, n)) {
      if (g1)
        return g1(t, n).value;
    } else return;
  return t[n];
}, o8 = function e() {
  var t, n, r, i, a, l, o = arguments[0], s = 1, u = arguments.length, c = !1;
  for (typeof o == "boolean" && (c = o, o = arguments[1] || {}, s = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); s < u; ++s)
    if (t = arguments[s], t != null)
      for (n in t)
        r = w1(o, n), i = w1(t, n), o !== i && (c && i && (y1(i) || (a = v1(i))) ? (a ? (a = !1, l = r && v1(r) ? r : []) : l = r && y1(r) ? r : {}, b1(o, { name: n, newValue: e(c, l, i) })) : typeof i < "u" && b1(o, { name: n, newValue: i }));
  return o;
};
const Qs = /* @__PURE__ */ Lh(o8);
function _u(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function s8() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const l = i.pop();
    if (typeof l != "function")
      throw new TypeError("Expected function as last argument, not " + l);
    o(null, ...i);
    function o(s, ...u) {
      const c = e[++a];
      let d = -1;
      if (s) {
        l(s);
        return;
      }
      for (; ++d < i.length; )
        (u[d] === null || u[d] === void 0) && (u[d] = i[d]);
      i = u, c ? u8(c, o)(...u) : l(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function u8(e, t) {
  let n;
  return r;
  function r(...l) {
    const o = e.length > l.length;
    let s;
    o && l.push(i);
    try {
      s = e.apply(this, l);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (o && n)
        throw c;
      return i(c);
    }
    o || (s && s.then && typeof s.then == "function" ? s.then(a, i) : s instanceof Error ? i(s) : a(s));
  }
  function i(l, ...o) {
    n || (n = !0, t(l, ...o));
  }
  function a(l) {
    i(null, l);
  }
}
const En = { basename: c8, dirname: d8, extname: f8, join: h8, sep: "/" };
function c8(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  al(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let l = -1, o = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      l < 0 && (a = !0, l = i + 1), o > -1 && (e.codePointAt(i) === t.codePointAt(o--) ? o < 0 && (r = i) : (o = -1, r = l));
  return n === r ? r = l : r < 0 && (r = e.length), e.slice(n, r);
}
function d8(e) {
  if (al(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function f8(e) {
  al(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, l;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (l) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (l = !0, n = t + 1), o === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function h8(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    al(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : p8(n);
}
function p8(e) {
  al(e);
  const t = e.codePointAt(0) === 47;
  let n = m8(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function m8(e, t) {
  let n = "", r = 0, i = -1, a = 0, l = -1, o, s;
  for (; ++l <= e.length; ) {
    if (l < e.length)
      o = e.codePointAt(l);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(i === l - 1 || a === 1)) if (i !== l - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (s = n.lastIndexOf("/"), s !== n.length - 1) {
              s < 0 ? (n = "", r = 0) : (n = n.slice(0, s), r = n.length - 1 - n.lastIndexOf("/")), i = l, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = l, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, l) : n = e.slice(i + 1, l), r = l - i - 1;
      i = l, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function al(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const g8 = { cwd: v8 };
function v8() {
  return "/";
}
function Tu(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function y8(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Tu(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return b8(e);
}
function b8(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Js = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Lg {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Tu(t) ? n = { path: t } : typeof t == "string" || w8(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : g8.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Js.length; ) {
      const a = Js[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      Js.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? En.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    t0(t, "basename"), e0(t, "basename"), this.path = En.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? En.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    x1(this.basename, "dirname"), this.path = En.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? En.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (e0(t, "extname"), x1(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = En.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Tu(t) && (t = y8(t)), t0(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? En.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    t0(t, "stem"), e0(t, "stem"), this.path = En.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new mt(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function e0(e, t) {
  if (e && e.includes(En.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + En.sep + "`"
    );
}
function t0(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function x1(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function w8(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const x8 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), k8 = {}.hasOwnProperty;
class Yc extends x8 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = s8();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Yc()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Qs(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (i0("data", this.frozen), this.namespace[t] = n, this) : k8.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (i0("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Al(t), r = this.parser || this.Parser;
    return n0("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), n0("process", this.parser || this.Parser), r0("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, l) {
      const o = Al(t), s = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(s, o, function(c, d, h) {
        if (c || !d || !h)
          return u(c);
        const p = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), g = r.stringify(p, h);
        _8(g) ? h.value = g : h.result = g, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          h
        );
      });
      function u(c, d) {
        c || !d ? l(c) : a ? a(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), n0("processSync", this.parser || this.Parser), r0("processSync", this.compiler || this.Compiler), this.process(t, i), E1("processSync", "process", n), r;
    function i(a, l) {
      n = !0, p1(a), r = l;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    k1(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(l, o) {
      const s = Al(n);
      i.run(t, s, u);
      function u(c, d, h) {
        const p = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        c ? o(c) : l ? l(p) : r(void 0, p, h);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), E1("runSync", "run", r), i;
    function a(l, o) {
      p1(l), i = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Al(n), i = this.compiler || this.Compiler;
    return r0("stringify", i), k1(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (i0("use", this.frozen), t != null) if (typeof t == "function")
      s(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : l(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(u) {
      if (typeof u == "function")
        s(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          s(c, d);
        } else
          l(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function l(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(u.plugins), u.settings && (i.settings = Qs(!0, i.settings, u.settings));
    }
    function o(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const d = u[c];
          a(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function s(u, c) {
      let d = -1, h = -1;
      for (; ++d < r.length; )
        if (r[d][0] === u) {
          h = d;
          break;
        }
      if (h === -1)
        r.push([u, ...c]);
      else if (c.length > 0) {
        let [p, ...g] = c;
        const w = r[h][1];
        _u(w) && _u(p) && (p = Qs(!0, w, p)), r[h] = [u, p, ...g];
      }
    }
  }
}
const E8 = new Yc().freeze();
function n0(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function r0(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function i0(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function k1(e) {
  if (!_u(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function E1(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Al(e) {
  return S8(e) ? e : new Lg(e);
}
function S8(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function _8(e) {
  return typeof e == "string" || T8(e);
}
function T8(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const N8 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", S1 = [], _1 = { allowDangerousHtml: !0 }, A8 = /^(https?|ircs?|mailto|xmpp)$/i, C8 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function M8(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, a = e.components, l = e.disallowedElements, o = e.rehypePlugins || S1, s = e.remarkPlugins || S1, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ..._1 } : _1, c = e.skipHtml, d = e.unwrapDisallowed, h = e.urlTransform || O8, p = E8().use(hy).use(s).use(l8, u).use(o), g = new Lg();
  typeof r == "string" && (g.value = r);
  for (const v of C8)
    Object.hasOwn(e, v.from) && ("" + v.from + (v.to ? "use `" + v.to + "` instead" : "remove it") + N8 + v.id, void 0);
  const w = p.parse(g);
  let S = p.runSync(w, g);
  return i && (S = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      S.type === "root" ? S.children : [S]
    )
  }), fs(S, y), q6(S, {
    Fragment: js.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: js.jsx,
    jsxs: js.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function y(v, x, C) {
    if (v.type === "raw" && C && typeof x == "number")
      return c ? C.children.splice(x, 1) : C.children[x] = { type: "text", value: v.value }, x;
    if (v.type === "element") {
      let R;
      for (R in Ys)
        if (Object.hasOwn(Ys, R) && Object.hasOwn(v.properties, R)) {
          const T = v.properties[R], z = Ys[R];
          (z === null || z.includes(v.tagName)) && (v.properties[R] = h(String(T || ""), R, v));
        }
    }
    if (v.type === "element") {
      let R = t ? !t.includes(v.tagName) : l ? l.includes(v.tagName) : !1;
      if (!R && n && typeof x == "number" && (R = !n(v, x, C)), R && C && typeof x == "number")
        return d && v.children ? C.children.splice(x, 1, ...v.children) : C.children.splice(x, 1), x;
    }
  }
}
function O8(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    A8.test(e.slice(0, t)) ? e : ""
  );
}
function T1(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function R8(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function I8(e, t, n) {
  const i = il((n || {}).ignore || []), a = D8(t);
  let l = -1;
  for (; ++l < a.length; )
    Kc(e, "text", o);
  function o(u, c) {
    let d = -1, h;
    for (; ++d < c.length; ) {
      const p = c[d], g = h ? h.children : void 0;
      if (i(
        p,
        g ? g.indexOf(p) : void 0,
        h
      ))
        return;
      h = p;
    }
    if (h)
      return s(u, c);
  }
  function s(u, c) {
    const d = c[c.length - 1], h = a[l][0], p = a[l][1];
    let g = 0;
    const S = d.children.indexOf(u);
    let y = !1, v = [];
    h.lastIndex = 0;
    let x = h.exec(u.value);
    for (; x; ) {
      const C = x.index, R = {
        index: x.index,
        input: x.input,
        stack: [...c, u]
      };
      let T = p(...x, R);
      if (typeof T == "string" && (T = T.length > 0 ? { type: "text", value: T } : void 0), T === !1 ? h.lastIndex = C + 1 : (g !== C && v.push({
        type: "text",
        value: u.value.slice(g, C)
      }), Array.isArray(T) ? v.push(...T) : T && v.push(T), g = C + x[0].length, y = !0), !h.global)
        break;
      x = h.exec(u.value);
    }
    return y ? (g < u.value.length && v.push({ type: "text", value: u.value.slice(g) }), d.children.splice(S, 1, ...v)) : v = [u], S + v.length;
  }
}
function D8(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([z8(i[0]), L8(i[1])]);
  }
  return t;
}
function z8(e) {
  return typeof e == "string" ? new RegExp(R8(e), "g") : e;
}
function L8(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const a0 = "phrasing", l0 = ["autolink", "link", "image", "label"];
function P8() {
  return {
    transforms: [G8],
    enter: {
      literalAutolink: F8,
      literalAutolinkEmail: o0,
      literalAutolinkHttp: o0,
      literalAutolinkWww: o0
    },
    exit: {
      literalAutolink: q8,
      literalAutolinkEmail: H8,
      literalAutolinkHttp: U8,
      literalAutolinkWww: $8
    }
  };
}
function B8() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: a0,
        notInConstruct: l0
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: a0,
        notInConstruct: l0
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: a0,
        notInConstruct: l0
      }
    ]
  };
}
function F8(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function o0(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function U8(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function $8(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function H8(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function q8(e) {
  this.exit(e);
}
function G8(e) {
  I8(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, V8],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), W8]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function V8(e, t, n, r, i) {
  let a = "";
  if (!Pg(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !K8(n)))
    return !1;
  const l = Y8(n + r);
  if (!l[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + l[0],
    children: [{ type: "text", value: t + l[0] }]
  };
  return l[1] ? [o, { type: "text", value: l[1] }] : o;
}
function W8(e, t, n, r) {
  return (
    // Not an expected previous character.
    !Pg(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function K8(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Y8(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = T1(e, "(");
  let a = T1(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function Pg(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Xr(n) || ss(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
Bg.peek = ab;
function j8() {
  return {
    enter: {
      gfmFootnoteDefinition: Z8,
      gfmFootnoteDefinitionLabelString: Q8,
      gfmFootnoteCall: tb,
      gfmFootnoteCallString: nb
    },
    exit: {
      gfmFootnoteDefinition: eb,
      gfmFootnoteDefinitionLabelString: J8,
      gfmFootnoteCall: ib,
      gfmFootnoteCallString: rb
    }
  };
}
function X8() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: lb, footnoteReference: Bg }
  };
}
function Z8(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Q8() {
  this.buffer();
}
function J8(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = mn(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function eb(e) {
  this.exit(e);
}
function tb(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function nb() {
  this.buffer();
}
function rb(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = mn(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function ib(e) {
  this.exit(e);
}
function Bg(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const l = n.enter("footnoteReference"), o = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), o(), l(), a += i.move("]"), a;
}
function ab() {
  return "[";
}
function lb(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const l = n.enter("footnoteDefinition"), o = n.enter("label");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), o(), a += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), a += i.move(
    n.indentLines(n.containerFlow(e, i.current()), ob)
  ), l(), a;
}
function ob(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const sb = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Fg.peek = hb;
function ub() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: db },
    exit: { strikethrough: fb }
  };
}
function cb() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: sb
      }
    ],
    handlers: { delete: Fg }
  };
}
function db(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function fb(e) {
  this.exit(e);
}
function Fg(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let l = i.move("~~");
  return l += n.containerPhrasing(e, {
    ...i.current(),
    before: l,
    after: "~"
  }), l += i.move("~~"), a(), l;
}
function hb() {
  return "~";
}
function pb(e) {
  return e.length;
}
function mb(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || pb, a = [], l = [], o = [], s = [];
  let u = 0, c = -1;
  for (; ++c < e.length; ) {
    const w = [], S = [];
    let y = -1;
    for (e[c].length > u && (u = e[c].length); ++y < e[c].length; ) {
      const v = gb(e[c][y]);
      if (n.alignDelimiters !== !1) {
        const x = i(v);
        S[y] = x, (s[y] === void 0 || x > s[y]) && (s[y] = x);
      }
      w.push(v);
    }
    l[c] = w, o[c] = S;
  }
  let d = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++d < u; )
      a[d] = N1(r[d]);
  else {
    const w = N1(r);
    for (; ++d < u; )
      a[d] = w;
  }
  d = -1;
  const h = [], p = [];
  for (; ++d < u; ) {
    const w = a[d];
    let S = "", y = "";
    w === 99 ? (S = ":", y = ":") : w === 108 ? S = ":" : w === 114 && (y = ":");
    let v = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      s[d] - S.length - y.length
    );
    const x = S + "-".repeat(v) + y;
    n.alignDelimiters !== !1 && (v = S.length + v + y.length, v > s[d] && (s[d] = v), p[d] = v), h[d] = x;
  }
  l.splice(1, 0, h), o.splice(1, 0, p), c = -1;
  const g = [];
  for (; ++c < l.length; ) {
    const w = l[c], S = o[c];
    d = -1;
    const y = [];
    for (; ++d < u; ) {
      const v = w[d] || "";
      let x = "", C = "";
      if (n.alignDelimiters !== !1) {
        const R = s[d] - (S[d] || 0), T = a[d];
        T === 114 ? x = " ".repeat(R) : T === 99 ? R % 2 ? (x = " ".repeat(R / 2 + 0.5), C = " ".repeat(R / 2 - 0.5)) : (x = " ".repeat(R / 2), C = x) : C = " ".repeat(R);
      }
      n.delimiterStart !== !1 && !d && y.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && v === "") && (n.delimiterStart !== !1 || d) && y.push(" "), n.alignDelimiters !== !1 && y.push(x), y.push(v), n.alignDelimiters !== !1 && y.push(C), n.padding !== !1 && y.push(" "), (n.delimiterEnd !== !1 || d !== u - 1) && y.push("|");
    }
    g.push(
      n.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return g.join(`
`);
}
function gb(e) {
  return e == null ? "" : String(e);
}
function N1(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function vb(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const l = n.indentLines(
    n.containerFlow(e, a.current()),
    yb
  );
  return i(), l;
}
function yb(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function bb(e, t) {
  return A1(e, t.inConstruct, !0) && !A1(e, t.notInConstruct, !1);
}
function A1(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function C1(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && bb(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Ug(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, l = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > l && (l = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return l;
}
function wb(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function xb(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function kb(e, t, n, r) {
  const i = xb(n), a = e.value || "", l = i === "`" ? "GraveAccent" : "Tilde";
  if (wb(e, n)) {
    const d = n.enter("codeIndented"), h = n.indentLines(a, Eb);
    return d(), h;
  }
  const o = n.createTracker(r), s = i.repeat(Math.max(Ug(a, i) + 1, 3)), u = n.enter("codeFenced");
  let c = o.move(s);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${l}`);
    c += o.move(
      n.safe(e.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${l}`);
    c += o.move(" "), c += o.move(
      n.safe(e.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), a && (c += o.move(a + `
`)), c += o.move(s), u(), c;
}
function Eb(e, t, n) {
  return (n ? "" : "    ") + e;
}
function jc(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Sb(e, t, n, r) {
  const i = jc(n), a = i === '"' ? "Quote" : "Apostrophe", l = n.enter("definition");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let u = s.move("[");
  return u += s.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...s.current()
    })
  ), u += s.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    n.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (o = n.enter("destinationRaw"), u += s.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...s.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), u += s.move(" " + i), u += s.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), o()), l(), u;
}
function _b(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Wa(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Lo(e, t, n) {
  const r = Fi(e), i = Fi(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
$g.peek = Tb;
function $g(e, t, n, r) {
  const i = _b(n), a = n.enter("emphasis"), l = n.createTracker(r), o = l.move(i);
  let s = l.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...l.current()
    })
  );
  const u = s.charCodeAt(0), c = Lo(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  c.inside && (s = Wa(u) + s.slice(1));
  const d = s.charCodeAt(s.length - 1), h = Lo(r.after.charCodeAt(0), d, i);
  h.inside && (s = s.slice(0, -1) + Wa(d));
  const p = l.move(i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: c.outside
  }, o + s + p;
}
function Tb(e, t, n) {
  return n.options.emphasis || "*";
}
function Nb(e, t) {
  let n = !1;
  return fs(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Eu;
  }), !!((!e.depth || e.depth < 3) && Uc(e) && (t.options.setext || n));
}
function Ab(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (Nb(e, n)) {
    const c = n.enter("headingSetext"), d = n.enter("phrasing"), h = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), h + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      h.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
    );
  }
  const l = "#".repeat(i), o = n.enter("headingAtx"), s = n.enter("phrasing");
  a.move(l + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(u) && (u = Wa(u.charCodeAt(0)) + u.slice(1)), u = u ? l + " " + u : l, n.options.closeAtx && (u += " " + l), s(), o(), u;
}
Hg.peek = Cb;
function Hg(e) {
  return e.value || "";
}
function Cb() {
  return "<";
}
qg.peek = Mb;
function qg(e, t, n, r) {
  const i = jc(n), a = i === '"' ? "Quote" : "Apostrophe", l = n.enter("image");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let u = s.move("![");
  return u += s.move(
    n.safe(e.alt, { before: u, after: "]", ...s.current() })
  ), u += s.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    n.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (o = n.enter("destinationRaw"), u += s.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), u += s.move(" " + i), u += s.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), o()), u += s.move(")"), l(), u;
}
function Mb() {
  return "!";
}
Gg.peek = Ob;
function Gg(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let l = n.enter("label");
  const o = n.createTracker(r);
  let s = o.move("![");
  const u = n.safe(e.alt, {
    before: s,
    after: "]",
    ...o.current()
  });
  s += o.move(u + "]["), l();
  const c = n.stack;
  n.stack = [], l = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: s,
    after: "]",
    ...o.current()
  });
  return l(), n.stack = c, a(), i === "full" || !u || u !== d ? s += o.move(d + "]") : i === "shortcut" ? s = s.slice(0, -1) : s += o.move("]"), s;
}
function Ob() {
  return "!";
}
Vg.peek = Rb;
function Vg(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const l = n.unsafe[a], o = n.compilePattern(l);
    let s;
    if (l.atBreak)
      for (; s = o.exec(r); ) {
        let u = s.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(s.index + 1);
      }
  }
  return i + r + i;
}
function Rb() {
  return "`";
}
function Wg(e, t) {
  const n = Uc(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
Kg.peek = Ib;
function Kg(e, t, n, r) {
  const i = jc(n), a = i === '"' ? "Quote" : "Apostrophe", l = n.createTracker(r);
  let o, s;
  if (Wg(e, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = l.move("<");
    return d += l.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...l.current()
      })
    ), d += l.move(">"), o(), n.stack = c, d;
  }
  o = n.enter("link"), s = n.enter("label");
  let u = l.move("[");
  return u += l.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...l.current()
    })
  ), u += l.move("]("), s(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), u += l.move(" " + i), u += l.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), s()), u += l.move(")"), o(), u;
}
function Ib(e, t, n) {
  return Wg(e, n) ? "<" : "[";
}
Yg.peek = Db;
function Yg(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let l = n.enter("label");
  const o = n.createTracker(r);
  let s = o.move("[");
  const u = n.containerPhrasing(e, {
    before: s,
    after: "]",
    ...o.current()
  });
  s += o.move(u + "]["), l();
  const c = n.stack;
  n.stack = [], l = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: s,
    after: "]",
    ...o.current()
  });
  return l(), n.stack = c, a(), i === "full" || !u || u !== d ? s += o.move(d + "]") : i === "shortcut" ? s = s.slice(0, -1) : s += o.move("]"), s;
}
function Db() {
  return "[";
}
function Xc(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function zb(e) {
  const t = Xc(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function Lb(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function jg(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Pb(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let l = e.ordered ? Lb(n) : Xc(n);
  const o = e.ordered ? l === "." ? ")" : "." : zb(n);
  let s = t && n.bulletLastUsed ? l === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (l === "*" || l === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (s = !0), jg(n) === l && c
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const h = e.children[d];
        if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
          s = !0;
          break;
        }
      }
    }
  }
  s && (l = o), n.bulletCurrent = l;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = l, n.bulletCurrent = a, i(), u;
}
function Bb(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Fb(e, t, n, r) {
  const i = Bb(n);
  let a = n.bulletCurrent || Xc(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let l = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (l = Math.ceil(l / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(l - a.length)), o.shift(l);
  const s = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, o.current()),
    c
  );
  return s(), u;
  function c(d, h, p) {
    return h ? (p ? "" : " ".repeat(l)) + d : (p ? a : a + " ".repeat(l - a.length)) + d;
  }
}
function Ub(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), l = n.containerPhrasing(e, r);
  return a(), i(), l;
}
const $b = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  il([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Hb(e, t, n, r) {
  return (e.children.some(function(l) {
    return $b(l);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function qb(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Xg.peek = Gb;
function Xg(e, t, n, r) {
  const i = qb(n), a = n.enter("strong"), l = n.createTracker(r), o = l.move(i + i);
  let s = l.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...l.current()
    })
  );
  const u = s.charCodeAt(0), c = Lo(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  c.inside && (s = Wa(u) + s.slice(1));
  const d = s.charCodeAt(s.length - 1), h = Lo(r.after.charCodeAt(0), d, i);
  h.inside && (s = s.slice(0, -1) + Wa(d));
  const p = l.move(i + i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: c.outside
  }, o + s + p;
}
function Gb(e, t, n) {
  return n.options.strong || "*";
}
function Vb(e, t, n, r) {
  return n.safe(e.value, r);
}
function Wb(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Kb(e, t, n) {
  const r = (jg(n) + (n.options.ruleSpaces ? " " : "")).repeat(Wb(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Zg = {
  blockquote: vb,
  break: C1,
  code: kb,
  definition: Sb,
  emphasis: $g,
  hardBreak: C1,
  heading: Ab,
  html: Hg,
  image: qg,
  imageReference: Gg,
  inlineCode: Vg,
  link: Kg,
  linkReference: Yg,
  list: Pb,
  listItem: Fb,
  paragraph: Ub,
  root: Hb,
  strong: Xg,
  text: Vb,
  thematicBreak: Kb
};
function Yb() {
  return {
    enter: {
      table: jb,
      tableData: M1,
      tableHeader: M1,
      tableRow: Zb
    },
    exit: {
      codeText: Qb,
      table: Xb,
      tableData: s0,
      tableHeader: s0,
      tableRow: s0
    }
  };
}
function jb(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Xb(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Zb(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function s0(e) {
  this.exit(e);
}
function M1(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Qb(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Jb));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Jb(e, t) {
  return t === "|" ? t : e;
}
function e9(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: h,
      table: l,
      tableCell: s,
      tableRow: o
    }
  };
  function l(p, g, w, S) {
    return u(c(p, w, S), p.align);
  }
  function o(p, g, w, S) {
    const y = d(p, w, S), v = u([y]);
    return v.slice(0, v.indexOf(`
`));
  }
  function s(p, g, w, S) {
    const y = w.enter("tableCell"), v = w.enter("phrasing"), x = w.containerPhrasing(p, {
      ...S,
      before: a,
      after: a
    });
    return v(), y(), x;
  }
  function u(p, g) {
    return mb(p, {
      align: g,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function c(p, g, w) {
    const S = p.children;
    let y = -1;
    const v = [], x = g.enter("table");
    for (; ++y < S.length; )
      v[y] = d(S[y], g, w);
    return x(), v;
  }
  function d(p, g, w) {
    const S = p.children;
    let y = -1;
    const v = [], x = g.enter("tableRow");
    for (; ++y < S.length; )
      v[y] = s(S[y], p, g, w);
    return x(), v;
  }
  function h(p, g, w) {
    let S = Zg.inlineCode(p, g, w);
    return w.stack.includes("tableCell") && (S = S.replace(/\|/g, "\\$&")), S;
  }
}
function t9() {
  return {
    exit: {
      taskListCheckValueChecked: O1,
      taskListCheckValueUnchecked: O1,
      paragraph: r9
    }
  };
}
function n9() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: i9 }
  };
}
function O1(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function r9(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, l;
      for (; ++a < i.length; ) {
        const o = i[a];
        if (o.type === "paragraph") {
          l = o;
          break;
        }
      }
      l === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function i9(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", l = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(l);
  let s = Zg.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (s = s.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), s;
  function u(c) {
    return c + l;
  }
}
function a9() {
  return [
    P8(),
    j8(),
    ub(),
    Yb(),
    t9()
  ];
}
function l9(e) {
  return {
    extensions: [
      B8(),
      X8(),
      cb(),
      e9(e),
      n9()
    ]
  };
}
const o9 = {
  tokenize: h9,
  partial: !0
}, Qg = {
  tokenize: p9,
  partial: !0
}, Jg = {
  tokenize: m9,
  partial: !0
}, e4 = {
  tokenize: g9,
  partial: !0
}, s9 = {
  tokenize: v9,
  partial: !0
}, t4 = {
  name: "wwwAutolink",
  tokenize: d9,
  previous: r4
}, n4 = {
  name: "protocolAutolink",
  tokenize: f9,
  previous: i4
}, Qn = {
  name: "emailAutolink",
  tokenize: c9,
  previous: a4
}, Cn = {};
function u9() {
  return {
    text: Cn
  };
}
let Ir = 48;
for (; Ir < 123; )
  Cn[Ir] = Qn, Ir++, Ir === 58 ? Ir = 65 : Ir === 91 && (Ir = 97);
Cn[43] = Qn;
Cn[45] = Qn;
Cn[46] = Qn;
Cn[95] = Qn;
Cn[72] = [Qn, n4];
Cn[104] = [Qn, n4];
Cn[87] = [Qn, t4];
Cn[119] = [Qn, t4];
function c9(e, t, n) {
  const r = this;
  let i, a;
  return l;
  function l(d) {
    return !Nu(d) || !a4.call(r, r.previous) || Zc(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return Nu(d) ? (e.consume(d), o) : d === 64 ? (e.consume(d), s) : n(d);
  }
  function s(d) {
    return d === 46 ? e.check(s9, c, u)(d) : d === 45 || d === 95 || ht(d) ? (a = !0, e.consume(d), s) : c(d);
  }
  function u(d) {
    return e.consume(d), i = !0, s;
  }
  function c(d) {
    return a && i && wt(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function d9(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return l !== 87 && l !== 119 || !r4.call(r, r.previous) || Zc(r.events) ? n(l) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(o9, e.attempt(Qg, e.attempt(Jg, a), n), n)(l));
  }
  function a(l) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(l);
  }
}
function f9(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return l;
  function l(d) {
    return (d === 72 || d === 104) && i4.call(r, r.previous) && !Zc(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), e.consume(d), o) : n(d);
  }
  function o(d) {
    if (wt(d) && i.length < 5)
      return i += String.fromCodePoint(d), e.consume(d), o;
    if (d === 58) {
      const h = i.toLowerCase();
      if (h === "http" || h === "https")
        return e.consume(d), s;
    }
    return n(d);
  }
  function s(d) {
    return d === 47 ? (e.consume(d), a ? u : (a = !0, s)) : n(d);
  }
  function u(d) {
    return d === null || Ro(d) || Ce(d) || Xr(d) || ss(d) ? n(d) : e.attempt(Qg, e.attempt(Jg, c), n)(d);
  }
  function c(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function h9(e, t, n) {
  let r = 0;
  return i;
  function i(l) {
    return (l === 87 || l === 119) && r < 3 ? (r++, e.consume(l), i) : l === 46 && r === 3 ? (e.consume(l), a) : n(l);
  }
  function a(l) {
    return l === null ? n(l) : t(l);
  }
}
function p9(e, t, n) {
  let r, i, a;
  return l;
  function l(u) {
    return u === 46 || u === 95 ? e.check(e4, s, o)(u) : u === null || Ce(u) || Xr(u) || u !== 45 && ss(u) ? s(u) : (a = !0, e.consume(u), l);
  }
  function o(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), l;
  }
  function s(u) {
    return i || r || !a ? n(u) : t(u);
  }
}
function m9(e, t) {
  let n = 0, r = 0;
  return i;
  function i(l) {
    return l === 40 ? (n++, e.consume(l), i) : l === 41 && r < n ? a(l) : l === 33 || l === 34 || l === 38 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 60 || l === 63 || l === 93 || l === 95 || l === 126 ? e.check(e4, t, a)(l) : l === null || Ce(l) || Xr(l) ? t(l) : (e.consume(l), i);
  }
  function a(l) {
    return l === 41 && r++, e.consume(l), i;
  }
}
function g9(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), i) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Ce(o) || Xr(o) ? t(o) : n(o)
    );
  }
  function i(o) {
    return o === null || o === 40 || o === 91 || Ce(o) || Xr(o) ? t(o) : r(o);
  }
  function a(o) {
    return wt(o) ? l(o) : n(o);
  }
  function l(o) {
    return o === 59 ? (e.consume(o), r) : wt(o) ? (e.consume(o), l) : n(o);
  }
}
function v9(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return ht(a) ? n(a) : t(a);
  }
}
function r4(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Ce(e);
}
function i4(e) {
  return !wt(e);
}
function a4(e) {
  return !(e === 47 || Nu(e));
}
function Nu(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || ht(e);
}
function Zc(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const y9 = {
  tokenize: T9,
  partial: !0
};
function b9() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: E9,
        continuation: {
          tokenize: S9
        },
        exit: _9
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: k9
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: w9,
        resolveTo: x9
      }
    }
  };
}
function w9(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l;
  for (; i--; ) {
    const s = r.events[i][1];
    if (s.type === "labelImage") {
      l = s;
      break;
    }
    if (s.type === "gfmFootnoteCall" || s.type === "labelLink" || s.type === "label" || s.type === "image" || s.type === "link")
      break;
  }
  return o;
  function o(s) {
    if (!l || !l._balanced)
      return n(s);
    const u = mn(r.sliceSerialize({
      start: l.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !a.includes(u.slice(1)) ? n(s) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(s), e.exit("gfmFootnoteCallLabelMarker"), t(s));
  }
}
function x9(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, l = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function k9(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, l;
  return o;
  function o(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), s;
  }
  function s(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(d) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      d === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || Ce(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteCallString");
      return i.includes(mn(r.sliceSerialize(h))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return Ce(d) || (l = !0), a++, e.consume(d), d === 92 ? c : u;
  }
  function c(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), a++, u) : u(d);
  }
}
function E9(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, l = 0, o;
  return s;
  function s(g) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(g) {
    return g === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(g);
  }
  function c(g) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      g === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      g === null || g === 91 || Ce(g)
    )
      return n(g);
    if (g === 93) {
      e.exit("chunkString");
      const w = e.exit("gfmFootnoteDefinitionLabelString");
      return a = mn(r.sliceSerialize(w)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h;
    }
    return Ce(g) || (o = !0), l++, e.consume(g), g === 92 ? d : c;
  }
  function d(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), l++, c) : c(g);
  }
  function h(g) {
    return g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), i.includes(a) || i.push(a), ve(e, p, "gfmFootnoteDefinitionWhitespace")) : n(g);
  }
  function p(g) {
    return t(g);
  }
}
function S9(e, t, n) {
  return e.check(rl, t, e.attempt(y9, t, n));
}
function _9(e) {
  e.exit("gfmFootnoteDefinition");
}
function T9(e, t, n) {
  const r = this;
  return ve(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "gfmFootnoteDefinitionIndent" && l[2].sliceSerialize(l[1], !0).length === 4 ? t(a) : n(a);
  }
}
function N9(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(l, o) {
    let s = -1;
    for (; ++s < l.length; )
      if (l[s][0] === "enter" && l[s][1].type === "strikethroughSequenceTemporary" && l[s][1]._close) {
        let u = s;
        for (; u--; )
          if (l[u][0] === "exit" && l[u][1].type === "strikethroughSequenceTemporary" && l[u][1]._open && // If the sizes are the same:
          l[s][1].end.offset - l[s][1].start.offset === l[u][1].end.offset - l[u][1].start.offset) {
            l[s][1].type = "strikethroughSequence", l[u][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, l[u][1].start),
              end: Object.assign({}, l[s][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, l[u][1].end),
              end: Object.assign({}, l[s][1].start)
            }, h = [["enter", c, o], ["enter", l[u][1], o], ["exit", l[u][1], o], ["enter", d, o]], p = o.parser.constructs.insideSpan.null;
            p && Ht(h, h.length, 0, us(p, l.slice(u + 1, s), o)), Ht(h, h.length, 0, [["exit", d, o], ["enter", l[s][1], o], ["exit", l[s][1], o], ["exit", c, o]]), Ht(l, u - 1, s - u + 3, h), s = u + h.length - 2;
            break;
          }
      }
    for (s = -1; ++s < l.length; )
      l[s][1].type === "strikethroughSequenceTemporary" && (l[s][1].type = "data");
    return l;
  }
  function a(l, o, s) {
    const u = this.previous, c = this.events;
    let d = 0;
    return h;
    function h(g) {
      return u === 126 && c[c.length - 1][1].type !== "characterEscape" ? s(g) : (l.enter("strikethroughSequenceTemporary"), p(g));
    }
    function p(g) {
      const w = Fi(u);
      if (g === 126)
        return d > 1 ? s(g) : (l.consume(g), d++, p);
      if (d < 2 && !n) return s(g);
      const S = l.exit("strikethroughSequenceTemporary"), y = Fi(g);
      return S._open = !y || y === 2 && !!w, S._close = !w || w === 2 && !!y, o(g);
    }
  }
}
class A9 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    C9(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, l) {
      return a[0] - l[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function C9(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function M9(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function O9() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: R9,
        resolveAll: I9
      }
    }
  };
}
function R9(e, t, n) {
  const r = this;
  let i = 0, a = 0, l;
  return o;
  function o(O) {
    let V = r.events.length - 1;
    for (; V > -1; ) {
      const ie = r.events[V][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") V--;
      else break;
    }
    const K = V > -1 ? r.events[V][1].type : null, ae = K === "tableHead" || K === "tableRow" ? T : s;
    return ae === T && r.parser.lazy[r.now().line] ? n(O) : ae(O);
  }
  function s(O) {
    return e.enter("tableHead"), e.enter("tableRow"), u(O);
  }
  function u(O) {
    return O === 124 || (l = !0, a += 1), c(O);
  }
  function c(O) {
    return O === null ? n(O) : le(O) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), p) : n(O) : be(O) ? ve(e, c, "whitespace")(O) : (a += 1, l && (l = !1, i += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), l = !0, c) : (e.enter("data"), d(O)));
  }
  function d(O) {
    return O === null || O === 124 || Ce(O) ? (e.exit("data"), c(O)) : (e.consume(O), O === 92 ? h : d);
  }
  function h(O) {
    return O === 92 || O === 124 ? (e.consume(O), d) : d(O);
  }
  function p(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), l = !1, be(O) ? ve(e, g, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : g(O));
  }
  function g(O) {
    return O === 45 || O === 58 ? S(O) : O === 124 ? (l = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), w) : R(O);
  }
  function w(O) {
    return be(O) ? ve(e, S, "whitespace")(O) : S(O);
  }
  function S(O) {
    return O === 58 ? (a += 1, l = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), y) : O === 45 ? (a += 1, y(O)) : O === null || le(O) ? C(O) : R(O);
  }
  function y(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), v(O)) : R(O);
  }
  function v(O) {
    return O === 45 ? (e.consume(O), v) : O === 58 ? (l = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), x) : (e.exit("tableDelimiterFiller"), x(O));
  }
  function x(O) {
    return be(O) ? ve(e, C, "whitespace")(O) : C(O);
  }
  function C(O) {
    return O === 124 ? g(O) : O === null || le(O) ? !l || i !== a ? R(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : R(O);
  }
  function R(O) {
    return n(O);
  }
  function T(O) {
    return e.enter("tableRow"), z(O);
  }
  function z(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), z) : O === null || le(O) ? (e.exit("tableRow"), t(O)) : be(O) ? ve(e, z, "whitespace")(O) : (e.enter("data"), P(O));
  }
  function P(O) {
    return O === null || O === 124 || Ce(O) ? (e.exit("data"), z(O)) : (e.consume(O), O === 92 ? U : P);
  }
  function U(O) {
    return O === 92 || O === 124 ? (e.consume(O), P) : P(O);
  }
}
function I9(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], l = [0, 0, 0, 0], o = !1, s = 0, u, c, d;
  const h = new A9();
  for (; ++n < e.length; ) {
    const p = e[n], g = p[1];
    p[0] === "enter" ? g.type === "tableHead" ? (o = !1, s !== 0 && (R1(h, t, s, u, c), c = void 0, s = 0), u = {
      type: "table",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, h.add(n, 0, [["enter", u, t]])) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (r = !0, d = void 0, a = [0, 0, 0, 0], l = [0, n + 1, 0, 0], o && (o = !1, c = {
      type: "tableBody",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, h.add(n, 0, [["enter", c, t]])), i = g.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : i && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") ? (r = !1, l[2] === 0 && (a[1] !== 0 && (l[0] = l[1], d = Cl(h, t, a, i, void 0, d), a = [0, 0, 0, 0]), l[2] = n)) : g.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (l[0] = l[1], d = Cl(h, t, a, i, void 0, d)), a = l, l = [a[1], n, 0, 0])) : g.type === "tableHead" ? (o = !0, s = n) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (s = n, a[1] !== 0 ? (l[0] = l[1], d = Cl(h, t, a, i, n, d)) : l[1] !== 0 && (d = Cl(h, t, l, i, n, d)), i = 0) : i && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") && (l[3] = n);
  }
  for (s !== 0 && R1(h, t, s, u, c), h.consume(t.events), n = -1; ++n < t.events.length; ) {
    const p = t.events[n];
    p[0] === "enter" && p[1].type === "table" && (p[1]._align = M9(t.events, n));
  }
  return e;
}
function Cl(e, t, n, r, i, a) {
  const l = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, ui(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const s = ui(t.events, n[1]);
  if (a = {
    type: l,
    start: Object.assign({}, s),
    // Note: correct end is set later.
    end: Object.assign({}, s)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const u = ui(t.events, n[2]), c = ui(t.events, n[3]), d = {
      type: o,
      start: Object.assign({}, u),
      end: Object.assign({}, c)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const h = t.events[n[2]], p = t.events[n[3]];
      if (h[1].end = Object.assign({}, p[1].end), h[1].type = "chunkText", h[1].contentType = "text", n[3] > n[2] + 1) {
        const g = n[2] + 1, w = n[3] - n[2] - 1;
        e.add(g, w, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, ui(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function R1(e, t, n, r, i) {
  const a = [], l = ui(t.events, n);
  i && (i.end = Object.assign({}, l), a.push(["exit", i, t])), r.end = Object.assign({}, l), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function ui(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const D9 = {
  name: "tasklistCheck",
  tokenize: L9
};
function z9() {
  return {
    text: {
      91: D9
    }
  };
}
function L9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(s) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(s), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(s) {
    return Ce(s) ? (e.enter("taskListCheckValueUnchecked"), e.consume(s), e.exit("taskListCheckValueUnchecked"), l) : s === 88 || s === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(s), e.exit("taskListCheckValueChecked"), l) : n(s);
  }
  function l(s) {
    return s === 93 ? (e.enter("taskListCheckMarker"), e.consume(s), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(s);
  }
  function o(s) {
    return le(s) ? t(s) : be(s) ? e.check({
      tokenize: P9
    }, t, n)(s) : n(s);
  }
}
function P9(e, t, n) {
  return ve(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function B9(e) {
  return mg([
    u9(),
    b9(),
    N9(e),
    O9(),
    z9()
  ]);
}
const F9 = {};
function U9(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || F9, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), l = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(B9(n)), a.push(a9()), l.push(l9(n));
}
function $9() {
  return {
    enter: {
      mathFlow: e,
      mathFlowFenceMeta: t,
      mathText: a
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: n,
      mathFlowValue: o,
      mathText: l,
      mathTextData: o
    }
  };
  function e(s) {
    const u = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [u] }
      },
      s
    );
  }
  function t() {
    this.buffer();
  }
  function n() {
    const s = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, u.meta = s;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(s) {
    const u = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), c = this.stack[this.stack.length - 1];
    c.type, this.exit(s), c.value = u;
    const d = (
      /** @type {HastElement} */
      c.data.hChildren[0]
    );
    d.type, d.tagName, d.children.push({ type: "text", value: u }), this.data.mathFlowInside = void 0;
  }
  function a(s) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      s
    ), this.buffer();
  }
  function l(s) {
    const u = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, this.exit(s), c.value = u, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    c.data.hChildren.push({ type: "text", value: u });
  }
  function o(s) {
    this.config.enter.data.call(this, s), this.config.exit.data.call(this, s);
  }
}
function H9(e) {
  let t = (e || {}).singleDollarTextMath;
  return t == null && (t = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: t ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: n, inlineMath: r }
  };
  function n(a, l, o, s) {
    const u = a.value || "", c = o.createTracker(s), d = "$".repeat(Math.max(Ug(u, "$") + 1, 2)), h = o.enter("mathFlow");
    let p = c.move(d);
    if (a.meta) {
      const g = o.enter("mathFlowMeta");
      p += c.move(
        o.safe(a.meta, {
          after: `
`,
          before: p,
          encode: ["$"],
          ...c.current()
        })
      ), g();
    }
    return p += c.move(`
`), u && (p += c.move(u + `
`)), p += c.move(d), h(), p;
  }
  function r(a, l, o) {
    let s = a.value || "", u = 1;
    for (t || u++; new RegExp("(^|[^$])" + "\\$".repeat(u) + "([^$]|$)").test(s); )
      u++;
    const c = "$".repeat(u);
    // Contains non-space.
    /[^ \r\n]/.test(s) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(s) && /[ \r\n]$/.test(s) || // Starts or ends with dollar.
    /^\$|\$$/.test(s)) && (s = " " + s + " ");
    let d = -1;
    for (; ++d < o.unsafe.length; ) {
      const h = o.unsafe[d];
      if (!h.atBreak) continue;
      const p = o.compilePattern(h);
      let g;
      for (; g = p.exec(s); ) {
        let w = g.index;
        s.codePointAt(w) === 10 && s.codePointAt(w - 1) === 13 && w--, s = s.slice(0, w) + " " + s.slice(g.index + 1);
      }
    }
    return c + s + c;
  }
  function i() {
    return "$";
  }
}
const q9 = {
  tokenize: G9,
  concrete: !0,
  name: "mathFlow"
}, I1 = {
  tokenize: V9,
  partial: !0
};
function G9(e, t, n) {
  const r = this, i = r.events[r.events.length - 1], a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let l = 0;
  return o;
  function o(v) {
    return e.enter("mathFlow"), e.enter("mathFlowFence"), e.enter("mathFlowFenceSequence"), s(v);
  }
  function s(v) {
    return v === 36 ? (e.consume(v), l++, s) : l < 2 ? n(v) : (e.exit("mathFlowFenceSequence"), ve(e, u, "whitespace")(v));
  }
  function u(v) {
    return v === null || le(v) ? d(v) : (e.enter("mathFlowFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), c(v));
  }
  function c(v) {
    return v === null || le(v) ? (e.exit("chunkString"), e.exit("mathFlowFenceMeta"), d(v)) : v === 36 ? n(v) : (e.consume(v), c);
  }
  function d(v) {
    return e.exit("mathFlowFence"), r.interrupt ? t(v) : e.attempt(I1, h, S)(v);
  }
  function h(v) {
    return e.attempt({
      tokenize: y,
      partial: !0
    }, S, p)(v);
  }
  function p(v) {
    return (a ? ve(e, g, "linePrefix", a + 1) : g)(v);
  }
  function g(v) {
    return v === null ? S(v) : le(v) ? e.attempt(I1, h, S)(v) : (e.enter("mathFlowValue"), w(v));
  }
  function w(v) {
    return v === null || le(v) ? (e.exit("mathFlowValue"), g(v)) : (e.consume(v), w);
  }
  function S(v) {
    return e.exit("mathFlow"), t(v);
  }
  function y(v, x, C) {
    let R = 0;
    return ve(v, T, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function T(U) {
      return v.enter("mathFlowFence"), v.enter("mathFlowFenceSequence"), z(U);
    }
    function z(U) {
      return U === 36 ? (R++, v.consume(U), z) : R < l ? C(U) : (v.exit("mathFlowFenceSequence"), ve(v, P, "whitespace")(U));
    }
    function P(U) {
      return U === null || le(U) ? (v.exit("mathFlowFence"), x(U)) : C(U);
    }
  }
}
function V9(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return l === null ? t(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a);
  }
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
function W9(e) {
  let n = (e || {}).singleDollarTextMath;
  return n == null && (n = !0), {
    tokenize: r,
    resolve: K9,
    previous: Y9,
    name: "mathText"
  };
  function r(i, a, l) {
    let o = 0, s, u;
    return c;
    function c(w) {
      return i.enter("mathText"), i.enter("mathTextSequence"), d(w);
    }
    function d(w) {
      return w === 36 ? (i.consume(w), o++, d) : o < 2 && !n ? l(w) : (i.exit("mathTextSequence"), h(w));
    }
    function h(w) {
      return w === null ? l(w) : w === 36 ? (u = i.enter("mathTextSequence"), s = 0, g(w)) : w === 32 ? (i.enter("space"), i.consume(w), i.exit("space"), h) : le(w) ? (i.enter("lineEnding"), i.consume(w), i.exit("lineEnding"), h) : (i.enter("mathTextData"), p(w));
    }
    function p(w) {
      return w === null || w === 32 || w === 36 || le(w) ? (i.exit("mathTextData"), h(w)) : (i.consume(w), p);
    }
    function g(w) {
      return w === 36 ? (i.consume(w), s++, g) : s === o ? (i.exit("mathTextSequence"), i.exit("mathText"), a(w)) : (u.type = "mathTextData", p(w));
    }
  }
}
function K9(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "mathTextData") {
        e[t][1].type = "mathTextPadding", e[n][1].type = "mathTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "mathTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function Y9(e) {
  return e !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function j9(e) {
  return {
    flow: {
      36: q9
    },
    text: {
      36: W9(e)
    }
  };
}
class Ft {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(t, n, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = n, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(t, n) {
    return n ? !t || !t.loc || !n.loc || t.loc.lexer !== n.loc.lexer ? null : new Ft(t.loc.lexer, t.loc.start, n.loc.end) : t && t.loc;
  }
}
class en {
  // don't expand the token
  // used in \noexpand
  constructor(t, n) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = n;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(t, n) {
    return new en(n, Ft.range(this, t));
  }
}
class Y {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(t, n) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + t, i, a, l = n && n.loc;
    if (l && l.start <= l.end) {
      var o = l.lexer.input;
      i = l.start, a = l.end, i === o.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var s = o.slice(i, a).replace(/[^]/g, "$&"), u;
      i > 15 ? u = "" + o.slice(i - 15, i) : u = o.slice(0, i);
      var c;
      a + 15 < o.length ? c = o.slice(a, a + 15) + "" : c = o.slice(a), r += u + s + c;
    }
    var d = new Error(r);
    return d.name = "ParseError", d.__proto__ = Y.prototype, d.position = i, i != null && a != null && (d.length = a - i), d.rawMessage = t, d;
  }
}
Y.prototype.__proto__ = Error.prototype;
var X9 = function(t, n) {
  return t.indexOf(n) !== -1;
}, Z9 = function(t, n) {
  return t === void 0 ? n : t;
}, Q9 = /([A-Z])/g, J9 = function(t) {
  return t.replace(Q9, "-$1").toLowerCase();
}, ew = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, tw = /[&><"']/g;
function nw(e) {
  return String(e).replace(tw, (t) => ew[t]);
}
var l4 = function e(t) {
  return t.type === "ordgroup" || t.type === "color" ? t.body.length === 1 ? e(t.body[0]) : t : t.type === "font" ? e(t.body) : t;
}, rw = function(t) {
  var n = l4(t);
  return n.type === "mathord" || n.type === "textord" || n.type === "atom";
}, iw = function(t) {
  if (!t)
    throw new Error("Expected non-null, but got " + String(t));
  return t;
}, aw = function(t) {
  var n = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(t);
  return n ? n[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(n[1]) ? null : n[1].toLowerCase() : "_relative";
}, se = {
  contains: X9,
  deflt: Z9,
  escape: nw,
  hyphenate: J9,
  getBaseElem: l4,
  isCharacterBox: rw,
  protocolFromUrl: aw
}, ao = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (e) => "#" + e
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (e, t) => (t.push(e), t)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (e) => Math.max(0, e),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (e) => Math.max(0, e),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (e) => Math.max(0, e),
    cli: "-e, --max-expand <n>",
    cliProcessor: (e) => e === "Infinity" ? 1 / 0 : parseInt(e)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function lw(e) {
  if (e.default)
    return e.default;
  var t = e.type, n = Array.isArray(t) ? t[0] : t;
  if (typeof n != "string")
    return n.enum[0];
  switch (n) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Qc {
  constructor(t) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, t = t || {};
    for (var n in ao)
      if (ao.hasOwnProperty(n)) {
        var r = ao[n];
        this[n] = t[n] !== void 0 ? r.processor ? r.processor(t[n]) : t[n] : lw(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(t, n, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(t, n, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new Y("LaTeX-incompatible input and strict mode is set to 'error': " + (n + " [" + t + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (n + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + n + " [" + t + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(t, n, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(t, n, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (n + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + n + " [" + t + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(t) {
    if (t.url && !t.protocol) {
      var n = se.protocolFromUrl(t.url);
      if (n == null)
        return !1;
      t.protocol = n;
    }
    var r = typeof this.trust == "function" ? this.trust(t) : this.trust;
    return !!r;
  }
}
class nr {
  constructor(t, n, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = n, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return Sn[ow[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return Sn[sw[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return Sn[uw[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return Sn[cw[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return Sn[dw[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return Sn[fw[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var Jc = 0, Po = 1, Oi = 2, Hn = 3, Ka = 4, Qt = 5, Ui = 6, kt = 7, Sn = [new nr(Jc, 0, !1), new nr(Po, 0, !0), new nr(Oi, 1, !1), new nr(Hn, 1, !0), new nr(Ka, 2, !1), new nr(Qt, 2, !0), new nr(Ui, 3, !1), new nr(kt, 3, !0)], ow = [Ka, Qt, Ka, Qt, Ui, kt, Ui, kt], sw = [Qt, Qt, Qt, Qt, kt, kt, kt, kt], uw = [Oi, Hn, Ka, Qt, Ui, kt, Ui, kt], cw = [Hn, Hn, Qt, Qt, kt, kt, kt, kt], dw = [Po, Po, Hn, Hn, Qt, Qt, kt, kt], fw = [Jc, Po, Oi, Hn, Oi, Hn, Oi, Hn], ce = {
  DISPLAY: Sn[Jc],
  TEXT: Sn[Oi],
  SCRIPT: Sn[Ka],
  SCRIPTSCRIPT: Sn[Ui]
}, Au = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function hw(e) {
  for (var t = 0; t < Au.length; t++)
    for (var n = Au[t], r = 0; r < n.blocks.length; r++) {
      var i = n.blocks[r];
      if (e >= i[0] && e <= i[1])
        return n.name;
    }
  return null;
}
var lo = [];
Au.forEach((e) => e.blocks.forEach((t) => lo.push(...t)));
function o4(e) {
  for (var t = 0; t < lo.length; t += 2)
    if (e >= lo[t] && e <= lo[t + 1])
      return !0;
  return !1;
}
var oi = 80, pw = function(t, n) {
  return "M95," + (622 + t + n) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + t / 2.075 + " -" + t + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + t) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, mw = function(t, n) {
  return "M263," + (601 + t + n) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + t / 2.084 + " -" + t + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + t) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, gw = function(t, n) {
  return "M983 " + (10 + t + n) + `
l` + t / 3.13 + " -" + t + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + t) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, vw = function(t, n) {
  return "M424," + (2398 + t + n) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + t / 4.223 + " -" + t + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + t) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + t) + " " + n + `
h400000v` + (40 + t) + "h-400000z";
}, yw = function(t, n) {
  return "M473," + (2713 + t + n) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + t / 5.298 + " -" + t + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + t) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "H1017.7z";
}, bw = function(t) {
  var n = t / 2;
  return "M400000 " + t + " H0 L" + n + " 0 l65 45 L145 " + (t - 80) + " H400000z";
}, ww = function(t, n, r) {
  var i = r - 54 - n - t;
  return "M702 " + (t + n) + "H400000" + (40 + t) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + n + "H400000v" + (40 + t) + "H742z";
}, xw = function(t, n, r) {
  n = 1e3 * n;
  var i = "";
  switch (t) {
    case "sqrtMain":
      i = pw(n, oi);
      break;
    case "sqrtSize1":
      i = mw(n, oi);
      break;
    case "sqrtSize2":
      i = gw(n, oi);
      break;
    case "sqrtSize3":
      i = vw(n, oi);
      break;
    case "sqrtSize4":
      i = yw(n, oi);
      break;
    case "sqrtTall":
      i = ww(n, oi, r);
  }
  return i;
}, kw = function(t, n) {
  switch (t) {
    case "":
      return "M291 0 H417 V" + n + " H291z M291 0 H417 V" + n + " H291z";
    case "":
      return "M145 0 H188 V" + n + " H145z M145 0 H188 V" + n + " H145z";
    case "":
      return "M145 0 H188 V" + n + " H145z M145 0 H188 V" + n + " H145z" + ("M367 0 H410 V" + n + " H367z M367 0 H410 V" + n + " H367z");
    case "":
      return "M457 0 H583 V" + n + " H457z M457 0 H583 V" + n + " H457z";
    case "":
      return "M319 0 H403 V" + n + " H319z M319 0 H403 V" + n + " H319z";
    case "":
      return "M263 0 H347 V" + n + " H263z M263 0 H347 V" + n + " H263z";
    case "":
      return "M384 0 H504 V" + n + " H384z M384 0 H504 V" + n + " H384z";
    case "":
      return "M312 0 H355 V" + n + " H312z M312 0 H355 V" + n + " H312z";
    case "":
      return "M257 0 H300 V" + n + " H257z M257 0 H300 V" + n + " H257z" + ("M478 0 H521 V" + n + " H478z M478 0 H521 V" + n + " H478z");
    default:
      return "";
  }
}, D1 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, Ew = function(t, n) {
  switch (t) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + n + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + n + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + n + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + n + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + n + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + n + ` v585 h43z
M367 15 v585 v` + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + n + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + n + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + n + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + n + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + n + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + n + ` v602 h84z
M403 1759 V0 H319 V1759 v` + n + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + n + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + n + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (n + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (n + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (n + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (n + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class ll {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(t) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = t, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(t) {
    return se.contains(this.classes, t);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var t = document.createDocumentFragment(), n = 0; n < this.children.length; n++)
      t.appendChild(this.children[n].toNode());
    return t;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var t = "", n = 0; n < this.children.length; n++)
      t += this.children[n].toMarkup();
    return t;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var t = (n) => n.toText();
    return this.children.map(t).join("");
  }
}
var Tn = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, Ml = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, z1 = {
  // Latin-1
  : "A",
  : "D",
  : "o",
  : "a",
  : "d",
  : "o",
  // Cyrillic
  : "A",
  : "B",
  : "B",
  : "F",
  : "A",
  : "E",
  : "K",
  : "3",
  : "N",
  : "N",
  : "K",
  : "N",
  : "M",
  : "H",
  : "O",
  : "N",
  : "P",
  : "C",
  : "T",
  : "y",
  : "O",
  : "X",
  : "U",
  : "h",
  : "W",
  : "W",
  : "B",
  : "X",
  : "B",
  : "3",
  : "X",
  : "R",
  : "a",
  : "b",
  : "a",
  : "r",
  : "y",
  : "e",
  : "m",
  : "e",
  : "n",
  : "n",
  : "n",
  : "n",
  : "m",
  : "n",
  : "o",
  : "n",
  : "p",
  : "c",
  : "o",
  : "y",
  : "b",
  : "x",
  : "n",
  : "n",
  : "w",
  : "w",
  : "a",
  : "m",
  : "a",
  : "e",
  : "m",
  : "r"
};
function Sw(e, t) {
  Tn[e] = t;
}
function ed(e, t, n) {
  if (!Tn[t])
    throw new Error("Font metrics not found for font: " + t + ".");
  var r = e.charCodeAt(0), i = Tn[t][r];
  if (!i && e[0] in z1 && (r = z1[e[0]].charCodeAt(0), i = Tn[t][r]), !i && n === "text" && o4(r) && (i = Tn[t][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var u0 = {};
function _w(e) {
  var t;
  if (e >= 5 ? t = 0 : e >= 3 ? t = 1 : t = 2, !u0[t]) {
    var n = u0[t] = {
      cssEmPerMu: Ml.quad[t] / 18
    };
    for (var r in Ml)
      Ml.hasOwnProperty(r) && (n[r] = Ml[r][t]);
  }
  return u0[t];
}
var Tw = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], L1 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], P1 = function(t, n) {
  return n.size < 2 ? t : Tw[t - 1][n.size - 1];
};
class Bn {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(t) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || Bn.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = L1[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(t) {
    var n = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in t)
      t.hasOwnProperty(r) && (n[r] = t[r]);
    return new Bn(n);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(t) {
    return this.style === t ? this : this.extend({
      style: t,
      size: P1(this.textSize, t)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(t) {
    return this.size === t && this.textSize === t ? this : this.extend({
      style: this.style.text(),
      size: t,
      textSize: t,
      sizeMultiplier: L1[t - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(t) {
    t = t || this.style.text();
    var n = P1(Bn.BASESIZE, t);
    return this.size === n && this.textSize === Bn.BASESIZE && this.style === t ? this : this.extend({
      style: t,
      size: n
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var t;
    switch (this.style.id) {
      case 4:
      case 5:
        t = 3;
        break;
      case 6:
      case 7:
        t = 1;
        break;
      default:
        t = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: t
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(t) {
    return this.extend({
      color: t
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(t) {
    return this.extend({
      font: t
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(t) {
    return this.extend({
      fontFamily: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(t) {
    return this.extend({
      fontWeight: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(t) {
    return this.extend({
      fontShape: t,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(t) {
    return t.size !== this.size ? ["sizing", "reset-size" + t.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Bn.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Bn.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = _w(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Bn.BASESIZE = 6;
var Cu = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, Nw = {
  ex: !0,
  em: !0,
  mu: !0
}, s4 = function(t) {
  return typeof t != "string" && (t = t.unit), t in Cu || t in Nw || t === "ex";
}, Ue = function(t, n) {
  var r;
  if (t.unit in Cu)
    r = Cu[t.unit] / n.fontMetrics().ptPerEm / n.sizeMultiplier;
  else if (t.unit === "mu")
    r = n.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (n.style.isTight() ? i = n.havingStyle(n.style.text()) : i = n, t.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (t.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new Y("Invalid unit: '" + t.unit + "'");
    i !== n && (r *= i.sizeMultiplier / n.sizeMultiplier);
  }
  return Math.min(t.number * r, n.maxSize);
}, X = function(t) {
  return +t.toFixed(4) + "em";
}, kr = function(t) {
  return t.filter((n) => n).join(" ");
}, u4 = function(t, n, r) {
  if (this.classes = t || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, n) {
    n.style.isTight() && this.classes.push("mtight");
    var i = n.getColor();
    i && (this.style.color = i);
  }
}, c4 = function(t) {
  var n = document.createElement(t);
  n.className = kr(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (n.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && n.setAttribute(i, this.attributes[i]);
  for (var a = 0; a < this.children.length; a++)
    n.appendChild(this.children[a].toNode());
  return n;
}, d4 = function(t) {
  var n = "<" + t;
  this.classes.length && (n += ' class="' + se.escape(kr(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += se.hyphenate(i) + ":" + this.style[i] + ";");
  r && (n += ' style="' + se.escape(r) + '"');
  for (var a in this.attributes)
    this.attributes.hasOwnProperty(a) && (n += " " + a + '="' + se.escape(this.attributes[a]) + '"');
  n += ">";
  for (var l = 0; l < this.children.length; l++)
    n += this.children[l].toMarkup();
  return n += "</" + t + ">", n;
};
class ol {
  constructor(t, n, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, u4.call(this, t, r, i), this.children = n || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  hasClass(t) {
    return se.contains(this.classes, t);
  }
  toNode() {
    return c4.call(this, "span");
  }
  toMarkup() {
    return d4.call(this, "span");
  }
}
class td {
  constructor(t, n, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, u4.call(this, n, i), this.children = r || [], this.setAttribute("href", t);
  }
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  hasClass(t) {
    return se.contains(this.classes, t);
  }
  toNode() {
    return c4.call(this, "a");
  }
  toMarkup() {
    return d4.call(this, "a");
  }
}
class Aw {
  constructor(t, n, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = n, this.src = t, this.classes = ["mord"], this.style = r;
  }
  hasClass(t) {
    return se.contains(this.classes, t);
  }
  toNode() {
    var t = document.createElement("img");
    t.src = this.src, t.alt = this.alt, t.className = "mord";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (t.style[n] = this.style[n]);
    return t;
  }
  toMarkup() {
    var t = '<img src="' + se.escape(this.src) + '"' + (' alt="' + se.escape(this.alt) + '"'), n = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (n += se.hyphenate(r) + ":" + this.style[r] + ";");
    return n && (t += ' style="' + se.escape(n) + '"'), t += "'/>", t;
  }
}
var Cw = {
  : "",
  : "",
  : "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  : ""
};
class rn {
  constructor(t, n, r, i, a, l, o, s) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = n || 0, this.depth = r || 0, this.italic = i || 0, this.skew = a || 0, this.width = l || 0, this.classes = o || [], this.style = s || {}, this.maxFontSize = 0;
    var u = hw(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[]/.test(this.text) && (this.text = Cw[this.text]);
  }
  hasClass(t) {
    return se.contains(this.classes, t);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var t = document.createTextNode(this.text), n = null;
    this.italic > 0 && (n = document.createElement("span"), n.style.marginRight = X(this.italic)), this.classes.length > 0 && (n = n || document.createElement("span"), n.className = kr(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (n = n || document.createElement("span"), n.style[r] = this.style[r]);
    return n ? (n.appendChild(t), n) : t;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var t = !1, n = "<span";
    this.classes.length && (t = !0, n += ' class="', n += se.escape(kr(this.classes)), n += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += se.hyphenate(i) + ":" + this.style[i] + ";");
    r && (t = !0, n += ' style="' + se.escape(r) + '"');
    var a = se.escape(this.text);
    return t ? (n += ">", n += a, n += "</span>", n) : a;
  }
}
class Yn {
  constructor(t, n) {
    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = n || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && n.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      n.appendChild(this.children[i].toNode());
    return n;
  }
  toMarkup() {
    var t = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="' + se.escape(this.attributes[n]) + '"');
    t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</svg>", t;
  }
}
class Er {
  constructor(t, n) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = n;
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "path");
    return this.alternate ? n.setAttribute("d", this.alternate) : n.setAttribute("d", D1[this.pathName]), n;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + se.escape(this.alternate) + '"/>' : '<path d="' + se.escape(D1[this.pathName]) + '"/>';
  }
}
class Mu {
  constructor(t) {
    this.attributes = void 0, this.attributes = t || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && n.setAttribute(r, this.attributes[r]);
    return n;
  }
  toMarkup() {
    var t = "<line";
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="' + se.escape(this.attributes[n]) + '"');
    return t += "/>", t;
  }
}
function B1(e) {
  if (e instanceof rn)
    return e;
  throw new Error("Expected symbolNode but got " + String(e) + ".");
}
function Mw(e) {
  if (e instanceof ol)
    return e;
  throw new Error("Expected span<HtmlDomNode> but got " + String(e) + ".");
}
var Ow = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Rw = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Ie = {
  math: {},
  text: {}
};
function f(e, t, n, r, i, a) {
  Ie[e][i] = {
    font: t,
    group: n,
    replace: r
  }, a && r && (Ie[e][r] = Ie[e][i]);
}
var m = "math", H = "text", b = "main", _ = "ams", Pe = "accent-token", te = "bin", Tt = "close", Ki = "inner", ue = "mathord", Qe = "op-token", Wt = "open", hs = "punct", N = "rel", Jn = "spacing", M = "textord";
f(m, b, N, "", "\\equiv", !0);
f(m, b, N, "", "\\prec", !0);
f(m, b, N, "", "\\succ", !0);
f(m, b, N, "", "\\sim", !0);
f(m, b, N, "", "\\perp");
f(m, b, N, "", "\\preceq", !0);
f(m, b, N, "", "\\succeq", !0);
f(m, b, N, "", "\\simeq", !0);
f(m, b, N, "", "\\mid", !0);
f(m, b, N, "", "\\ll", !0);
f(m, b, N, "", "\\gg", !0);
f(m, b, N, "", "\\asymp", !0);
f(m, b, N, "", "\\parallel");
f(m, b, N, "", "\\bowtie", !0);
f(m, b, N, "", "\\smile", !0);
f(m, b, N, "", "\\sqsubseteq", !0);
f(m, b, N, "", "\\sqsupseteq", !0);
f(m, b, N, "", "\\doteq", !0);
f(m, b, N, "", "\\frown", !0);
f(m, b, N, "", "\\ni", !0);
f(m, b, N, "", "\\propto", !0);
f(m, b, N, "", "\\vdash", !0);
f(m, b, N, "", "\\dashv", !0);
f(m, b, N, "", "\\owns");
f(m, b, hs, ".", "\\ldotp");
f(m, b, hs, "", "\\cdotp");
f(m, b, M, "#", "\\#");
f(H, b, M, "#", "\\#");
f(m, b, M, "&", "\\&");
f(H, b, M, "&", "\\&");
f(m, b, M, "", "\\aleph", !0);
f(m, b, M, "", "\\forall", !0);
f(m, b, M, "", "\\hbar", !0);
f(m, b, M, "", "\\exists", !0);
f(m, b, M, "", "\\nabla", !0);
f(m, b, M, "", "\\flat", !0);
f(m, b, M, "", "\\ell", !0);
f(m, b, M, "", "\\natural", !0);
f(m, b, M, "", "\\clubsuit", !0);
f(m, b, M, "", "\\wp", !0);
f(m, b, M, "", "\\sharp", !0);
f(m, b, M, "", "\\diamondsuit", !0);
f(m, b, M, "", "\\Re", !0);
f(m, b, M, "", "\\heartsuit", !0);
f(m, b, M, "", "\\Im", !0);
f(m, b, M, "", "\\spadesuit", !0);
f(m, b, M, "", "\\S", !0);
f(H, b, M, "", "\\S");
f(m, b, M, "", "\\P", !0);
f(H, b, M, "", "\\P");
f(m, b, M, "", "\\dag");
f(H, b, M, "", "\\dag");
f(H, b, M, "", "\\textdagger");
f(m, b, M, "", "\\ddag");
f(H, b, M, "", "\\ddag");
f(H, b, M, "", "\\textdaggerdbl");
f(m, b, Tt, "", "\\rmoustache", !0);
f(m, b, Wt, "", "\\lmoustache", !0);
f(m, b, Tt, "", "\\rgroup", !0);
f(m, b, Wt, "", "\\lgroup", !0);
f(m, b, te, "", "\\mp", !0);
f(m, b, te, "", "\\ominus", !0);
f(m, b, te, "", "\\uplus", !0);
f(m, b, te, "", "\\sqcap", !0);
f(m, b, te, "", "\\ast");
f(m, b, te, "", "\\sqcup", !0);
f(m, b, te, "", "\\bigcirc", !0);
f(m, b, te, "", "\\bullet", !0);
f(m, b, te, "", "\\ddagger");
f(m, b, te, "", "\\wr", !0);
f(m, b, te, "", "\\amalg");
f(m, b, te, "&", "\\And");
f(m, b, N, "", "\\longleftarrow", !0);
f(m, b, N, "", "\\Leftarrow", !0);
f(m, b, N, "", "\\Longleftarrow", !0);
f(m, b, N, "", "\\longrightarrow", !0);
f(m, b, N, "", "\\Rightarrow", !0);
f(m, b, N, "", "\\Longrightarrow", !0);
f(m, b, N, "", "\\leftrightarrow", !0);
f(m, b, N, "", "\\longleftrightarrow", !0);
f(m, b, N, "", "\\Leftrightarrow", !0);
f(m, b, N, "", "\\Longleftrightarrow", !0);
f(m, b, N, "", "\\mapsto", !0);
f(m, b, N, "", "\\longmapsto", !0);
f(m, b, N, "", "\\nearrow", !0);
f(m, b, N, "", "\\hookleftarrow", !0);
f(m, b, N, "", "\\hookrightarrow", !0);
f(m, b, N, "", "\\searrow", !0);
f(m, b, N, "", "\\leftharpoonup", !0);
f(m, b, N, "", "\\rightharpoonup", !0);
f(m, b, N, "", "\\swarrow", !0);
f(m, b, N, "", "\\leftharpoondown", !0);
f(m, b, N, "", "\\rightharpoondown", !0);
f(m, b, N, "", "\\nwarrow", !0);
f(m, b, N, "", "\\rightleftharpoons", !0);
f(m, _, N, "", "\\nless", !0);
f(m, _, N, "", "\\@nleqslant");
f(m, _, N, "", "\\@nleqq");
f(m, _, N, "", "\\lneq", !0);
f(m, _, N, "", "\\lneqq", !0);
f(m, _, N, "", "\\@lvertneqq");
f(m, _, N, "", "\\lnsim", !0);
f(m, _, N, "", "\\lnapprox", !0);
f(m, _, N, "", "\\nprec", !0);
f(m, _, N, "", "\\npreceq", !0);
f(m, _, N, "", "\\precnsim", !0);
f(m, _, N, "", "\\precnapprox", !0);
f(m, _, N, "", "\\nsim", !0);
f(m, _, N, "", "\\@nshortmid");
f(m, _, N, "", "\\nmid", !0);
f(m, _, N, "", "\\nvdash", !0);
f(m, _, N, "", "\\nvDash", !0);
f(m, _, N, "", "\\ntriangleleft");
f(m, _, N, "", "\\ntrianglelefteq", !0);
f(m, _, N, "", "\\subsetneq", !0);
f(m, _, N, "", "\\@varsubsetneq");
f(m, _, N, "", "\\subsetneqq", !0);
f(m, _, N, "", "\\@varsubsetneqq");
f(m, _, N, "", "\\ngtr", !0);
f(m, _, N, "", "\\@ngeqslant");
f(m, _, N, "", "\\@ngeqq");
f(m, _, N, "", "\\gneq", !0);
f(m, _, N, "", "\\gneqq", !0);
f(m, _, N, "", "\\@gvertneqq");
f(m, _, N, "", "\\gnsim", !0);
f(m, _, N, "", "\\gnapprox", !0);
f(m, _, N, "", "\\nsucc", !0);
f(m, _, N, "", "\\nsucceq", !0);
f(m, _, N, "", "\\succnsim", !0);
f(m, _, N, "", "\\succnapprox", !0);
f(m, _, N, "", "\\ncong", !0);
f(m, _, N, "", "\\@nshortparallel");
f(m, _, N, "", "\\nparallel", !0);
f(m, _, N, "", "\\nVDash", !0);
f(m, _, N, "", "\\ntriangleright");
f(m, _, N, "", "\\ntrianglerighteq", !0);
f(m, _, N, "", "\\@nsupseteqq");
f(m, _, N, "", "\\supsetneq", !0);
f(m, _, N, "", "\\@varsupsetneq");
f(m, _, N, "", "\\supsetneqq", !0);
f(m, _, N, "", "\\@varsupsetneqq");
f(m, _, N, "", "\\nVdash", !0);
f(m, _, N, "", "\\precneqq", !0);
f(m, _, N, "", "\\succneqq", !0);
f(m, _, N, "", "\\@nsubseteqq");
f(m, _, te, "", "\\unlhd");
f(m, _, te, "", "\\unrhd");
f(m, _, N, "", "\\nleftarrow", !0);
f(m, _, N, "", "\\nrightarrow", !0);
f(m, _, N, "", "\\nLeftarrow", !0);
f(m, _, N, "", "\\nRightarrow", !0);
f(m, _, N, "", "\\nleftrightarrow", !0);
f(m, _, N, "", "\\nLeftrightarrow", !0);
f(m, _, N, "", "\\vartriangle");
f(m, _, M, "", "\\hslash");
f(m, _, M, "", "\\triangledown");
f(m, _, M, "", "\\lozenge");
f(m, _, M, "", "\\circledS");
f(m, _, M, "", "\\circledR");
f(H, _, M, "", "\\circledR");
f(m, _, M, "", "\\measuredangle", !0);
f(m, _, M, "", "\\nexists");
f(m, _, M, "", "\\mho");
f(m, _, M, "", "\\Finv", !0);
f(m, _, M, "", "\\Game", !0);
f(m, _, M, "", "\\backprime");
f(m, _, M, "", "\\blacktriangle");
f(m, _, M, "", "\\blacktriangledown");
f(m, _, M, "", "\\blacksquare");
f(m, _, M, "", "\\blacklozenge");
f(m, _, M, "", "\\bigstar");
f(m, _, M, "", "\\sphericalangle", !0);
f(m, _, M, "", "\\complement", !0);
f(m, _, M, "", "\\eth", !0);
f(H, b, M, "", "");
f(m, _, M, "", "\\diagup");
f(m, _, M, "", "\\diagdown");
f(m, _, M, "", "\\square");
f(m, _, M, "", "\\Box");
f(m, _, M, "", "\\Diamond");
f(m, _, M, "", "\\yen", !0);
f(H, _, M, "", "\\yen", !0);
f(m, _, M, "", "\\checkmark", !0);
f(H, _, M, "", "\\checkmark");
f(m, _, M, "", "\\beth", !0);
f(m, _, M, "", "\\daleth", !0);
f(m, _, M, "", "\\gimel", !0);
f(m, _, M, "", "\\digamma", !0);
f(m, _, M, "", "\\varkappa");
f(m, _, Wt, "", "\\@ulcorner", !0);
f(m, _, Tt, "", "\\@urcorner", !0);
f(m, _, Wt, "", "\\@llcorner", !0);
f(m, _, Tt, "", "\\@lrcorner", !0);
f(m, _, N, "", "\\leqq", !0);
f(m, _, N, "", "\\leqslant", !0);
f(m, _, N, "", "\\eqslantless", !0);
f(m, _, N, "", "\\lesssim", !0);
f(m, _, N, "", "\\lessapprox", !0);
f(m, _, N, "", "\\approxeq", !0);
f(m, _, te, "", "\\lessdot");
f(m, _, N, "", "\\lll", !0);
f(m, _, N, "", "\\lessgtr", !0);
f(m, _, N, "", "\\lesseqgtr", !0);
f(m, _, N, "", "\\lesseqqgtr", !0);
f(m, _, N, "", "\\doteqdot");
f(m, _, N, "", "\\risingdotseq", !0);
f(m, _, N, "", "\\fallingdotseq", !0);
f(m, _, N, "", "\\backsim", !0);
f(m, _, N, "", "\\backsimeq", !0);
f(m, _, N, "", "\\subseteqq", !0);
f(m, _, N, "", "\\Subset", !0);
f(m, _, N, "", "\\sqsubset", !0);
f(m, _, N, "", "\\preccurlyeq", !0);
f(m, _, N, "", "\\curlyeqprec", !0);
f(m, _, N, "", "\\precsim", !0);
f(m, _, N, "", "\\precapprox", !0);
f(m, _, N, "", "\\vartriangleleft");
f(m, _, N, "", "\\trianglelefteq");
f(m, _, N, "", "\\vDash", !0);
f(m, _, N, "", "\\Vvdash", !0);
f(m, _, N, "", "\\smallsmile");
f(m, _, N, "", "\\smallfrown");
f(m, _, N, "", "\\bumpeq", !0);
f(m, _, N, "", "\\Bumpeq", !0);
f(m, _, N, "", "\\geqq", !0);
f(m, _, N, "", "\\geqslant", !0);
f(m, _, N, "", "\\eqslantgtr", !0);
f(m, _, N, "", "\\gtrsim", !0);
f(m, _, N, "", "\\gtrapprox", !0);
f(m, _, te, "", "\\gtrdot");
f(m, _, N, "", "\\ggg", !0);
f(m, _, N, "", "\\gtrless", !0);
f(m, _, N, "", "\\gtreqless", !0);
f(m, _, N, "", "\\gtreqqless", !0);
f(m, _, N, "", "\\eqcirc", !0);
f(m, _, N, "", "\\circeq", !0);
f(m, _, N, "", "\\triangleq", !0);
f(m, _, N, "", "\\thicksim");
f(m, _, N, "", "\\thickapprox");
f(m, _, N, "", "\\supseteqq", !0);
f(m, _, N, "", "\\Supset", !0);
f(m, _, N, "", "\\sqsupset", !0);
f(m, _, N, "", "\\succcurlyeq", !0);
f(m, _, N, "", "\\curlyeqsucc", !0);
f(m, _, N, "", "\\succsim", !0);
f(m, _, N, "", "\\succapprox", !0);
f(m, _, N, "", "\\vartriangleright");
f(m, _, N, "", "\\trianglerighteq");
f(m, _, N, "", "\\Vdash", !0);
f(m, _, N, "", "\\shortmid");
f(m, _, N, "", "\\shortparallel");
f(m, _, N, "", "\\between", !0);
f(m, _, N, "", "\\pitchfork", !0);
f(m, _, N, "", "\\varpropto");
f(m, _, N, "", "\\blacktriangleleft");
f(m, _, N, "", "\\therefore", !0);
f(m, _, N, "", "\\backepsilon");
f(m, _, N, "", "\\blacktriangleright");
f(m, _, N, "", "\\because", !0);
f(m, _, N, "", "\\llless");
f(m, _, N, "", "\\gggtr");
f(m, _, te, "", "\\lhd");
f(m, _, te, "", "\\rhd");
f(m, _, N, "", "\\eqsim", !0);
f(m, b, N, "", "\\Join");
f(m, _, N, "", "\\Doteq", !0);
f(m, _, te, "", "\\dotplus", !0);
f(m, _, te, "", "\\smallsetminus");
f(m, _, te, "", "\\Cap", !0);
f(m, _, te, "", "\\Cup", !0);
f(m, _, te, "", "\\doublebarwedge", !0);
f(m, _, te, "", "\\boxminus", !0);
f(m, _, te, "", "\\boxplus", !0);
f(m, _, te, "", "\\divideontimes", !0);
f(m, _, te, "", "\\ltimes", !0);
f(m, _, te, "", "\\rtimes", !0);
f(m, _, te, "", "\\leftthreetimes", !0);
f(m, _, te, "", "\\rightthreetimes", !0);
f(m, _, te, "", "\\curlywedge", !0);
f(m, _, te, "", "\\curlyvee", !0);
f(m, _, te, "", "\\circleddash", !0);
f(m, _, te, "", "\\circledast", !0);
f(m, _, te, "", "\\centerdot");
f(m, _, te, "", "\\intercal", !0);
f(m, _, te, "", "\\doublecap");
f(m, _, te, "", "\\doublecup");
f(m, _, te, "", "\\boxtimes", !0);
f(m, _, N, "", "\\dashrightarrow", !0);
f(m, _, N, "", "\\dashleftarrow", !0);
f(m, _, N, "", "\\leftleftarrows", !0);
f(m, _, N, "", "\\leftrightarrows", !0);
f(m, _, N, "", "\\Lleftarrow", !0);
f(m, _, N, "", "\\twoheadleftarrow", !0);
f(m, _, N, "", "\\leftarrowtail", !0);
f(m, _, N, "", "\\looparrowleft", !0);
f(m, _, N, "", "\\leftrightharpoons", !0);
f(m, _, N, "", "\\curvearrowleft", !0);
f(m, _, N, "", "\\circlearrowleft", !0);
f(m, _, N, "", "\\Lsh", !0);
f(m, _, N, "", "\\upuparrows", !0);
f(m, _, N, "", "\\upharpoonleft", !0);
f(m, _, N, "", "\\downharpoonleft", !0);
f(m, b, N, "", "\\origof", !0);
f(m, b, N, "", "\\imageof", !0);
f(m, _, N, "", "\\multimap", !0);
f(m, _, N, "", "\\leftrightsquigarrow", !0);
f(m, _, N, "", "\\rightrightarrows", !0);
f(m, _, N, "", "\\rightleftarrows", !0);
f(m, _, N, "", "\\twoheadrightarrow", !0);
f(m, _, N, "", "\\rightarrowtail", !0);
f(m, _, N, "", "\\looparrowright", !0);
f(m, _, N, "", "\\curvearrowright", !0);
f(m, _, N, "", "\\circlearrowright", !0);
f(m, _, N, "", "\\Rsh", !0);
f(m, _, N, "", "\\downdownarrows", !0);
f(m, _, N, "", "\\upharpoonright", !0);
f(m, _, N, "", "\\downharpoonright", !0);
f(m, _, N, "", "\\rightsquigarrow", !0);
f(m, _, N, "", "\\leadsto");
f(m, _, N, "", "\\Rrightarrow", !0);
f(m, _, N, "", "\\restriction");
f(m, b, M, "", "`");
f(m, b, M, "$", "\\$");
f(H, b, M, "$", "\\$");
f(H, b, M, "$", "\\textdollar");
f(m, b, M, "%", "\\%");
f(H, b, M, "%", "\\%");
f(m, b, M, "_", "\\_");
f(H, b, M, "_", "\\_");
f(H, b, M, "_", "\\textunderscore");
f(m, b, M, "", "\\angle", !0);
f(m, b, M, "", "\\infty", !0);
f(m, b, M, "", "\\prime");
f(m, b, M, "", "\\triangle");
f(m, b, M, "", "\\Gamma", !0);
f(m, b, M, "", "\\Delta", !0);
f(m, b, M, "", "\\Theta", !0);
f(m, b, M, "", "\\Lambda", !0);
f(m, b, M, "", "\\Xi", !0);
f(m, b, M, "", "\\Pi", !0);
f(m, b, M, "", "\\Sigma", !0);
f(m, b, M, "", "\\Upsilon", !0);
f(m, b, M, "", "\\Phi", !0);
f(m, b, M, "", "\\Psi", !0);
f(m, b, M, "", "\\Omega", !0);
f(m, b, M, "A", "");
f(m, b, M, "B", "");
f(m, b, M, "E", "");
f(m, b, M, "Z", "");
f(m, b, M, "H", "");
f(m, b, M, "I", "");
f(m, b, M, "K", "");
f(m, b, M, "M", "");
f(m, b, M, "N", "");
f(m, b, M, "O", "");
f(m, b, M, "P", "");
f(m, b, M, "T", "");
f(m, b, M, "X", "");
f(m, b, M, "", "\\neg", !0);
f(m, b, M, "", "\\lnot");
f(m, b, M, "", "\\top");
f(m, b, M, "", "\\bot");
f(m, b, M, "", "\\emptyset");
f(m, _, M, "", "\\varnothing");
f(m, b, ue, "", "\\alpha", !0);
f(m, b, ue, "", "\\beta", !0);
f(m, b, ue, "", "\\gamma", !0);
f(m, b, ue, "", "\\delta", !0);
f(m, b, ue, "", "\\epsilon", !0);
f(m, b, ue, "", "\\zeta", !0);
f(m, b, ue, "", "\\eta", !0);
f(m, b, ue, "", "\\theta", !0);
f(m, b, ue, "", "\\iota", !0);
f(m, b, ue, "", "\\kappa", !0);
f(m, b, ue, "", "\\lambda", !0);
f(m, b, ue, "", "\\mu", !0);
f(m, b, ue, "", "\\nu", !0);
f(m, b, ue, "", "\\xi", !0);
f(m, b, ue, "", "\\omicron", !0);
f(m, b, ue, "", "\\pi", !0);
f(m, b, ue, "", "\\rho", !0);
f(m, b, ue, "", "\\sigma", !0);
f(m, b, ue, "", "\\tau", !0);
f(m, b, ue, "", "\\upsilon", !0);
f(m, b, ue, "", "\\phi", !0);
f(m, b, ue, "", "\\chi", !0);
f(m, b, ue, "", "\\psi", !0);
f(m, b, ue, "", "\\omega", !0);
f(m, b, ue, "", "\\varepsilon", !0);
f(m, b, ue, "", "\\vartheta", !0);
f(m, b, ue, "", "\\varpi", !0);
f(m, b, ue, "", "\\varrho", !0);
f(m, b, ue, "", "\\varsigma", !0);
f(m, b, ue, "", "\\varphi", !0);
f(m, b, te, "", "*", !0);
f(m, b, te, "+", "+");
f(m, b, te, "", "-", !0);
f(m, b, te, "", "\\cdot", !0);
f(m, b, te, "", "\\circ", !0);
f(m, b, te, "", "\\div", !0);
f(m, b, te, "", "\\pm", !0);
f(m, b, te, "", "\\times", !0);
f(m, b, te, "", "\\cap", !0);
f(m, b, te, "", "\\cup", !0);
f(m, b, te, "", "\\setminus", !0);
f(m, b, te, "", "\\land");
f(m, b, te, "", "\\lor");
f(m, b, te, "", "\\wedge", !0);
f(m, b, te, "", "\\vee", !0);
f(m, b, M, "", "\\surd");
f(m, b, Wt, "", "\\langle", !0);
f(m, b, Wt, "", "\\lvert");
f(m, b, Wt, "", "\\lVert");
f(m, b, Tt, "?", "?");
f(m, b, Tt, "!", "!");
f(m, b, Tt, "", "\\rangle", !0);
f(m, b, Tt, "", "\\rvert");
f(m, b, Tt, "", "\\rVert");
f(m, b, N, "=", "=");
f(m, b, N, ":", ":");
f(m, b, N, "", "\\approx", !0);
f(m, b, N, "", "\\cong", !0);
f(m, b, N, "", "\\ge");
f(m, b, N, "", "\\geq", !0);
f(m, b, N, "", "\\gets");
f(m, b, N, ">", "\\gt", !0);
f(m, b, N, "", "\\in", !0);
f(m, b, N, "", "\\@not");
f(m, b, N, "", "\\subset", !0);
f(m, b, N, "", "\\supset", !0);
f(m, b, N, "", "\\subseteq", !0);
f(m, b, N, "", "\\supseteq", !0);
f(m, _, N, "", "\\nsubseteq", !0);
f(m, _, N, "", "\\nsupseteq", !0);
f(m, b, N, "", "\\models");
f(m, b, N, "", "\\leftarrow", !0);
f(m, b, N, "", "\\le");
f(m, b, N, "", "\\leq", !0);
f(m, b, N, "<", "\\lt", !0);
f(m, b, N, "", "\\rightarrow", !0);
f(m, b, N, "", "\\to");
f(m, _, N, "", "\\ngeq", !0);
f(m, _, N, "", "\\nleq", !0);
f(m, b, Jn, "", "\\ ");
f(m, b, Jn, "", "\\space");
f(m, b, Jn, "", "\\nobreakspace");
f(H, b, Jn, "", "\\ ");
f(H, b, Jn, "", " ");
f(H, b, Jn, "", "\\space");
f(H, b, Jn, "", "\\nobreakspace");
f(m, b, Jn, null, "\\nobreak");
f(m, b, Jn, null, "\\allowbreak");
f(m, b, hs, ",", ",");
f(m, b, hs, ";", ";");
f(m, _, te, "", "\\barwedge", !0);
f(m, _, te, "", "\\veebar", !0);
f(m, b, te, "", "\\odot", !0);
f(m, b, te, "", "\\oplus", !0);
f(m, b, te, "", "\\otimes", !0);
f(m, b, M, "", "\\partial", !0);
f(m, b, te, "", "\\oslash", !0);
f(m, _, te, "", "\\circledcirc", !0);
f(m, _, te, "", "\\boxdot", !0);
f(m, b, te, "", "\\bigtriangleup");
f(m, b, te, "", "\\bigtriangledown");
f(m, b, te, "", "\\dagger");
f(m, b, te, "", "\\diamond");
f(m, b, te, "", "\\star");
f(m, b, te, "", "\\triangleleft");
f(m, b, te, "", "\\triangleright");
f(m, b, Wt, "{", "\\{");
f(H, b, M, "{", "\\{");
f(H, b, M, "{", "\\textbraceleft");
f(m, b, Tt, "}", "\\}");
f(H, b, M, "}", "\\}");
f(H, b, M, "}", "\\textbraceright");
f(m, b, Wt, "{", "\\lbrace");
f(m, b, Tt, "}", "\\rbrace");
f(m, b, Wt, "[", "\\lbrack", !0);
f(H, b, M, "[", "\\lbrack", !0);
f(m, b, Tt, "]", "\\rbrack", !0);
f(H, b, M, "]", "\\rbrack", !0);
f(m, b, Wt, "(", "\\lparen", !0);
f(m, b, Tt, ")", "\\rparen", !0);
f(H, b, M, "<", "\\textless", !0);
f(H, b, M, ">", "\\textgreater", !0);
f(m, b, Wt, "", "\\lfloor", !0);
f(m, b, Tt, "", "\\rfloor", !0);
f(m, b, Wt, "", "\\lceil", !0);
f(m, b, Tt, "", "\\rceil", !0);
f(m, b, M, "\\", "\\backslash");
f(m, b, M, "", "|");
f(m, b, M, "", "\\vert");
f(H, b, M, "|", "\\textbar", !0);
f(m, b, M, "", "\\|");
f(m, b, M, "", "\\Vert");
f(H, b, M, "", "\\textbardbl");
f(H, b, M, "~", "\\textasciitilde");
f(H, b, M, "\\", "\\textbackslash");
f(H, b, M, "^", "\\textasciicircum");
f(m, b, N, "", "\\uparrow", !0);
f(m, b, N, "", "\\Uparrow", !0);
f(m, b, N, "", "\\downarrow", !0);
f(m, b, N, "", "\\Downarrow", !0);
f(m, b, N, "", "\\updownarrow", !0);
f(m, b, N, "", "\\Updownarrow", !0);
f(m, b, Qe, "", "\\coprod");
f(m, b, Qe, "", "\\bigvee");
f(m, b, Qe, "", "\\bigwedge");
f(m, b, Qe, "", "\\biguplus");
f(m, b, Qe, "", "\\bigcap");
f(m, b, Qe, "", "\\bigcup");
f(m, b, Qe, "", "\\int");
f(m, b, Qe, "", "\\intop");
f(m, b, Qe, "", "\\iint");
f(m, b, Qe, "", "\\iiint");
f(m, b, Qe, "", "\\prod");
f(m, b, Qe, "", "\\sum");
f(m, b, Qe, "", "\\bigotimes");
f(m, b, Qe, "", "\\bigoplus");
f(m, b, Qe, "", "\\bigodot");
f(m, b, Qe, "", "\\oint");
f(m, b, Qe, "", "\\oiint");
f(m, b, Qe, "", "\\oiiint");
f(m, b, Qe, "", "\\bigsqcup");
f(m, b, Qe, "", "\\smallint");
f(H, b, Ki, "", "\\textellipsis");
f(m, b, Ki, "", "\\mathellipsis");
f(H, b, Ki, "", "\\ldots", !0);
f(m, b, Ki, "", "\\ldots", !0);
f(m, b, Ki, "", "\\@cdots", !0);
f(m, b, Ki, "", "\\ddots", !0);
f(m, b, M, "", "\\varvdots");
f(m, b, Pe, "", "\\acute");
f(m, b, Pe, "", "\\grave");
f(m, b, Pe, "", "\\ddot");
f(m, b, Pe, "~", "\\tilde");
f(m, b, Pe, "", "\\bar");
f(m, b, Pe, "", "\\breve");
f(m, b, Pe, "", "\\check");
f(m, b, Pe, "^", "\\hat");
f(m, b, Pe, "", "\\vec");
f(m, b, Pe, "", "\\dot");
f(m, b, Pe, "", "\\mathring");
f(m, b, ue, "", "\\@imath");
f(m, b, ue, "", "\\@jmath");
f(m, b, M, "", "");
f(m, b, M, "", "");
f(H, b, M, "", "\\i", !0);
f(H, b, M, "", "\\j", !0);
f(H, b, M, "", "\\ss", !0);
f(H, b, M, "", "\\ae", !0);
f(H, b, M, "", "\\oe", !0);
f(H, b, M, "", "\\o", !0);
f(H, b, M, "", "\\AE", !0);
f(H, b, M, "", "\\OE", !0);
f(H, b, M, "", "\\O", !0);
f(H, b, Pe, "", "\\'");
f(H, b, Pe, "", "\\`");
f(H, b, Pe, "", "\\^");
f(H, b, Pe, "", "\\~");
f(H, b, Pe, "", "\\=");
f(H, b, Pe, "", "\\u");
f(H, b, Pe, "", "\\.");
f(H, b, Pe, "", "\\c");
f(H, b, Pe, "", "\\r");
f(H, b, Pe, "", "\\v");
f(H, b, Pe, "", '\\"');
f(H, b, Pe, "", "\\H");
f(H, b, Pe, "", "\\textcircled");
var f4 = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
f(H, b, M, "", "--", !0);
f(H, b, M, "", "\\textendash");
f(H, b, M, "", "---", !0);
f(H, b, M, "", "\\textemdash");
f(H, b, M, "", "`", !0);
f(H, b, M, "", "\\textquoteleft");
f(H, b, M, "", "'", !0);
f(H, b, M, "", "\\textquoteright");
f(H, b, M, "", "``", !0);
f(H, b, M, "", "\\textquotedblleft");
f(H, b, M, "", "''", !0);
f(H, b, M, "", "\\textquotedblright");
f(m, b, M, "", "\\degree", !0);
f(H, b, M, "", "\\degree");
f(H, b, M, "", "\\textdegree", !0);
f(m, b, M, "", "\\pounds");
f(m, b, M, "", "\\mathsterling", !0);
f(H, b, M, "", "\\pounds");
f(H, b, M, "", "\\textsterling", !0);
f(m, _, M, "", "\\maltese");
f(H, _, M, "", "\\maltese");
var F1 = '0123456789/@."';
for (var c0 = 0; c0 < F1.length; c0++) {
  var U1 = F1.charAt(c0);
  f(m, b, M, U1, U1);
}
var $1 = '0123456789!@*()-=+";:?/.,';
for (var d0 = 0; d0 < $1.length; d0++) {
  var H1 = $1.charAt(d0);
  f(H, b, M, H1, H1);
}
var Bo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var f0 = 0; f0 < Bo.length; f0++) {
  var Ol = Bo.charAt(f0);
  f(m, b, ue, Ol, Ol), f(H, b, M, Ol, Ol);
}
f(m, _, M, "C", "");
f(H, _, M, "C", "");
f(m, _, M, "H", "");
f(H, _, M, "H", "");
f(m, _, M, "N", "");
f(H, _, M, "N", "");
f(m, _, M, "P", "");
f(H, _, M, "P", "");
f(m, _, M, "Q", "");
f(H, _, M, "Q", "");
f(m, _, M, "R", "");
f(H, _, M, "R", "");
f(m, _, M, "Z", "");
f(H, _, M, "Z", "");
f(m, b, ue, "h", "");
f(H, b, ue, "h", "");
var fe = "";
for (var vt = 0; vt < Bo.length; vt++) {
  var Ve = Bo.charAt(vt);
  fe = String.fromCharCode(55349, 56320 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56372 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56424 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56580 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56684 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56736 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56788 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56840 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56944 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), vt < 26 && (fe = String.fromCharCode(55349, 56632 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe), fe = String.fromCharCode(55349, 56476 + vt), f(m, b, ue, Ve, fe), f(H, b, M, Ve, fe));
}
fe = "";
f(m, b, ue, "k", fe);
f(H, b, M, "k", fe);
for (var Dr = 0; Dr < 10; Dr++) {
  var rr = Dr.toString();
  fe = String.fromCharCode(55349, 57294 + Dr), f(m, b, ue, rr, fe), f(H, b, M, rr, fe), fe = String.fromCharCode(55349, 57314 + Dr), f(m, b, ue, rr, fe), f(H, b, M, rr, fe), fe = String.fromCharCode(55349, 57324 + Dr), f(m, b, ue, rr, fe), f(H, b, M, rr, fe), fe = String.fromCharCode(55349, 57334 + Dr), f(m, b, ue, rr, fe), f(H, b, M, rr, fe);
}
var Ou = "";
for (var h0 = 0; h0 < Ou.length; h0++) {
  var Rl = Ou.charAt(h0);
  f(m, b, ue, Rl, Rl), f(H, b, M, Rl, Rl);
}
var Il = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], q1 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Iw = function(t, n) {
  var r = t.charCodeAt(0), i = t.charCodeAt(1), a = (r - 55296) * 1024 + (i - 56320) + 65536, l = n === "math" ? 0 : 1;
  if (119808 <= a && a < 120484) {
    var o = Math.floor((a - 119808) / 26);
    return [Il[o][2], Il[o][l]];
  } else if (120782 <= a && a <= 120831) {
    var s = Math.floor((a - 120782) / 10);
    return [q1[s][2], q1[s][l]];
  } else {
    if (a === 120485 || a === 120486)
      return [Il[0][2], Il[0][l]];
    if (120486 < a && a < 120782)
      return ["", ""];
    throw new Y("Unsupported character: " + t);
  }
}, ps = function(t, n, r) {
  return Ie[r][t] && Ie[r][t].replace && (t = Ie[r][t].replace), {
    value: t,
    metrics: ed(t, n, r)
  };
}, dn = function(t, n, r, i, a) {
  var l = ps(t, n, r), o = l.metrics;
  t = l.value;
  var s;
  if (o) {
    var u = o.italic;
    (r === "text" || i && i.font === "mathit") && (u = 0), s = new rn(t, o.height, o.depth, u, o.skew, o.width, a);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + t + "' in style '" + n + "' and mode '" + r + "'")), s = new rn(t, 0, 0, 0, 0, 0, a);
  if (i) {
    s.maxFontSize = i.sizeMultiplier, i.style.isTight() && s.classes.push("mtight");
    var c = i.getColor();
    c && (s.style.color = c);
  }
  return s;
}, Dw = function(t, n, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && ps(t, "Main-Bold", n).metrics ? dn(t, "Main-Bold", n, r, i.concat(["mathbf"])) : t === "\\" || Ie[n][t].font === "main" ? dn(t, "Main-Regular", n, r, i) : dn(t, "AMS-Regular", n, r, i.concat(["amsrm"]));
}, zw = function(t, n, r, i, a) {
  return a !== "textord" && ps(t, "Math-BoldItalic", n).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Lw = function(t, n, r) {
  var i = t.mode, a = t.text, l = ["mord"], o = i === "math" || i === "text" && n.font, s = o ? n.font : n.fontFamily, u = "", c = "";
  if (a.charCodeAt(0) === 55349 && ([u, c] = Iw(a, i)), u.length > 0)
    return dn(a, u, i, n, l.concat(c));
  if (s) {
    var d, h;
    if (s === "boldsymbol") {
      var p = zw(a, i, n, l, r);
      d = p.fontName, h = [p.fontClass];
    } else o ? (d = m4[s].fontName, h = [s]) : (d = Dl(s, n.fontWeight, n.fontShape), h = [s, n.fontWeight, n.fontShape]);
    if (ps(a, d, i).metrics)
      return dn(a, d, i, n, l.concat(h));
    if (f4.hasOwnProperty(a) && d.slice(0, 10) === "Typewriter") {
      for (var g = [], w = 0; w < a.length; w++)
        g.push(dn(a[w], d, i, n, l.concat(h)));
      return p4(g);
    }
  }
  if (r === "mathord")
    return dn(a, "Math-Italic", i, n, l.concat(["mathnormal"]));
  if (r === "textord") {
    var S = Ie[i][a] && Ie[i][a].font;
    if (S === "ams") {
      var y = Dl("amsrm", n.fontWeight, n.fontShape);
      return dn(a, y, i, n, l.concat("amsrm", n.fontWeight, n.fontShape));
    } else if (S === "main" || !S) {
      var v = Dl("textrm", n.fontWeight, n.fontShape);
      return dn(a, v, i, n, l.concat(n.fontWeight, n.fontShape));
    } else {
      var x = Dl(S, n.fontWeight, n.fontShape);
      return dn(a, x, i, n, l.concat(x, n.fontWeight, n.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Pw = (e, t) => {
  if (kr(e.classes) !== kr(t.classes) || e.skew !== t.skew || e.maxFontSize !== t.maxFontSize)
    return !1;
  if (e.classes.length === 1) {
    var n = e.classes[0];
    if (n === "mbin" || n === "mord")
      return !1;
  }
  for (var r in e.style)
    if (e.style.hasOwnProperty(r) && e.style[r] !== t.style[r])
      return !1;
  for (var i in t.style)
    if (t.style.hasOwnProperty(i) && e.style[i] !== t.style[i])
      return !1;
  return !0;
}, Bw = (e) => {
  for (var t = 0; t < e.length - 1; t++) {
    var n = e[t], r = e[t + 1];
    n instanceof rn && r instanceof rn && Pw(n, r) && (n.text += r.text, n.height = Math.max(n.height, r.height), n.depth = Math.max(n.depth, r.depth), n.italic = r.italic, e.splice(t + 1, 1), t--);
  }
  return e;
}, nd = function(t) {
  for (var n = 0, r = 0, i = 0, a = 0; a < t.children.length; a++) {
    var l = t.children[a];
    l.height > n && (n = l.height), l.depth > r && (r = l.depth), l.maxFontSize > i && (i = l.maxFontSize);
  }
  t.height = n, t.depth = r, t.maxFontSize = i;
}, At = function(t, n, r, i) {
  var a = new ol(t, n, r, i);
  return nd(a), a;
}, h4 = (e, t, n, r) => new ol(e, t, n, r), Fw = function(t, n, r) {
  var i = At([t], [], n);
  return i.height = Math.max(r || n.fontMetrics().defaultRuleThickness, n.minRuleThickness), i.style.borderBottomWidth = X(i.height), i.maxFontSize = 1, i;
}, Uw = function(t, n, r, i) {
  var a = new td(t, n, r, i);
  return nd(a), a;
}, p4 = function(t) {
  var n = new ll(t);
  return nd(n), n;
}, $w = function(t, n) {
  return t instanceof ll ? At([], [t], n) : t;
}, Hw = function(t) {
  if (t.positionType === "individualShift") {
    for (var n = t.children, r = [n[0]], i = -n[0].shift - n[0].elem.depth, a = i, l = 1; l < n.length; l++) {
      var o = -n[l].shift - a - n[l].elem.depth, s = o - (n[l - 1].elem.height + n[l - 1].elem.depth);
      a = a + o, r.push({
        type: "kern",
        size: s
      }), r.push(n[l]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var u;
  if (t.positionType === "top") {
    for (var c = t.positionData, d = 0; d < t.children.length; d++) {
      var h = t.children[d];
      c -= h.type === "kern" ? h.size : h.elem.height + h.elem.depth;
    }
    u = c;
  } else if (t.positionType === "bottom")
    u = -t.positionData;
  else {
    var p = t.children[0];
    if (p.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (t.positionType === "shift")
      u = -p.elem.depth - t.positionData;
    else if (t.positionType === "firstBaseline")
      u = -p.elem.depth;
    else
      throw new Error("Invalid positionType " + t.positionType + ".");
  }
  return {
    children: t.children,
    depth: u
  };
}, qw = function(t, n) {
  for (var {
    children: r,
    depth: i
  } = Hw(t), a = 0, l = 0; l < r.length; l++) {
    var o = r[l];
    if (o.type === "elem") {
      var s = o.elem;
      a = Math.max(a, s.maxFontSize, s.height);
    }
  }
  a += 2;
  var u = At(["pstrut"], []);
  u.style.height = X(a);
  for (var c = [], d = i, h = i, p = i, g = 0; g < r.length; g++) {
    var w = r[g];
    if (w.type === "kern")
      p += w.size;
    else {
      var S = w.elem, y = w.wrapperClasses || [], v = w.wrapperStyle || {}, x = At(y, [u, S], void 0, v);
      x.style.top = X(-a - p - S.depth), w.marginLeft && (x.style.marginLeft = w.marginLeft), w.marginRight && (x.style.marginRight = w.marginRight), c.push(x), p += S.height + S.depth;
    }
    d = Math.min(d, p), h = Math.max(h, p);
  }
  var C = At(["vlist"], c);
  C.style.height = X(h);
  var R;
  if (d < 0) {
    var T = At([], []), z = At(["vlist"], [T]);
    z.style.height = X(-d);
    var P = At(["vlist-s"], [new rn("")]);
    R = [At(["vlist-r"], [C, P]), At(["vlist-r"], [z])];
  } else
    R = [At(["vlist-r"], [C])];
  var U = At(["vlist-t"], R);
  return R.length === 2 && U.classes.push("vlist-t2"), U.height = h, U.depth = -d, U;
}, Gw = (e, t) => {
  var n = At(["mspace"], [], t), r = Ue(e, t);
  return n.style.marginRight = X(r), n;
}, Dl = function(t, n, r) {
  var i = "";
  switch (t) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = t;
  }
  var a;
  return n === "textbf" && r === "textit" ? a = "BoldItalic" : n === "textbf" ? a = "Bold" : n === "textit" ? a = "Italic" : a = "Regular", i + "-" + a;
}, m4 = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, g4 = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, Vw = function(t, n) {
  var [r, i, a] = g4[t], l = new Er(r), o = new Yn([l], {
    width: X(i),
    height: X(a),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + X(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * a,
    preserveAspectRatio: "xMinYMin"
  }), s = h4(["overlay"], [o], n);
  return s.height = a, s.style.height = X(a), s.style.width = X(i), s;
}, D = {
  fontMap: m4,
  makeSymbol: dn,
  mathsym: Dw,
  makeSpan: At,
  makeSvgSpan: h4,
  makeLineSpan: Fw,
  makeAnchor: Uw,
  makeFragment: p4,
  wrapFragment: $w,
  makeVList: qw,
  makeOrd: Lw,
  makeGlue: Gw,
  staticSvg: Vw,
  svgData: g4,
  tryCombineChars: Bw
}, Be = {
  number: 3,
  unit: "mu"
}, zr = {
  number: 4,
  unit: "mu"
}, zn = {
  number: 5,
  unit: "mu"
}, Ww = {
  mord: {
    mop: Be,
    mbin: zr,
    mrel: zn,
    minner: Be
  },
  mop: {
    mord: Be,
    mop: Be,
    mrel: zn,
    minner: Be
  },
  mbin: {
    mord: zr,
    mop: zr,
    mopen: zr,
    minner: zr
  },
  mrel: {
    mord: zn,
    mop: zn,
    mopen: zn,
    minner: zn
  },
  mopen: {},
  mclose: {
    mop: Be,
    mbin: zr,
    mrel: zn,
    minner: Be
  },
  mpunct: {
    mord: Be,
    mop: Be,
    mrel: zn,
    mopen: Be,
    mclose: Be,
    mpunct: Be,
    minner: Be
  },
  minner: {
    mord: Be,
    mop: Be,
    mbin: zr,
    mrel: zn,
    mopen: Be,
    mpunct: Be,
    minner: Be
  }
}, Kw = {
  mord: {
    mop: Be
  },
  mop: {
    mord: Be,
    mop: Be
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Be
  },
  mpunct: {},
  minner: {
    mop: Be
  }
}, v4 = {}, Fo = {}, Uo = {};
function J(e) {
  for (var {
    type: t,
    names: n,
    props: r,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: l
  } = e, o = {
    type: t,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, s = 0; s < n.length; ++s)
    v4[n[s]] = o;
  t && (a && (Fo[t] = a), l && (Uo[t] = l));
}
function ei(e) {
  var {
    type: t,
    htmlBuilder: n,
    mathmlBuilder: r
  } = e;
  J({
    type: t,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: n,
    mathmlBuilder: r
  });
}
var $o = function(t) {
  return t.type === "ordgroup" && t.body.length === 1 ? t.body[0] : t;
}, je = function(t) {
  return t.type === "ordgroup" ? t.body : [t];
}, jn = D.makeSpan, Yw = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], jw = ["rightmost", "mrel", "mclose", "mpunct"], Xw = {
  display: ce.DISPLAY,
  text: ce.TEXT,
  script: ce.SCRIPT,
  scriptscript: ce.SCRIPTSCRIPT
}, Zw = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, nt = function(t, n, r, i) {
  i === void 0 && (i = [null, null]);
  for (var a = [], l = 0; l < t.length; l++) {
    var o = Ee(t[l], n);
    if (o instanceof ll) {
      var s = o.children;
      a.push(...s);
    } else
      a.push(o);
  }
  if (D.tryCombineChars(a), !r)
    return a;
  var u = n;
  if (t.length === 1) {
    var c = t[0];
    c.type === "sizing" ? u = n.havingSize(c.size) : c.type === "styling" && (u = n.havingStyle(Xw[c.style]));
  }
  var d = jn([i[0] || "leftmost"], [], n), h = jn([i[1] || "rightmost"], [], n), p = r === "root";
  return G1(a, (g, w) => {
    var S = w.classes[0], y = g.classes[0];
    S === "mbin" && se.contains(jw, y) ? w.classes[0] = "mord" : y === "mbin" && se.contains(Yw, S) && (g.classes[0] = "mord");
  }, {
    node: d
  }, h, p), G1(a, (g, w) => {
    var S = Ru(w), y = Ru(g), v = S && y ? g.hasClass("mtight") ? Kw[S][y] : Ww[S][y] : null;
    if (v)
      return D.makeGlue(v, u);
  }, {
    node: d
  }, h, p), a;
}, G1 = function e(t, n, r, i, a) {
  i && t.push(i);
  for (var l = 0; l < t.length; l++) {
    var o = t[l], s = y4(o);
    if (s) {
      e(s.children, n, r, null, a);
      continue;
    }
    var u = !o.hasClass("mspace");
    if (u) {
      var c = n(o, r.node);
      c && (r.insertAfter ? r.insertAfter(c) : (t.unshift(c), l++));
    }
    u ? r.node = o : a && o.hasClass("newline") && (r.node = jn(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((d) => (h) => {
      t.splice(d + 1, 0, h), l++;
    })(l);
  }
  i && t.pop();
}, y4 = function(t) {
  return t instanceof ll || t instanceof td || t instanceof ol && t.hasClass("enclosing") ? t : null;
}, Qw = function e(t, n) {
  var r = y4(t);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (n === "right")
        return e(i[i.length - 1], "right");
      if (n === "left")
        return e(i[0], "left");
    }
  }
  return t;
}, Ru = function(t, n) {
  return t ? (n && (t = Qw(t, n)), Zw[t.classes[0]] || null) : null;
}, Ya = function(t, n) {
  var r = ["nulldelimiter"].concat(t.baseSizingClasses());
  return jn(n.concat(r));
}, Ee = function(t, n, r) {
  if (!t)
    return jn();
  if (Fo[t.type]) {
    var i = Fo[t.type](t, n);
    if (r && n.size !== r.size) {
      i = jn(n.sizingClasses(r), [i], n);
      var a = n.sizeMultiplier / r.sizeMultiplier;
      i.height *= a, i.depth *= a;
    }
    return i;
  } else
    throw new Y("Got group of unknown type: '" + t.type + "'");
};
function zl(e, t) {
  var n = jn(["base"], e, t), r = jn(["strut"]);
  return r.style.height = X(n.height + n.depth), n.depth && (r.style.verticalAlign = X(-n.depth)), n.children.unshift(r), n;
}
function Iu(e, t) {
  var n = null;
  e.length === 1 && e[0].type === "tag" && (n = e[0].tag, e = e[0].body);
  var r = nt(e, t, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var a = [], l = [], o = 0; o < r.length; o++)
    if (l.push(r[o]), r[o].hasClass("mbin") || r[o].hasClass("mrel") || r[o].hasClass("allowbreak")) {
      for (var s = !1; o < r.length - 1 && r[o + 1].hasClass("mspace") && !r[o + 1].hasClass("newline"); )
        o++, l.push(r[o]), r[o].hasClass("nobreak") && (s = !0);
      s || (a.push(zl(l, t)), l = []);
    } else r[o].hasClass("newline") && (l.pop(), l.length > 0 && (a.push(zl(l, t)), l = []), a.push(r[o]));
  l.length > 0 && a.push(zl(l, t));
  var u;
  n ? (u = zl(nt(n, t, !0)), u.classes = ["tag"], a.push(u)) : i && a.push(i);
  var c = jn(["katex-html"], a);
  if (c.setAttribute("aria-hidden", "true"), u) {
    var d = u.children[0];
    d.style.height = X(c.height + c.depth), c.depth && (d.style.verticalAlign = X(-c.depth));
  }
  return c;
}
function b4(e) {
  return new ll(e);
}
class Xt {
  constructor(t, n, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = n || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && t.setAttribute(n, this.attributes[n]);
    this.classes.length > 0 && (t.className = kr(this.classes));
    for (var r = 0; r < this.children.length; r++)
      t.appendChild(this.children[r].toNode());
    return t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var t = "<" + this.type;
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="', t += se.escape(this.attributes[n]), t += '"');
    this.classes.length > 0 && (t += ' class ="' + se.escape(kr(this.classes)) + '"'), t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</" + this.type + ">", t;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((t) => t.toText()).join("");
  }
}
class _a {
  constructor(t) {
    this.text = void 0, this.text = t;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return se.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Jw {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(t) {
    this.width = void 0, this.character = void 0, this.width = t, t >= 0.05555 && t <= 0.05556 ? this.character = "" : t >= 0.1666 && t <= 0.1667 ? this.character = "" : t >= 0.2222 && t <= 0.2223 ? this.character = "" : t >= 0.2777 && t <= 0.2778 ? this.character = "" : t >= -0.05556 && t <= -0.05555 ? this.character = "" : t >= -0.1667 && t <= -0.1666 ? this.character = "" : t >= -0.2223 && t <= -0.2222 ? this.character = "" : t >= -0.2778 && t <= -0.2777 ? this.character = "" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return t.setAttribute("width", X(this.width)), t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + X(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var G = {
  MathNode: Xt,
  TextNode: _a,
  SpaceNode: Jw,
  newDocumentFragment: b4
}, an = function(t, n, r) {
  return Ie[n][t] && Ie[n][t].replace && t.charCodeAt(0) !== 55349 && !(f4.hasOwnProperty(t) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (t = Ie[n][t].replace), new G.TextNode(t);
}, rd = function(t) {
  return t.length === 1 ? t[0] : new G.MathNode("mrow", t);
}, id = function(t, n) {
  if (n.fontFamily === "texttt")
    return "monospace";
  if (n.fontFamily === "textsf")
    return n.fontShape === "textit" && n.fontWeight === "textbf" ? "sans-serif-bold-italic" : n.fontShape === "textit" ? "sans-serif-italic" : n.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (n.fontShape === "textit" && n.fontWeight === "textbf")
    return "bold-italic";
  if (n.fontShape === "textit")
    return "italic";
  if (n.fontWeight === "textbf")
    return "bold";
  var r = n.font;
  if (!r || r === "mathnormal")
    return null;
  var i = t.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return t.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var a = t.text;
  if (se.contains(["\\imath", "\\jmath"], a))
    return null;
  Ie[i][a] && Ie[i][a].replace && (a = Ie[i][a].replace);
  var l = D.fontMap[r].fontName;
  return ed(a, l, i) ? D.fontMap[r].variant : null;
}, Dt = function(t, n, r) {
  if (t.length === 1) {
    var i = Me(t[0], n);
    return r && i instanceof Xt && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var a = [], l, o = 0; o < t.length; o++) {
    var s = Me(t[o], n);
    if (s instanceof Xt && l instanceof Xt) {
      if (s.type === "mtext" && l.type === "mtext" && s.getAttribute("mathvariant") === l.getAttribute("mathvariant")) {
        l.children.push(...s.children);
        continue;
      } else if (s.type === "mn" && l.type === "mn") {
        l.children.push(...s.children);
        continue;
      } else if (s.type === "mi" && s.children.length === 1 && l.type === "mn") {
        var u = s.children[0];
        if (u instanceof _a && u.text === ".") {
          l.children.push(...s.children);
          continue;
        }
      } else if (l.type === "mi" && l.children.length === 1) {
        var c = l.children[0];
        if (c instanceof _a && c.text === "" && (s.type === "mo" || s.type === "mi" || s.type === "mn")) {
          var d = s.children[0];
          d instanceof _a && d.text.length > 0 && (d.text = d.text.slice(0, 1) + "" + d.text.slice(1), a.pop());
        }
      }
    }
    a.push(s), l = s;
  }
  return a;
}, Sr = function(t, n, r) {
  return rd(Dt(t, n, r));
}, Me = function(t, n) {
  if (!t)
    return new G.MathNode("mrow");
  if (Uo[t.type]) {
    var r = Uo[t.type](t, n);
    return r;
  } else
    throw new Y("Got group of unknown type: '" + t.type + "'");
};
function V1(e, t, n, r, i) {
  var a = Dt(e, n), l;
  a.length === 1 && a[0] instanceof Xt && se.contains(["mrow", "mtable"], a[0].type) ? l = a[0] : l = new G.MathNode("mrow", a);
  var o = new G.MathNode("annotation", [new G.TextNode(t)]);
  o.setAttribute("encoding", "application/x-tex");
  var s = new G.MathNode("semantics", [l, o]), u = new G.MathNode("math", [s]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && u.setAttribute("display", "block");
  var c = i ? "katex" : "katex-mathml";
  return D.makeSpan([c], [u]);
}
var w4 = function(t) {
  return new Bn({
    style: t.displayMode ? ce.DISPLAY : ce.TEXT,
    maxSize: t.maxSize,
    minRuleThickness: t.minRuleThickness
  });
}, x4 = function(t, n) {
  if (n.displayMode) {
    var r = ["katex-display"];
    n.leqno && r.push("leqno"), n.fleqn && r.push("fleqn"), t = D.makeSpan(r, [t]);
  }
  return t;
}, ex = function(t, n, r) {
  var i = w4(r), a;
  if (r.output === "mathml")
    return V1(t, n, i, r.displayMode, !0);
  if (r.output === "html") {
    var l = Iu(t, i);
    a = D.makeSpan(["katex"], [l]);
  } else {
    var o = V1(t, n, i, r.displayMode, !1), s = Iu(t, i);
    a = D.makeSpan(["katex"], [o, s]);
  }
  return x4(a, r);
}, tx = function(t, n, r) {
  var i = w4(r), a = Iu(t, i), l = D.makeSpan(["katex"], [a]);
  return x4(l, r);
}, nx = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
}, rx = function(t) {
  var n = new G.MathNode("mo", [new G.TextNode(nx[t.replace(/^\\/, "")])]);
  return n.setAttribute("stretchy", "true"), n;
}, ix = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, ax = function(t) {
  return t.type === "ordgroup" ? t.body.length : 1;
}, lx = function(t, n) {
  function r() {
    var o = 4e5, s = t.label.slice(1);
    if (se.contains(["widehat", "widecheck", "widetilde", "utilde"], s)) {
      var u = t, c = ax(u.base), d, h, p;
      if (c > 5)
        s === "widehat" || s === "widecheck" ? (d = 420, o = 2364, p = 0.42, h = s + "4") : (d = 312, o = 2340, p = 0.34, h = "tilde4");
      else {
        var g = [1, 1, 2, 2, 3, 3][c];
        s === "widehat" || s === "widecheck" ? (o = [0, 1062, 2364, 2364, 2364][g], d = [0, 239, 300, 360, 420][g], p = [0, 0.24, 0.3, 0.3, 0.36, 0.42][g], h = s + g) : (o = [0, 600, 1033, 2339, 2340][g], d = [0, 260, 286, 306, 312][g], p = [0, 0.26, 0.286, 0.3, 0.306, 0.34][g], h = "tilde" + g);
      }
      var w = new Er(h), S = new Yn([w], {
        width: "100%",
        height: X(p),
        viewBox: "0 0 " + o + " " + d,
        preserveAspectRatio: "none"
      });
      return {
        span: D.makeSvgSpan([], [S], n),
        minWidth: 0,
        height: p
      };
    } else {
      var y = [], v = ix[s], [x, C, R] = v, T = R / 1e3, z = x.length, P, U;
      if (z === 1) {
        var O = v[3];
        P = ["hide-tail"], U = [O];
      } else if (z === 2)
        P = ["halfarrow-left", "halfarrow-right"], U = ["xMinYMin", "xMaxYMin"];
      else if (z === 3)
        P = ["brace-left", "brace-center", "brace-right"], U = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + z + " children.");
      for (var V = 0; V < z; V++) {
        var K = new Er(x[V]), ae = new Yn([K], {
          width: "400em",
          height: X(T),
          viewBox: "0 0 " + o + " " + R,
          preserveAspectRatio: U[V] + " slice"
        }), ie = D.makeSvgSpan([P[V]], [ae], n);
        if (z === 1)
          return {
            span: ie,
            minWidth: C,
            height: T
          };
        ie.style.height = X(T), y.push(ie);
      }
      return {
        span: D.makeSpan(["stretchy"], y, n),
        minWidth: C,
        height: T
      };
    }
  }
  var {
    span: i,
    minWidth: a,
    height: l
  } = r();
  return i.height = l, i.style.height = X(l), a > 0 && (i.style.minWidth = X(a)), i;
}, ox = function(t, n, r, i, a) {
  var l, o = t.height + t.depth + r + i;
  if (/fbox|color|angl/.test(n)) {
    if (l = D.makeSpan(["stretchy", n], [], a), n === "fbox") {
      var s = a.color && a.getColor();
      s && (l.style.borderColor = s);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(n) && u.push(new Mu({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(n) && u.push(new Mu({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var c = new Yn(u, {
      width: "100%",
      height: X(o)
    });
    l = D.makeSvgSpan([], [c], a);
  }
  return l.height = o, l.style.height = X(o), l;
}, Xn = {
  encloseSpan: ox,
  mathMLnode: rx,
  svgSpan: lx
};
function me(e, t) {
  if (!e || e.type !== t)
    throw new Error("Expected node of type " + t + ", but got " + (e ? "node of type " + e.type : String(e)));
  return e;
}
function ad(e) {
  var t = ms(e);
  if (!t)
    throw new Error("Expected node of symbol group type, but got " + (e ? "node of type " + e.type : String(e)));
  return t;
}
function ms(e) {
  return e && (e.type === "atom" || Rw.hasOwnProperty(e.type)) ? e : null;
}
var ld = (e, t) => {
  var n, r, i;
  e && e.type === "supsub" ? (r = me(e.base, "accent"), n = r.base, e.base = n, i = Mw(Ee(e, t)), e.base = r) : (r = me(e, "accent"), n = r.base);
  var a = Ee(n, t.havingCrampedStyle()), l = r.isShifty && se.isCharacterBox(n), o = 0;
  if (l) {
    var s = se.getBaseElem(n), u = Ee(s, t.havingCrampedStyle());
    o = B1(u).skew;
  }
  var c = r.label === "\\c", d = c ? a.height + a.depth : Math.min(a.height, t.fontMetrics().xHeight), h;
  if (r.isStretchy)
    h = Xn.svgSpan(r, t), h = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "elem",
        elem: h,
        wrapperClasses: ["svg-align"],
        wrapperStyle: o > 0 ? {
          width: "calc(100% - " + X(2 * o) + ")",
          marginLeft: X(2 * o)
        } : void 0
      }]
    }, t);
  else {
    var p, g;
    r.label === "\\vec" ? (p = D.staticSvg("vec", t), g = D.svgData.vec[1]) : (p = D.makeOrd({
      mode: r.mode,
      text: r.label
    }, t, "textord"), p = B1(p), p.italic = 0, g = p.width, c && (d += p.depth)), h = D.makeSpan(["accent-body"], [p]);
    var w = r.label === "\\textcircled";
    w && (h.classes.push("accent-full"), d = a.height);
    var S = o;
    w || (S -= g / 2), h.style.left = X(S), r.label === "\\textcircled" && (h.style.top = ".2em"), h = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: -d
      }, {
        type: "elem",
        elem: h
      }]
    }, t);
  }
  var y = D.makeSpan(["mord", "accent"], [h], t);
  return i ? (i.children[0] = y, i.height = Math.max(y.height, i.height), i.classes[0] = "mord", i) : y;
}, k4 = (e, t) => {
  var n = e.isStretchy ? Xn.mathMLnode(e.label) : new G.MathNode("mo", [an(e.label, e.mode)]), r = new G.MathNode("mover", [Me(e.base, t), n]);
  return r.setAttribute("accent", "true"), r;
}, sx = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((e) => "\\" + e).join("|"));
J({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var n = $o(t[0]), r = !sx.test(e.funcName), i = !r || e.funcName === "\\widehat" || e.funcName === "\\widetilde" || e.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: e.parser.mode,
      label: e.funcName,
      isStretchy: r,
      isShifty: i,
      base: n
    };
  },
  htmlBuilder: ld,
  mathmlBuilder: k4
});
J({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var n = t[0], r = e.parser.mode;
    return r === "math" && (e.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + e.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: e.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: n
    };
  },
  htmlBuilder: ld,
  mathmlBuilder: k4
});
J({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "accentUnder",
      mode: n.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (e, t) => {
    var n = Ee(e.base, t), r = Xn.svgSpan(e, t), i = e.label === "\\utilde" ? 0.12 : 0, a = D.makeVList({
      positionType: "top",
      positionData: n.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: n
      }]
    }, t);
    return D.makeSpan(["mord", "accentunder"], [a], t);
  },
  mathmlBuilder: (e, t) => {
    var n = Xn.mathMLnode(e.label), r = new G.MathNode("munder", [Me(e.base, t), n]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var Ll = (e) => {
  var t = new G.MathNode("mpadded", e ? [e] : []);
  return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t;
};
J({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: t[0],
      below: n[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(e, t) {
    var n = t.style, r = t.havingStyle(n.sup()), i = D.wrapFragment(Ee(e.body, r, t), t), a = e.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(a + "-arrow-pad");
    var l;
    e.below && (r = t.havingStyle(n.sub()), l = D.wrapFragment(Ee(e.below, r, t), t), l.classes.push(a + "-arrow-pad"));
    var o = Xn.svgSpan(e, t), s = -t.fontMetrics().axisHeight + 0.5 * o.height, u = -t.fontMetrics().axisHeight - 0.5 * o.height - 0.111;
    (i.depth > 0.25 || e.label === "\\xleftequilibrium") && (u -= i.depth);
    var c;
    if (l) {
      var d = -t.fontMetrics().axisHeight + l.height + 0.5 * o.height + 0.111;
      c = D.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: s
        }, {
          type: "elem",
          elem: l,
          shift: d
        }]
      }, t);
    } else
      c = D.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: s
        }]
      }, t);
    return c.children[0].children[0].children[1].classes.push("svg-align"), D.makeSpan(["mrel", "x-arrow"], [c], t);
  },
  mathmlBuilder(e, t) {
    var n = Xn.mathMLnode(e.label);
    n.setAttribute("minsize", e.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (e.body) {
      var i = Ll(Me(e.body, t));
      if (e.below) {
        var a = Ll(Me(e.below, t));
        r = new G.MathNode("munderover", [n, a, i]);
      } else
        r = new G.MathNode("mover", [n, i]);
    } else if (e.below) {
      var l = Ll(Me(e.below, t));
      r = new G.MathNode("munder", [n, l]);
    } else
      r = Ll(), r = new G.MathNode("mover", [n, r]);
    return r;
  }
});
var ux = D.makeSpan;
function E4(e, t) {
  var n = nt(e.body, t, !0);
  return ux([e.mclass], n, t);
}
function S4(e, t) {
  var n, r = Dt(e.body, t);
  return e.mclass === "minner" ? n = new G.MathNode("mpadded", r) : e.mclass === "mord" ? e.isCharacterBox ? (n = r[0], n.type = "mi") : n = new G.MathNode("mi", r) : (e.isCharacterBox ? (n = r[0], n.type = "mo") : n = new G.MathNode("mo", r), e.mclass === "mbin" ? (n.attributes.lspace = "0.22em", n.attributes.rspace = "0.22em") : e.mclass === "mpunct" ? (n.attributes.lspace = "0em", n.attributes.rspace = "0.17em") : e.mclass === "mopen" || e.mclass === "mclose" ? (n.attributes.lspace = "0em", n.attributes.rspace = "0em") : e.mclass === "minner" && (n.attributes.lspace = "0.0556em", n.attributes.width = "+0.1111em")), n;
}
J({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "mclass",
      mode: n.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: je(i),
      isCharacterBox: se.isCharacterBox(i)
    };
  },
  htmlBuilder: E4,
  mathmlBuilder: S4
});
var gs = (e) => {
  var t = e.type === "ordgroup" && e.body.length ? e.body[0] : e;
  return t.type === "atom" && (t.family === "bin" || t.family === "rel") ? "m" + t.family : "mord";
};
J({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "mclass",
      mode: n.mode,
      mclass: gs(t[0]),
      body: je(t[1]),
      isCharacterBox: se.isCharacterBox(t[1])
    };
  }
});
J({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[1], a = t[0], l;
    r !== "\\stackrel" ? l = gs(i) : l = "mrel";
    var o = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: je(i)
    }, s = {
      type: "supsub",
      mode: a.mode,
      base: o,
      sup: r === "\\underset" ? null : a,
      sub: r === "\\underset" ? a : null
    };
    return {
      type: "mclass",
      mode: n.mode,
      mclass: l,
      body: [s],
      isCharacterBox: se.isCharacterBox(s)
    };
  },
  htmlBuilder: E4,
  mathmlBuilder: S4
});
J({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "pmb",
      mode: n.mode,
      mclass: gs(t[0]),
      body: je(t[0])
    };
  },
  htmlBuilder(e, t) {
    var n = nt(e.body, t, !0), r = D.makeSpan([e.mclass], n, t);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(e, t) {
    var n = Dt(e.body, t), r = new G.MathNode("mstyle", n);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var cx = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, W1 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), K1 = (e) => e.type === "textord" && e.text === "@", dx = (e, t) => (e.type === "mathord" || e.type === "atom") && e.text === t;
function fx(e, t, n) {
  var r = cx[e];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return n.callFunction(r, [t[0]], [t[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = n.callFunction("\\\\cdleft", [t[0]], []), a = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, l = n.callFunction("\\Big", [a], []), o = n.callFunction("\\\\cdright", [t[1]], []), s = {
        type: "ordgroup",
        mode: "math",
        body: [i, l, o]
      };
      return n.callFunction("\\\\cdparent", [s], []);
    }
    case "\\\\cdlongequal":
      return n.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return n.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function hx(e) {
  var t = [];
  for (e.gullet.beginGroup(), e.gullet.macros.set("\\cr", "\\\\\\relax"), e.gullet.beginGroup(); ; ) {
    t.push(e.parseExpression(!1, "\\\\")), e.gullet.endGroup(), e.gullet.beginGroup();
    var n = e.fetch().text;
    if (n === "&" || n === "\\\\")
      e.consume();
    else if (n === "\\end") {
      t[t.length - 1].length === 0 && t.pop();
      break;
    } else
      throw new Y("Expected \\\\ or \\cr or \\end", e.nextToken);
  }
  for (var r = [], i = [r], a = 0; a < t.length; a++) {
    for (var l = t[a], o = W1(), s = 0; s < l.length; s++)
      if (!K1(l[s]))
        o.body.push(l[s]);
      else {
        r.push(o), s += 1;
        var u = ad(l[s]).text, c = new Array(2);
        if (c[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, c[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var d = 0; d < 2; d++) {
            for (var h = !0, p = s + 1; p < l.length; p++) {
              if (dx(l[p], u)) {
                h = !1, s = p;
                break;
              }
              if (K1(l[p]))
                throw new Y("Missing a " + u + " character to complete a CD arrow.", l[p]);
              c[d].body.push(l[p]);
            }
            if (h)
              throw new Y("Missing a " + u + " character to complete a CD arrow.", l[s]);
          }
        else
          throw new Y('Expected one of "<>AV=|." after @', l[s]);
        var g = fx(u, c, e), w = {
          type: "styling",
          body: [g],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(w), o = W1();
      }
    a % 2 === 0 ? r.push(o) : r.shift(), r = [], i.push(r);
  }
  e.gullet.endGroup(), e.gullet.endGroup();
  var S = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: S,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
J({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e;
    return {
      type: "cdlabel",
      mode: n.mode,
      side: r.slice(4),
      label: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = t.havingStyle(t.style.sup()), r = D.wrapFragment(Ee(e.label, n, t), t);
    return r.classes.push("cd-label-" + e.side), r.style.bottom = X(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mrow", [Me(e.label, t)]);
    return n = new G.MathNode("mpadded", [n]), n.setAttribute("width", "0"), e.side === "left" && n.setAttribute("lspace", "-1width"), n.setAttribute("voffset", "0.7em"), n = new G.MathNode("mstyle", [n]), n.setAttribute("displaystyle", "false"), n.setAttribute("scriptlevel", "1"), n;
  }
});
J({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "cdlabelparent",
      mode: n.mode,
      fragment: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = D.wrapFragment(Ee(e.fragment, t), t);
    return n.classes.push("cd-vert-arrow"), n;
  },
  mathmlBuilder(e, t) {
    return new G.MathNode("mrow", [Me(e.fragment, t)]);
  }
});
J({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    for (var {
      parser: n
    } = e, r = me(t[0], "ordgroup"), i = r.body, a = "", l = 0; l < i.length; l++) {
      var o = me(i[l], "textord");
      a += o.text;
    }
    var s = parseInt(a), u;
    if (isNaN(s))
      throw new Y("\\@char has non-numeric argument " + a);
    if (s < 0 || s >= 1114111)
      throw new Y("\\@char with invalid code point " + a);
    return s <= 65535 ? u = String.fromCharCode(s) : (s -= 65536, u = String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320)), {
      type: "textord",
      mode: n.mode,
      text: u
    };
  }
});
var _4 = (e, t) => {
  var n = nt(e.body, t.withColor(e.color), !1);
  return D.makeFragment(n);
}, T4 = (e, t) => {
  var n = Dt(e.body, t.withColor(e.color)), r = new G.MathNode("mstyle", n);
  return r.setAttribute("mathcolor", e.color), r;
};
J({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = me(t[0], "color-token").color, i = t[1];
    return {
      type: "color",
      mode: n.mode,
      color: r,
      body: je(i)
    };
  },
  htmlBuilder: _4,
  mathmlBuilder: T4
});
J({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(e, t) {
    var {
      parser: n,
      breakOnTokenText: r
    } = e, i = me(t[0], "color-token").color;
    n.gullet.macros.set("\\current@color", i);
    var a = n.parseExpression(!0, r);
    return {
      type: "color",
      mode: n.mode,
      color: i,
      body: a
    };
  },
  htmlBuilder: _4,
  mathmlBuilder: T4
});
J({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, a = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: a,
      size: i && me(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(e, t) {
    var n = D.makeSpan(["mspace"], [], t);
    return e.newLine && (n.classes.push("newline"), e.size && (n.style.marginTop = X(Ue(e.size, t)))), n;
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mspace");
    return e.newLine && (n.setAttribute("linebreak", "newline"), e.size && n.setAttribute("height", X(Ue(e.size, t)))), n;
  }
});
var Du = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, N4 = (e) => {
  var t = e.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(t))
    throw new Y("Expected a control sequence", e);
  return t;
}, px = (e) => {
  var t = e.gullet.popToken();
  return t.text === "=" && (t = e.gullet.popToken(), t.text === " " && (t = e.gullet.popToken())), t;
}, A4 = (e, t, n, r) => {
  var i = e.gullet.macros.get(n.text);
  i == null && (n.noexpand = !0, i = {
    tokens: [n],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !e.gullet.isExpandable(n.text)
  }), e.gullet.macros.set(t, i, r);
};
J({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    t.consumeSpaces();
    var r = t.fetch();
    if (Du[r.text])
      return (n === "\\global" || n === "\\\\globallong") && (r.text = Du[r.text]), me(t.parseFunction(), "internal");
    throw new Y("Invalid token after macro prefix", r);
  }
});
J({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = t.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new Y("Expected a control sequence", r);
    for (var a = 0, l, o = [[]]; t.gullet.future().text !== "{"; )
      if (r = t.gullet.popToken(), r.text === "#") {
        if (t.gullet.future().text === "{") {
          l = t.gullet.future(), o[a].push("{");
          break;
        }
        if (r = t.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new Y('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== a + 1)
          throw new Y('Argument number "' + r.text + '" out of order');
        a++, o.push([]);
      } else {
        if (r.text === "EOF")
          throw new Y("Expected a macro definition");
        o[a].push(r.text);
      }
    var {
      tokens: s
    } = t.gullet.consumeArg();
    return l && s.unshift(l), (n === "\\edef" || n === "\\xdef") && (s = t.gullet.expandTokens(s), s.reverse()), t.gullet.macros.set(i, {
      tokens: s,
      numArgs: a,
      delimiters: o
    }, n === Du[n]), {
      type: "internal",
      mode: t.mode
    };
  }
});
J({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = N4(t.gullet.popToken());
    t.gullet.consumeSpaces();
    var i = px(t);
    return A4(t, r, i, n === "\\\\globallet"), {
      type: "internal",
      mode: t.mode
    };
  }
});
J({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = N4(t.gullet.popToken()), i = t.gullet.popToken(), a = t.gullet.popToken();
    return A4(t, r, a, n === "\\\\globalfuture"), t.gullet.pushToken(a), t.gullet.pushToken(i), {
      type: "internal",
      mode: t.mode
    };
  }
});
var ha = function(t, n, r) {
  var i = Ie.math[t] && Ie.math[t].replace, a = ed(i || t, n, r);
  if (!a)
    throw new Error("Unsupported symbol " + t + " and font size " + n + ".");
  return a;
}, od = function(t, n, r, i) {
  var a = r.havingBaseStyle(n), l = D.makeSpan(i.concat(a.sizingClasses(r)), [t], r), o = a.sizeMultiplier / r.sizeMultiplier;
  return l.height *= o, l.depth *= o, l.maxFontSize = a.sizeMultiplier, l;
}, C4 = function(t, n, r) {
  var i = n.havingBaseStyle(r), a = (1 - n.sizeMultiplier / i.sizeMultiplier) * n.fontMetrics().axisHeight;
  t.classes.push("delimcenter"), t.style.top = X(a), t.height -= a, t.depth += a;
}, mx = function(t, n, r, i, a, l) {
  var o = D.makeSymbol(t, "Main-Regular", a, i), s = od(o, n, i, l);
  return r && C4(s, i, n), s;
}, gx = function(t, n, r, i) {
  return D.makeSymbol(t, "Size" + n + "-Regular", r, i);
}, M4 = function(t, n, r, i, a, l) {
  var o = gx(t, n, a, i), s = od(D.makeSpan(["delimsizing", "size" + n], [o], i), ce.TEXT, i, l);
  return r && C4(s, i, ce.TEXT), s;
}, p0 = function(t, n, r) {
  var i;
  n === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var a = D.makeSpan(["delimsizinginner", i], [D.makeSpan([], [D.makeSymbol(t, n, r)])]);
  return {
    type: "elem",
    elem: a
  };
}, m0 = function(t, n, r) {
  var i = Tn["Size4-Regular"][t.charCodeAt(0)] ? Tn["Size4-Regular"][t.charCodeAt(0)][4] : Tn["Size1-Regular"][t.charCodeAt(0)][4], a = new Er("inner", kw(t, Math.round(1e3 * n))), l = new Yn([a], {
    width: X(i),
    height: X(n),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + X(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * n),
    preserveAspectRatio: "xMinYMin"
  }), o = D.makeSvgSpan([], [l], r);
  return o.height = n, o.style.height = X(n), o.style.width = X(i), {
    type: "elem",
    elem: o
  };
}, zu = 8e-3, Pl = {
  type: "kern",
  size: -1 * zu
}, vx = ["|", "\\lvert", "\\rvert", "\\vert"], yx = ["\\|", "\\lVert", "\\rVert", "\\Vert"], O4 = function(t, n, r, i, a, l) {
  var o, s, u, c, d = "", h = 0;
  o = u = c = t, s = null;
  var p = "Size1-Regular";
  t === "\\uparrow" ? u = c = "" : t === "\\Uparrow" ? u = c = "" : t === "\\downarrow" ? o = u = "" : t === "\\Downarrow" ? o = u = "" : t === "\\updownarrow" ? (o = "\\uparrow", u = "", c = "\\downarrow") : t === "\\Updownarrow" ? (o = "\\Uparrow", u = "", c = "\\Downarrow") : se.contains(vx, t) ? (u = "", d = "vert", h = 333) : se.contains(yx, t) ? (u = "", d = "doublevert", h = 556) : t === "[" || t === "\\lbrack" ? (o = "", u = "", c = "", p = "Size4-Regular", d = "lbrack", h = 667) : t === "]" || t === "\\rbrack" ? (o = "", u = "", c = "", p = "Size4-Regular", d = "rbrack", h = 667) : t === "\\lfloor" || t === "" ? (u = o = "", c = "", p = "Size4-Regular", d = "lfloor", h = 667) : t === "\\lceil" || t === "" ? (o = "", u = c = "", p = "Size4-Regular", d = "lceil", h = 667) : t === "\\rfloor" || t === "" ? (u = o = "", c = "", p = "Size4-Regular", d = "rfloor", h = 667) : t === "\\rceil" || t === "" ? (o = "", u = c = "", p = "Size4-Regular", d = "rceil", h = 667) : t === "(" || t === "\\lparen" ? (o = "", u = "", c = "", p = "Size4-Regular", d = "lparen", h = 875) : t === ")" || t === "\\rparen" ? (o = "", u = "", c = "", p = "Size4-Regular", d = "rparen", h = 875) : t === "\\{" || t === "\\lbrace" ? (o = "", s = "", c = "", u = "", p = "Size4-Regular") : t === "\\}" || t === "\\rbrace" ? (o = "", s = "", c = "", u = "", p = "Size4-Regular") : t === "\\lgroup" || t === "" ? (o = "", c = "", u = "", p = "Size4-Regular") : t === "\\rgroup" || t === "" ? (o = "", c = "", u = "", p = "Size4-Regular") : t === "\\lmoustache" || t === "" ? (o = "", c = "", u = "", p = "Size4-Regular") : (t === "\\rmoustache" || t === "") && (o = "", c = "", u = "", p = "Size4-Regular");
  var g = ha(o, p, a), w = g.height + g.depth, S = ha(u, p, a), y = S.height + S.depth, v = ha(c, p, a), x = v.height + v.depth, C = 0, R = 1;
  if (s !== null) {
    var T = ha(s, p, a);
    C = T.height + T.depth, R = 2;
  }
  var z = w + x + C, P = Math.max(0, Math.ceil((n - z) / (R * y))), U = z + P * R * y, O = i.fontMetrics().axisHeight;
  r && (O *= i.sizeMultiplier);
  var V = U / 2 - O, K = [];
  if (d.length > 0) {
    var ae = U - w - x, ie = Math.round(U * 1e3), re = Ew(d, Math.round(ae * 1e3)), ge = new Er(d, re), B = (h / 1e3).toFixed(3) + "em", I = (ie / 1e3).toFixed(3) + "em", $ = new Yn([ge], {
      width: B,
      height: I,
      viewBox: "0 0 " + h + " " + ie
    }), E = D.makeSvgSpan([], [$], i);
    E.height = ie / 1e3, E.style.width = B, E.style.height = I, K.push({
      type: "elem",
      elem: E
    });
  } else {
    if (K.push(p0(c, p, a)), K.push(Pl), s === null) {
      var Z = U - w - x + 2 * zu;
      K.push(m0(u, Z, i));
    } else {
      var ee = (U - w - x - C) / 2 + 2 * zu;
      K.push(m0(u, ee, i)), K.push(Pl), K.push(p0(s, p, a)), K.push(Pl), K.push(m0(u, ee, i));
    }
    K.push(Pl), K.push(p0(o, p, a));
  }
  var A = i.havingBaseStyle(ce.TEXT), Se = D.makeVList({
    positionType: "bottom",
    positionData: V,
    children: K
  }, A);
  return od(D.makeSpan(["delimsizing", "mult"], [Se], A), ce.TEXT, i, l);
}, g0 = 80, v0 = 0.08, y0 = function(t, n, r, i, a) {
  var l = xw(t, i, r), o = new Er(t, l), s = new Yn([o], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: X(n),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return D.makeSvgSpan(["hide-tail"], [s], a);
}, bx = function(t, n) {
  var r = n.havingBaseSizing(), i = z4("\\surd", t * r.sizeMultiplier, D4, r), a = r.sizeMultiplier, l = Math.max(0, n.minRuleThickness - n.fontMetrics().sqrtRuleThickness), o, s = 0, u = 0, c = 0, d;
  return i.type === "small" ? (c = 1e3 + 1e3 * l + g0, t < 1 ? a = 1 : t < 1.4 && (a = 0.7), s = (1 + l + v0) / a, u = (1 + l) / a, o = y0("sqrtMain", s, c, l, n), o.style.minWidth = "0.853em", d = 0.833 / a) : i.type === "large" ? (c = (1e3 + g0) * Ta[i.size], u = (Ta[i.size] + l) / a, s = (Ta[i.size] + l + v0) / a, o = y0("sqrtSize" + i.size, s, c, l, n), o.style.minWidth = "1.02em", d = 1 / a) : (s = t + l + v0, u = t + l, c = Math.floor(1e3 * t + l) + g0, o = y0("sqrtTall", s, c, l, n), o.style.minWidth = "0.742em", d = 1.056), o.height = u, o.style.height = X(s), {
    span: o,
    advanceWidth: d,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (n.fontMetrics().sqrtRuleThickness + l) * a
  };
}, R4 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"], wx = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""], I4 = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Ta = [0, 1.2, 1.8, 2.4, 3], xx = function(t, n, r, i, a) {
  if (t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle"), se.contains(R4, t) || se.contains(I4, t))
    return M4(t, n, !1, r, i, a);
  if (se.contains(wx, t))
    return O4(t, Ta[n], !1, r, i, a);
  throw new Y("Illegal delimiter: '" + t + "'");
}, kx = [{
  type: "small",
  style: ce.SCRIPTSCRIPT
}, {
  type: "small",
  style: ce.SCRIPT
}, {
  type: "small",
  style: ce.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], Ex = [{
  type: "small",
  style: ce.SCRIPTSCRIPT
}, {
  type: "small",
  style: ce.SCRIPT
}, {
  type: "small",
  style: ce.TEXT
}, {
  type: "stack"
}], D4 = [{
  type: "small",
  style: ce.SCRIPTSCRIPT
}, {
  type: "small",
  style: ce.SCRIPT
}, {
  type: "small",
  style: ce.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], Sx = function(t) {
  if (t.type === "small")
    return "Main-Regular";
  if (t.type === "large")
    return "Size" + t.size + "-Regular";
  if (t.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + t.type + "' here.");
}, z4 = function(t, n, r, i) {
  for (var a = Math.min(2, 3 - i.style.size), l = a; l < r.length && r[l].type !== "stack"; l++) {
    var o = ha(t, Sx(r[l]), "math"), s = o.height + o.depth;
    if (r[l].type === "small") {
      var u = i.havingBaseStyle(r[l].style);
      s *= u.sizeMultiplier;
    }
    if (s > n)
      return r[l];
  }
  return r[r.length - 1];
}, L4 = function(t, n, r, i, a, l) {
  t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle");
  var o;
  se.contains(I4, t) ? o = kx : se.contains(R4, t) ? o = D4 : o = Ex;
  var s = z4(t, n, o, i);
  return s.type === "small" ? mx(t, s.style, r, i, a, l) : s.type === "large" ? M4(t, s.size, r, i, a, l) : O4(t, n, r, i, a, l);
}, _x = function(t, n, r, i, a, l) {
  var o = i.fontMetrics().axisHeight * i.sizeMultiplier, s = 901, u = 5 / i.fontMetrics().ptPerEm, c = Math.max(n - o, r + o), d = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    c / 500 * s,
    2 * c - u
  );
  return L4(t, d, !0, i, a, l);
}, qn = {
  sqrtImage: bx,
  sizedDelim: xx,
  sizeToMaxHeight: Ta,
  customSizedDelim: L4,
  leftRightDelim: _x
}, Y1 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, Tx = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function vs(e, t) {
  var n = ms(e);
  if (n && se.contains(Tx, n.text))
    return n;
  throw n ? new Y("Invalid delimiter '" + n.text + "' after '" + t.funcName + "'", e) : new Y("Invalid delimiter type '" + e.type + "'", e);
}
J({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var n = vs(t[0], e);
    return {
      type: "delimsizing",
      mode: e.parser.mode,
      size: Y1[e.funcName].size,
      mclass: Y1[e.funcName].mclass,
      delim: n.text
    };
  },
  htmlBuilder: (e, t) => e.delim === "." ? D.makeSpan([e.mclass]) : qn.sizedDelim(e.delim, e.size, t, e.mode, [e.mclass]),
  mathmlBuilder: (e) => {
    var t = [];
    e.delim !== "." && t.push(an(e.delim, e.mode));
    var n = new G.MathNode("mo", t);
    e.mclass === "mopen" || e.mclass === "mclose" ? n.setAttribute("fence", "true") : n.setAttribute("fence", "false"), n.setAttribute("stretchy", "true");
    var r = X(qn.sizeToMaxHeight[e.size]);
    return n.setAttribute("minsize", r), n.setAttribute("maxsize", r), n;
  }
});
function j1(e) {
  if (!e.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
J({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = e.parser.gullet.macros.get("\\current@color");
    if (n && typeof n != "string")
      throw new Y("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: e.parser.mode,
      delim: vs(t[0], e).text,
      color: n
      // undefined if not set via \color
    };
  }
});
J({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = vs(t[0], e), r = e.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var a = me(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: n.text,
      right: a.delim,
      rightColor: a.color
    };
  },
  htmlBuilder: (e, t) => {
    j1(e);
    for (var n = nt(e.body, t, !0, ["mopen", "mclose"]), r = 0, i = 0, a = !1, l = 0; l < n.length; l++)
      n[l].isMiddle ? a = !0 : (r = Math.max(n[l].height, r), i = Math.max(n[l].depth, i));
    r *= t.sizeMultiplier, i *= t.sizeMultiplier;
    var o;
    if (e.left === "." ? o = Ya(t, ["mopen"]) : o = qn.leftRightDelim(e.left, r, i, t, e.mode, ["mopen"]), n.unshift(o), a)
      for (var s = 1; s < n.length; s++) {
        var u = n[s], c = u.isMiddle;
        c && (n[s] = qn.leftRightDelim(c.delim, r, i, c.options, e.mode, []));
      }
    var d;
    if (e.right === ".")
      d = Ya(t, ["mclose"]);
    else {
      var h = e.rightColor ? t.withColor(e.rightColor) : t;
      d = qn.leftRightDelim(e.right, r, i, h, e.mode, ["mclose"]);
    }
    return n.push(d), D.makeSpan(["minner"], n, t);
  },
  mathmlBuilder: (e, t) => {
    j1(e);
    var n = Dt(e.body, t);
    if (e.left !== ".") {
      var r = new G.MathNode("mo", [an(e.left, e.mode)]);
      r.setAttribute("fence", "true"), n.unshift(r);
    }
    if (e.right !== ".") {
      var i = new G.MathNode("mo", [an(e.right, e.mode)]);
      i.setAttribute("fence", "true"), e.rightColor && i.setAttribute("mathcolor", e.rightColor), n.push(i);
    }
    return rd(n);
  }
});
J({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = vs(t[0], e);
    if (!e.parser.leftrightDepth)
      throw new Y("\\middle without preceding \\left", n);
    return {
      type: "middle",
      mode: e.parser.mode,
      delim: n.text
    };
  },
  htmlBuilder: (e, t) => {
    var n;
    if (e.delim === ".")
      n = Ya(t, []);
    else {
      n = qn.sizedDelim(e.delim, 1, t, e.mode, []);
      var r = {
        delim: e.delim,
        options: t
      };
      n.isMiddle = r;
    }
    return n;
  },
  mathmlBuilder: (e, t) => {
    var n = e.delim === "\\vert" || e.delim === "|" ? an("|", "text") : an(e.delim, e.mode), r = new G.MathNode("mo", [n]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var sd = (e, t) => {
  var n = D.wrapFragment(Ee(e.body, t), t), r = e.label.slice(1), i = t.sizeMultiplier, a, l = 0, o = se.isCharacterBox(e.body);
  if (r === "sout")
    a = D.makeSpan(["stretchy", "sout"]), a.height = t.fontMetrics().defaultRuleThickness / i, l = -0.5 * t.fontMetrics().xHeight;
  else if (r === "phase") {
    var s = Ue({
      number: 0.6,
      unit: "pt"
    }, t), u = Ue({
      number: 0.35,
      unit: "ex"
    }, t), c = t.havingBaseSizing();
    i = i / c.sizeMultiplier;
    var d = n.height + n.depth + s + u;
    n.style.paddingLeft = X(d / 2 + s);
    var h = Math.floor(1e3 * d * i), p = bw(h), g = new Yn([new Er("phase", p)], {
      width: "400em",
      height: X(h / 1e3),
      viewBox: "0 0 400000 " + h,
      preserveAspectRatio: "xMinYMin slice"
    });
    a = D.makeSvgSpan(["hide-tail"], [g], t), a.style.height = X(d), l = n.depth + s + u;
  } else {
    /cancel/.test(r) ? o || n.classes.push("cancel-pad") : r === "angl" ? n.classes.push("anglpad") : n.classes.push("boxpad");
    var w = 0, S = 0, y = 0;
    /box/.test(r) ? (y = Math.max(
      t.fontMetrics().fboxrule,
      // default
      t.minRuleThickness
      // User override.
    ), w = t.fontMetrics().fboxsep + (r === "colorbox" ? 0 : y), S = w) : r === "angl" ? (y = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), w = 4 * y, S = Math.max(0, 0.25 - n.depth)) : (w = o ? 0.2 : 0, S = w), a = Xn.encloseSpan(n, r, w, S, t), /fbox|boxed|fcolorbox/.test(r) ? (a.style.borderStyle = "solid", a.style.borderWidth = X(y)) : r === "angl" && y !== 0.049 && (a.style.borderTopWidth = X(y), a.style.borderRightWidth = X(y)), l = n.depth + S, e.backgroundColor && (a.style.backgroundColor = e.backgroundColor, e.borderColor && (a.style.borderColor = e.borderColor));
  }
  var v;
  if (e.backgroundColor)
    v = D.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: a,
          shift: l
        },
        {
          type: "elem",
          elem: n,
          shift: 0
        }
      ]
    }, t);
  else {
    var x = /cancel|phase/.test(r) ? ["svg-align"] : [];
    v = D.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: n,
          shift: 0
        },
        {
          type: "elem",
          elem: a,
          shift: l,
          wrapperClasses: x
        }
      ]
    }, t);
  }
  return /cancel/.test(r) && (v.height = n.height, v.depth = n.depth), /cancel/.test(r) && !o ? D.makeSpan(["mord", "cancel-lap"], [v], t) : D.makeSpan(["mord"], [v], t);
}, ud = (e, t) => {
  var n = 0, r = new G.MathNode(e.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Me(e.body, t)]);
  switch (e.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (n = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * n + "pt"), r.setAttribute("height", "+" + 2 * n + "pt"), r.setAttribute("lspace", n + "pt"), r.setAttribute("voffset", n + "pt"), e.label === "\\fcolorbox") {
        var i = Math.max(
          t.fontMetrics().fboxrule,
          // default
          t.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(e.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return e.backgroundColor && r.setAttribute("mathbackground", e.backgroundColor), r;
};
J({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e, a = me(t[0], "color-token").color, l = t[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: a,
      body: l
    };
  },
  htmlBuilder: sd,
  mathmlBuilder: ud
});
J({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e, a = me(t[0], "color-token").color, l = me(t[1], "color-token").color, o = t[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: l,
      borderColor: a,
      body: o
    };
  },
  htmlBuilder: sd,
  mathmlBuilder: ud
});
J({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "enclose",
      mode: n.mode,
      label: "\\fbox",
      body: t[0]
    };
  }
});
J({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "enclose",
      mode: n.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: sd,
  mathmlBuilder: ud
});
J({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "enclose",
      mode: n.mode,
      label: "\\angl",
      body: t[0]
    };
  }
});
var P4 = {};
function Mn(e) {
  for (var {
    type: t,
    names: n,
    props: r,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: l
  } = e, o = {
    type: t,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, s = 0; s < n.length; ++s)
    P4[n[s]] = o;
  a && (Fo[t] = a), l && (Uo[t] = l);
}
var B4 = {};
function k(e, t) {
  B4[e] = t;
}
function X1(e) {
  var t = [];
  e.consumeSpaces();
  var n = e.fetch().text;
  for (n === "\\relax" && (e.consume(), e.consumeSpaces(), n = e.fetch().text); n === "\\hline" || n === "\\hdashline"; )
    e.consume(), t.push(n === "\\hdashline"), e.consumeSpaces(), n = e.fetch().text;
  return t;
}
var ys = (e) => {
  var t = e.parser.settings;
  if (!t.displayMode)
    throw new Y("{" + e.envName + "} can be used only in display mode.");
};
function cd(e) {
  if (e.indexOf("ed") === -1)
    return e.indexOf("*") === -1;
}
function Cr(e, t, n) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: a,
    arraystretch: l,
    colSeparationType: o,
    autoTag: s,
    singleRow: u,
    emptySingleRow: c,
    maxNumCols: d,
    leqno: h
  } = t;
  if (e.gullet.beginGroup(), u || e.gullet.macros.set("\\cr", "\\\\\\relax"), !l) {
    var p = e.gullet.expandMacroAsText("\\arraystretch");
    if (p == null)
      l = 1;
    else if (l = parseFloat(p), !l || l < 0)
      throw new Y("Invalid \\arraystretch: " + p);
  }
  e.gullet.beginGroup();
  var g = [], w = [g], S = [], y = [], v = s != null ? [] : void 0;
  function x() {
    s && e.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function C() {
    v && (e.gullet.macros.get("\\df@tag") ? (v.push(e.subparse([new en("\\df@tag")])), e.gullet.macros.set("\\df@tag", void 0, !0)) : v.push(!!s && e.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (x(), y.push(X1(e)); ; ) {
    var R = e.parseExpression(!1, u ? "\\end" : "\\\\");
    e.gullet.endGroup(), e.gullet.beginGroup(), R = {
      type: "ordgroup",
      mode: e.mode,
      body: R
    }, n && (R = {
      type: "styling",
      mode: e.mode,
      style: n,
      body: [R]
    }), g.push(R);
    var T = e.fetch().text;
    if (T === "&") {
      if (d && g.length === d) {
        if (u || o)
          throw new Y("Too many tab characters: &", e.nextToken);
        e.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      e.consume();
    } else if (T === "\\end") {
      C(), g.length === 1 && R.type === "styling" && R.body[0].body.length === 0 && (w.length > 1 || !c) && w.pop(), y.length < w.length + 1 && y.push([]);
      break;
    } else if (T === "\\\\") {
      e.consume();
      var z = void 0;
      e.gullet.future().text !== " " && (z = e.parseSizeGroup(!0)), S.push(z ? z.value : null), C(), y.push(X1(e)), g = [], w.push(g), x();
    } else
      throw new Y("Expected & or \\\\ or \\cr or \\end", e.nextToken);
  }
  return e.gullet.endGroup(), e.gullet.endGroup(), {
    type: "array",
    mode: e.mode,
    addJot: i,
    arraystretch: l,
    body: w,
    cols: a,
    rowGaps: S,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: y,
    colSeparationType: o,
    tags: v,
    leqno: h
  };
}
function dd(e) {
  return e.slice(0, 1) === "d" ? "display" : "text";
}
var On = function(t, n) {
  var r, i, a = t.body.length, l = t.hLinesBeforeRow, o = 0, s = new Array(a), u = [], c = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    n.fontMetrics().arrayRuleWidth,
    n.minRuleThickness
    // User override.
  ), d = 1 / n.fontMetrics().ptPerEm, h = 5 * d;
  if (t.colSeparationType && t.colSeparationType === "small") {
    var p = n.havingStyle(ce.SCRIPT).sizeMultiplier;
    h = 0.2778 * (p / n.sizeMultiplier);
  }
  var g = t.colSeparationType === "CD" ? Ue({
    number: 3,
    unit: "ex"
  }, n) : 12 * d, w = 3 * d, S = t.arraystretch * g, y = 0.7 * S, v = 0.3 * S, x = 0;
  function C(bn) {
    for (var de = 0; de < bn.length; ++de)
      de > 0 && (x += 0.25), u.push({
        pos: x,
        isDashed: bn[de]
      });
  }
  for (C(l[0]), r = 0; r < t.body.length; ++r) {
    var R = t.body[r], T = y, z = v;
    o < R.length && (o = R.length);
    var P = new Array(R.length);
    for (i = 0; i < R.length; ++i) {
      var U = Ee(R[i], n);
      z < U.depth && (z = U.depth), T < U.height && (T = U.height), P[i] = U;
    }
    var O = t.rowGaps[r], V = 0;
    O && (V = Ue(O, n), V > 0 && (V += v, z < V && (z = V), V = 0)), t.addJot && (z += w), P.height = T, P.depth = z, x += T, P.pos = x, x += z + V, s[r] = P, C(l[r + 1]);
  }
  var K = x / 2 + n.fontMetrics().axisHeight, ae = t.cols || [], ie = [], re, ge, B = [];
  if (t.tags && t.tags.some((bn) => bn))
    for (r = 0; r < a; ++r) {
      var I = s[r], $ = I.pos - K, E = t.tags[r], Z = void 0;
      E === !0 ? Z = D.makeSpan(["eqn-num"], [], n) : E === !1 ? Z = D.makeSpan([], [], n) : Z = D.makeSpan([], nt(E, n, !0), n), Z.depth = I.depth, Z.height = I.height, B.push({
        type: "elem",
        elem: Z,
        shift: $
      });
    }
  for (
    i = 0, ge = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < o || ge < ae.length;
    ++i, ++ge
  ) {
    for (var ee = ae[ge] || {}, A = !0; ee.type === "separator"; ) {
      if (A || (re = D.makeSpan(["arraycolsep"], []), re.style.width = X(n.fontMetrics().doubleRuleSep), ie.push(re)), ee.separator === "|" || ee.separator === ":") {
        var Se = ee.separator === "|" ? "solid" : "dashed", xe = D.makeSpan(["vertical-separator"], [], n);
        xe.style.height = X(x), xe.style.borderRightWidth = X(c), xe.style.borderRightStyle = Se, xe.style.margin = "0 " + X(-c / 2);
        var he = x - K;
        he && (xe.style.verticalAlign = X(-he)), ie.push(xe);
      } else
        throw new Y("Invalid separator type: " + ee.separator);
      ge++, ee = ae[ge] || {}, A = !1;
    }
    if (!(i >= o)) {
      var qe = void 0;
      (i > 0 || t.hskipBeforeAndAfter) && (qe = se.deflt(ee.pregap, h), qe !== 0 && (re = D.makeSpan(["arraycolsep"], []), re.style.width = X(qe), ie.push(re)));
      var Ke = [];
      for (r = 0; r < a; ++r) {
        var ut = s[r], gt = ut[i];
        if (gt) {
          var vn = ut.pos - K;
          gt.depth = ut.depth, gt.height = ut.height, Ke.push({
            type: "elem",
            elem: gt,
            shift: vn
          });
        }
      }
      Ke = D.makeVList({
        positionType: "individualShift",
        children: Ke
      }, n), Ke = D.makeSpan(["col-align-" + (ee.align || "c")], [Ke]), ie.push(Ke), (i < o - 1 || t.hskipBeforeAndAfter) && (qe = se.deflt(ee.postgap, h), qe !== 0 && (re = D.makeSpan(["arraycolsep"], []), re.style.width = X(qe), ie.push(re)));
    }
  }
  if (s = D.makeSpan(["mtable"], ie), u.length > 0) {
    for (var Mr = D.makeLineSpan("hline", n, c), Or = D.makeLineSpan("hdashline", n, c), ye = [{
      type: "elem",
      elem: s,
      shift: 0
    }]; u.length > 0; ) {
      var zt = u.pop(), Ge = zt.pos - K;
      zt.isDashed ? ye.push({
        type: "elem",
        elem: Or,
        shift: Ge
      }) : ye.push({
        type: "elem",
        elem: Mr,
        shift: Ge
      });
    }
    s = D.makeVList({
      positionType: "individualShift",
      children: ye
    }, n);
  }
  if (B.length === 0)
    return D.makeSpan(["mord"], [s], n);
  var yn = D.makeVList({
    positionType: "individualShift",
    children: B
  }, n);
  return yn = D.makeSpan(["tag"], [yn], n), D.makeFragment([s, yn]);
}, Nx = {
  c: "center ",
  l: "left ",
  r: "right "
}, Rn = function(t, n) {
  for (var r = [], i = new G.MathNode("mtd", [], ["mtr-glue"]), a = new G.MathNode("mtd", [], ["mml-eqn-num"]), l = 0; l < t.body.length; l++) {
    for (var o = t.body[l], s = [], u = 0; u < o.length; u++)
      s.push(new G.MathNode("mtd", [Me(o[u], n)]));
    t.tags && t.tags[l] && (s.unshift(i), s.push(i), t.leqno ? s.unshift(a) : s.push(a)), r.push(new G.MathNode("mtr", s));
  }
  var c = new G.MathNode("mtable", r), d = t.arraystretch === 0.5 ? 0.1 : 0.16 + t.arraystretch - 1 + (t.addJot ? 0.09 : 0);
  c.setAttribute("rowspacing", X(d));
  var h = "", p = "";
  if (t.cols && t.cols.length > 0) {
    var g = t.cols, w = "", S = !1, y = 0, v = g.length;
    g[0].type === "separator" && (h += "top ", y = 1), g[g.length - 1].type === "separator" && (h += "bottom ", v -= 1);
    for (var x = y; x < v; x++)
      g[x].type === "align" ? (p += Nx[g[x].align], S && (w += "none "), S = !0) : g[x].type === "separator" && S && (w += g[x].separator === "|" ? "solid " : "dashed ", S = !1);
    c.setAttribute("columnalign", p.trim()), /[sd]/.test(w) && c.setAttribute("columnlines", w.trim());
  }
  if (t.colSeparationType === "align") {
    for (var C = t.cols || [], R = "", T = 1; T < C.length; T++)
      R += T % 2 ? "0em " : "1em ";
    c.setAttribute("columnspacing", R.trim());
  } else t.colSeparationType === "alignat" || t.colSeparationType === "gather" ? c.setAttribute("columnspacing", "0em") : t.colSeparationType === "small" ? c.setAttribute("columnspacing", "0.2778em") : t.colSeparationType === "CD" ? c.setAttribute("columnspacing", "0.5em") : c.setAttribute("columnspacing", "1em");
  var z = "", P = t.hLinesBeforeRow;
  h += P[0].length > 0 ? "left " : "", h += P[P.length - 1].length > 0 ? "right " : "";
  for (var U = 1; U < P.length - 1; U++)
    z += P[U].length === 0 ? "none " : P[U][0] ? "dashed " : "solid ";
  return /[sd]/.test(z) && c.setAttribute("rowlines", z.trim()), h !== "" && (c = new G.MathNode("menclose", [c]), c.setAttribute("notation", h.trim())), t.arraystretch && t.arraystretch < 1 && (c = new G.MathNode("mstyle", [c]), c.setAttribute("scriptlevel", "1")), c;
}, F4 = function(t, n) {
  t.envName.indexOf("ed") === -1 && ys(t);
  var r = [], i = t.envName.indexOf("at") > -1 ? "alignat" : "align", a = t.envName === "split", l = Cr(t.parser, {
    cols: r,
    addJot: !0,
    autoTag: a ? void 0 : cd(t.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: a ? 2 : void 0,
    leqno: t.parser.settings.leqno
  }, "display"), o, s = 0, u = {
    type: "ordgroup",
    mode: t.mode,
    body: []
  };
  if (n[0] && n[0].type === "ordgroup") {
    for (var c = "", d = 0; d < n[0].body.length; d++) {
      var h = me(n[0].body[d], "textord");
      c += h.text;
    }
    o = Number(c), s = o * 2;
  }
  var p = !s;
  l.body.forEach(function(y) {
    for (var v = 1; v < y.length; v += 2) {
      var x = me(y[v], "styling"), C = me(x.body[0], "ordgroup");
      C.body.unshift(u);
    }
    if (p)
      s < y.length && (s = y.length);
    else {
      var R = y.length / 2;
      if (o < R)
        throw new Y("Too many math in a row: " + ("expected " + o + ", but got " + R), y[0]);
    }
  });
  for (var g = 0; g < s; ++g) {
    var w = "r", S = 0;
    g % 2 === 1 ? w = "l" : g > 0 && p && (S = 1), r[g] = {
      type: "align",
      align: w,
      pregap: S,
      postgap: 0
    };
  }
  return l.colSeparationType = p ? "align" : "alignat", l;
};
Mn({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var n = ms(t[0]), r = n ? [t[0]] : me(t[0], "ordgroup").body, i = r.map(function(l) {
      var o = ad(l), s = o.text;
      if ("lcr".indexOf(s) !== -1)
        return {
          type: "align",
          align: s
        };
      if (s === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (s === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new Y("Unknown column alignment: " + s, l);
    }), a = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return Cr(e.parser, a, dd(e.envName));
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[e.envName.replace("*", "")], n = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: n
      }]
    };
    if (e.envName.charAt(e.envName.length - 1) === "*") {
      var i = e.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), n = i.fetch().text, "lcr".indexOf(n) === -1)
          throw new Y("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: n
        }];
      }
    }
    var a = Cr(e.parser, r, dd(e.envName)), l = Math.max(0, ...a.body.map((o) => o.length));
    return a.cols = new Array(l).fill({
      type: "align",
      align: n
    }), t ? {
      type: "leftright",
      mode: e.mode,
      body: [a],
      left: t[0],
      right: t[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : a;
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 0.5
    }, n = Cr(e.parser, t, "script");
    return n.colSeparationType = "small", n;
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var n = ms(t[0]), r = n ? [t[0]] : me(t[0], "ordgroup").body, i = r.map(function(l) {
      var o = ad(l), s = o.text;
      if ("lc".indexOf(s) !== -1)
        return {
          type: "align",
          align: s
        };
      throw new Y("Unknown column alignment: " + s, l);
    });
    if (i.length > 1)
      throw new Y("{subarray} can contain only one column");
    var a = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (a = Cr(e.parser, a, "script"), a.body.length > 0 && a.body[0].length > 1)
      throw new Y("{subarray} can contain only one column");
    return a;
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, n = Cr(e.parser, t, dd(e.envName));
    return {
      type: "leftright",
      mode: e.mode,
      body: [n],
      left: e.envName.indexOf("r") > -1 ? "." : "\\{",
      right: e.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: F4,
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    se.contains(["gather", "gather*"], e.envName) && ys(e);
    var t = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: cd(e.envName),
      emptySingleRow: !0,
      leqno: e.parser.settings.leqno
    };
    return Cr(e.parser, t, "display");
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: F4,
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    ys(e);
    var t = {
      autoTag: cd(e.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: e.parser.settings.leqno
    };
    return Cr(e.parser, t, "display");
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
Mn({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(e) {
    return ys(e), hx(e.parser);
  },
  htmlBuilder: On,
  mathmlBuilder: Rn
});
k("\\nonumber", "\\gdef\\@eqnsw{0}");
k("\\notag", "\\nonumber");
J({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(e, t) {
    throw new Y(e.funcName + " valid only within array environment");
  }
});
var Z1 = P4;
J({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    if (i.type !== "ordgroup")
      throw new Y("Invalid environment name", i);
    for (var a = "", l = 0; l < i.body.length; ++l)
      a += me(i.body[l], "textord").text;
    if (r === "\\begin") {
      if (!Z1.hasOwnProperty(a))
        throw new Y("No such environment: " + a, i);
      var o = Z1[a], {
        args: s,
        optArgs: u
      } = n.parseArguments("\\begin{" + a + "}", o), c = {
        mode: n.mode,
        envName: a,
        parser: n
      }, d = o.handler(c, s, u);
      n.expect("\\end", !1);
      var h = n.nextToken, p = me(n.parseFunction(), "environment");
      if (p.name !== a)
        throw new Y("Mismatch: \\begin{" + a + "} matched by \\end{" + p.name + "}", h);
      return d;
    }
    return {
      type: "environment",
      mode: n.mode,
      name: a,
      nameGroup: i
    };
  }
});
var U4 = (e, t) => {
  var n = e.font, r = t.withFont(n);
  return Ee(e.body, r);
}, $4 = (e, t) => {
  var n = e.font, r = t.withFont(n);
  return Me(e.body, r);
}, Q1 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
J({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = $o(t[0]), a = r;
    return a in Q1 && (a = Q1[a]), {
      type: "font",
      mode: n.mode,
      font: a.slice(1),
      body: i
    };
  },
  htmlBuilder: U4,
  mathmlBuilder: $4
});
J({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0], i = se.isCharacterBox(r);
    return {
      type: "mclass",
      mode: n.mode,
      mclass: gs(r),
      body: [{
        type: "font",
        mode: n.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
J({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r,
      breakOnTokenText: i
    } = e, {
      mode: a
    } = n, l = n.parseExpression(!0, i), o = "math" + r.slice(1);
    return {
      type: "font",
      mode: a,
      font: o,
      body: {
        type: "ordgroup",
        mode: n.mode,
        body: l
      }
    };
  },
  htmlBuilder: U4,
  mathmlBuilder: $4
});
var H4 = (e, t) => {
  var n = t;
  return e === "display" ? n = n.id >= ce.SCRIPT.id ? n.text() : ce.DISPLAY : e === "text" && n.size === ce.DISPLAY.size ? n = ce.TEXT : e === "script" ? n = ce.SCRIPT : e === "scriptscript" && (n = ce.SCRIPTSCRIPT), n;
}, fd = (e, t) => {
  var n = H4(e.size, t.style), r = n.fracNum(), i = n.fracDen(), a;
  a = t.havingStyle(r);
  var l = Ee(e.numer, a, t);
  if (e.continued) {
    var o = 8.5 / t.fontMetrics().ptPerEm, s = 3.5 / t.fontMetrics().ptPerEm;
    l.height = l.height < o ? o : l.height, l.depth = l.depth < s ? s : l.depth;
  }
  a = t.havingStyle(i);
  var u = Ee(e.denom, a, t), c, d, h;
  e.hasBarLine ? (e.barSize ? (d = Ue(e.barSize, t), c = D.makeLineSpan("frac-line", t, d)) : c = D.makeLineSpan("frac-line", t), d = c.height, h = c.height) : (c = null, d = 0, h = t.fontMetrics().defaultRuleThickness);
  var p, g, w;
  n.size === ce.DISPLAY.size || e.size === "display" ? (p = t.fontMetrics().num1, d > 0 ? g = 3 * h : g = 7 * h, w = t.fontMetrics().denom1) : (d > 0 ? (p = t.fontMetrics().num2, g = h) : (p = t.fontMetrics().num3, g = 3 * h), w = t.fontMetrics().denom2);
  var S;
  if (c) {
    var v = t.fontMetrics().axisHeight;
    p - l.depth - (v + 0.5 * d) < g && (p += g - (p - l.depth - (v + 0.5 * d))), v - 0.5 * d - (u.height - w) < g && (w += g - (v - 0.5 * d - (u.height - w)));
    var x = -(v - 0.5 * d);
    S = D.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: w
      }, {
        type: "elem",
        elem: c,
        shift: x
      }, {
        type: "elem",
        elem: l,
        shift: -p
      }]
    }, t);
  } else {
    var y = p - l.depth - (u.height - w);
    y < g && (p += 0.5 * (g - y), w += 0.5 * (g - y)), S = D.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: w
      }, {
        type: "elem",
        elem: l,
        shift: -p
      }]
    }, t);
  }
  a = t.havingStyle(n), S.height *= a.sizeMultiplier / t.sizeMultiplier, S.depth *= a.sizeMultiplier / t.sizeMultiplier;
  var C;
  n.size === ce.DISPLAY.size ? C = t.fontMetrics().delim1 : n.size === ce.SCRIPTSCRIPT.size ? C = t.havingStyle(ce.SCRIPT).fontMetrics().delim2 : C = t.fontMetrics().delim2;
  var R, T;
  return e.leftDelim == null ? R = Ya(t, ["mopen"]) : R = qn.customSizedDelim(e.leftDelim, C, !0, t.havingStyle(n), e.mode, ["mopen"]), e.continued ? T = D.makeSpan([]) : e.rightDelim == null ? T = Ya(t, ["mclose"]) : T = qn.customSizedDelim(e.rightDelim, C, !0, t.havingStyle(n), e.mode, ["mclose"]), D.makeSpan(["mord"].concat(a.sizingClasses(t)), [R, D.makeSpan(["mfrac"], [S]), T], t);
}, hd = (e, t) => {
  var n = new G.MathNode("mfrac", [Me(e.numer, t), Me(e.denom, t)]);
  if (!e.hasBarLine)
    n.setAttribute("linethickness", "0px");
  else if (e.barSize) {
    var r = Ue(e.barSize, t);
    n.setAttribute("linethickness", X(r));
  }
  var i = H4(e.size, t.style);
  if (i.size !== t.style.size) {
    n = new G.MathNode("mstyle", [n]);
    var a = i.size === ce.DISPLAY.size ? "true" : "false";
    n.setAttribute("displaystyle", a), n.setAttribute("scriptlevel", "0");
  }
  if (e.leftDelim != null || e.rightDelim != null) {
    var l = [];
    if (e.leftDelim != null) {
      var o = new G.MathNode("mo", [new G.TextNode(e.leftDelim.replace("\\", ""))]);
      o.setAttribute("fence", "true"), l.push(o);
    }
    if (l.push(n), e.rightDelim != null) {
      var s = new G.MathNode("mo", [new G.TextNode(e.rightDelim.replace("\\", ""))]);
      s.setAttribute("fence", "true"), l.push(s);
    }
    return rd(l);
  }
  return n;
};
J({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = t[1], l, o = null, s = null, u = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        l = !0;
        break;
      case "\\\\atopfrac":
        l = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        l = !1, o = "(", s = ")";
        break;
      case "\\\\bracefrac":
        l = !1, o = "\\{", s = "\\}";
        break;
      case "\\\\brackfrac":
        l = !1, o = "[", s = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: n.mode,
      continued: !1,
      numer: i,
      denom: a,
      hasBarLine: l,
      leftDelim: o,
      rightDelim: s,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: fd,
  mathmlBuilder: hd
});
J({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = t[1];
    return {
      type: "genfrac",
      mode: n.mode,
      continued: !0,
      numer: i,
      denom: a,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
J({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n,
      token: r
    } = e, i;
    switch (n) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: i,
      token: r
    };
  }
});
var J1 = ["display", "text", "script", "scriptscript"], eh = function(t) {
  var n = null;
  return t.length > 0 && (n = t, n = n === "." ? null : n), n;
};
J({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = t[4], i = t[5], a = $o(t[0]), l = a.type === "atom" && a.family === "open" ? eh(a.text) : null, o = $o(t[1]), s = o.type === "atom" && o.family === "close" ? eh(o.text) : null, u = me(t[2], "size"), c, d = null;
    u.isBlank ? c = !0 : (d = u.value, c = d.number > 0);
    var h = "auto", p = t[3];
    if (p.type === "ordgroup") {
      if (p.body.length > 0) {
        var g = me(p.body[0], "textord");
        h = J1[Number(g.text)];
      }
    } else
      p = me(p, "textord"), h = J1[Number(p.text)];
    return {
      type: "genfrac",
      mode: n.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: c,
      barSize: d,
      leftDelim: l,
      rightDelim: s,
      size: h
    };
  },
  htmlBuilder: fd,
  mathmlBuilder: hd
});
J({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r,
      token: i
    } = e;
    return {
      type: "infix",
      mode: n.mode,
      replaceWith: "\\\\abovefrac",
      size: me(t[0], "size").value,
      token: i
    };
  }
});
J({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = iw(me(t[1], "infix").size), l = t[2], o = a.number > 0;
    return {
      type: "genfrac",
      mode: n.mode,
      numer: i,
      denom: l,
      continued: !1,
      hasBarLine: o,
      barSize: a,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: fd,
  mathmlBuilder: hd
});
var q4 = (e, t) => {
  var n = t.style, r, i;
  e.type === "supsub" ? (r = e.sup ? Ee(e.sup, t.havingStyle(n.sup()), t) : Ee(e.sub, t.havingStyle(n.sub()), t), i = me(e.base, "horizBrace")) : i = me(e, "horizBrace");
  var a = Ee(i.base, t.havingBaseStyle(ce.DISPLAY)), l = Xn.svgSpan(i, t), o;
  if (i.isOver ? (o = D.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: a
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: l
    }]
  }, t), o.children[0].children[0].children[1].classes.push("svg-align")) : (o = D.makeVList({
    positionType: "bottom",
    positionData: a.depth + 0.1 + l.height,
    children: [{
      type: "elem",
      elem: l
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: a
    }]
  }, t), o.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var s = D.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], t);
    i.isOver ? o = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, t) : o = D.makeVList({
      positionType: "bottom",
      positionData: s.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: s
      }]
    }, t);
  }
  return D.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], t);
}, Ax = (e, t) => {
  var n = Xn.mathMLnode(e.label);
  return new G.MathNode(e.isOver ? "mover" : "munder", [Me(e.base, t), n]);
};
J({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e;
    return {
      type: "horizBrace",
      mode: n.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: t[0]
    };
  },
  htmlBuilder: q4,
  mathmlBuilder: Ax
});
J({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[1], i = me(t[0], "url").url;
    return n.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: n.mode,
      href: i,
      body: je(r)
    } : n.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (e, t) => {
    var n = nt(e.body, t, !1);
    return D.makeAnchor(e.href, [], n, t);
  },
  mathmlBuilder: (e, t) => {
    var n = Sr(e.body, t);
    return n instanceof Xt || (n = new Xt("mrow", [n])), n.setAttribute("href", e.href), n;
  }
});
J({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = me(t[0], "url").url;
    if (!n.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return n.formatUnsupportedCmd("\\url");
    for (var i = [], a = 0; a < r.length; a++) {
      var l = r[a];
      l === "~" && (l = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: l
      });
    }
    var o = {
      type: "text",
      mode: n.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: n.mode,
      href: r,
      body: je(o)
    };
  }
});
J({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "hbox",
      mode: n.mode,
      body: je(t[0])
    };
  },
  htmlBuilder(e, t) {
    var n = nt(e.body, t, !1);
    return D.makeFragment(n);
  },
  mathmlBuilder(e, t) {
    return new G.MathNode("mrow", Dt(e.body, t));
  }
});
J({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r,
      token: i
    } = e, a = me(t[0], "raw").string, l = t[1];
    n.settings.strict && n.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var o, s = {};
    switch (r) {
      case "\\htmlClass":
        s.class = a, o = {
          command: "\\htmlClass",
          class: a
        };
        break;
      case "\\htmlId":
        s.id = a, o = {
          command: "\\htmlId",
          id: a
        };
        break;
      case "\\htmlStyle":
        s.style = a, o = {
          command: "\\htmlStyle",
          style: a
        };
        break;
      case "\\htmlData": {
        for (var u = a.split(","), c = 0; c < u.length; c++) {
          var d = u[c].split("=");
          if (d.length !== 2)
            throw new Y("Error parsing key-value for \\htmlData");
          s["data-" + d[0].trim()] = d[1].trim();
        }
        o = {
          command: "\\htmlData",
          attributes: s
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return n.settings.isTrusted(o) ? {
      type: "html",
      mode: n.mode,
      attributes: s,
      body: je(l)
    } : n.formatUnsupportedCmd(r);
  },
  htmlBuilder: (e, t) => {
    var n = nt(e.body, t, !1), r = ["enclosing"];
    e.attributes.class && r.push(...e.attributes.class.trim().split(/\s+/));
    var i = D.makeSpan(r, n, t);
    for (var a in e.attributes)
      a !== "class" && e.attributes.hasOwnProperty(a) && i.setAttribute(a, e.attributes[a]);
    return i;
  },
  mathmlBuilder: (e, t) => Sr(e.body, t)
});
J({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e;
    return {
      type: "htmlmathml",
      mode: n.mode,
      html: je(t[0]),
      mathml: je(t[1])
    };
  },
  htmlBuilder: (e, t) => {
    var n = nt(e.html, t, !1);
    return D.makeFragment(n);
  },
  mathmlBuilder: (e, t) => Sr(e.mathml, t)
});
var b0 = function(t) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(t))
    return {
      number: +t,
      unit: "bp"
    };
  var n = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t);
  if (!n)
    throw new Y("Invalid size: '" + t + "' in \\includegraphics");
  var r = {
    number: +(n[1] + n[2]),
    // sign + magnitude, cast to number
    unit: n[3]
  };
  if (!s4(r))
    throw new Y("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
J({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (e, t, n) => {
    var {
      parser: r
    } = e, i = {
      number: 0,
      unit: "em"
    }, a = {
      number: 0.9,
      unit: "em"
    }, l = {
      number: 0,
      unit: "em"
    }, o = "";
    if (n[0])
      for (var s = me(n[0], "raw").string, u = s.split(","), c = 0; c < u.length; c++) {
        var d = u[c].split("=");
        if (d.length === 2) {
          var h = d[1].trim();
          switch (d[0].trim()) {
            case "alt":
              o = h;
              break;
            case "width":
              i = b0(h);
              break;
            case "height":
              a = b0(h);
              break;
            case "totalheight":
              l = b0(h);
              break;
            default:
              throw new Y("Invalid key: '" + d[0] + "' in \\includegraphics.");
          }
        }
      }
    var p = me(t[0], "url").url;
    return o === "" && (o = p, o = o.replace(/^.*[\\/]/, ""), o = o.substring(0, o.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: p
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: o,
      width: i,
      height: a,
      totalheight: l,
      src: p
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (e, t) => {
    var n = Ue(e.height, t), r = 0;
    e.totalheight.number > 0 && (r = Ue(e.totalheight, t) - n);
    var i = 0;
    e.width.number > 0 && (i = Ue(e.width, t));
    var a = {
      height: X(n + r)
    };
    i > 0 && (a.width = X(i)), r > 0 && (a.verticalAlign = X(-r));
    var l = new Aw(e.src, e.alt, a);
    return l.height = n, l.depth = r, l;
  },
  mathmlBuilder: (e, t) => {
    var n = new G.MathNode("mglyph", []);
    n.setAttribute("alt", e.alt);
    var r = Ue(e.height, t), i = 0;
    if (e.totalheight.number > 0 && (i = Ue(e.totalheight, t) - r, n.setAttribute("valign", X(-i))), n.setAttribute("height", X(r + i)), e.width.number > 0) {
      var a = Ue(e.width, t);
      n.setAttribute("width", X(a));
    }
    return n.setAttribute("src", e.src), n;
  }
});
J({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = me(t[0], "size");
    if (n.settings.strict) {
      var a = r[1] === "m", l = i.value.unit === "mu";
      a ? (l || n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), n.mode !== "math" && n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : l && n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: n.mode,
      dimension: i.value
    };
  },
  htmlBuilder(e, t) {
    return D.makeGlue(e.dimension, t);
  },
  mathmlBuilder(e, t) {
    var n = Ue(e.dimension, t);
    return new G.SpaceNode(n);
  }
});
J({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "lap",
      mode: n.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (e, t) => {
    var n;
    e.alignment === "clap" ? (n = D.makeSpan([], [Ee(e.body, t)]), n = D.makeSpan(["inner"], [n], t)) : n = D.makeSpan(["inner"], [Ee(e.body, t)]);
    var r = D.makeSpan(["fix"], []), i = D.makeSpan([e.alignment], [n, r], t), a = D.makeSpan(["strut"]);
    return a.style.height = X(i.height + i.depth), i.depth && (a.style.verticalAlign = X(-i.depth)), i.children.unshift(a), i = D.makeSpan(["thinbox"], [i], t), D.makeSpan(["mord", "vbox"], [i], t);
  },
  mathmlBuilder: (e, t) => {
    var n = new G.MathNode("mpadded", [Me(e.body, t)]);
    if (e.alignment !== "rlap") {
      var r = e.alignment === "llap" ? "-1" : "-0.5";
      n.setAttribute("lspace", r + "width");
    }
    return n.setAttribute("width", "0px"), n;
  }
});
J({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    var {
      funcName: n,
      parser: r
    } = e, i = r.mode;
    r.switchMode("math");
    var a = n === "\\(" ? "\\)" : "$", l = r.parseExpression(!1, a);
    return r.expect(a), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: l
    };
  }
});
J({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    throw new Y("Mismatched " + e.funcName);
  }
});
var th = (e, t) => {
  switch (t.style.size) {
    case ce.DISPLAY.size:
      return e.display;
    case ce.TEXT.size:
      return e.text;
    case ce.SCRIPT.size:
      return e.script;
    case ce.SCRIPTSCRIPT.size:
      return e.scriptscript;
    default:
      return e.text;
  }
};
J({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e;
    return {
      type: "mathchoice",
      mode: n.mode,
      display: je(t[0]),
      text: je(t[1]),
      script: je(t[2]),
      scriptscript: je(t[3])
    };
  },
  htmlBuilder: (e, t) => {
    var n = th(e, t), r = nt(n, t, !1);
    return D.makeFragment(r);
  },
  mathmlBuilder: (e, t) => {
    var n = th(e, t);
    return Sr(n, t);
  }
});
var G4 = (e, t, n, r, i, a, l) => {
  e = D.makeSpan([], [e]);
  var o = n && se.isCharacterBox(n), s, u;
  if (t) {
    var c = Ee(t, r.havingStyle(i.sup()), r);
    u = {
      elem: c,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - c.depth)
    };
  }
  if (n) {
    var d = Ee(n, r.havingStyle(i.sub()), r);
    s = {
      elem: d,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - d.height)
    };
  }
  var h;
  if (u && s) {
    var p = r.fontMetrics().bigOpSpacing5 + s.elem.height + s.elem.depth + s.kern + e.depth + l;
    h = D.makeVList({
      positionType: "bottom",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: s.elem,
        marginLeft: X(-a)
      }, {
        type: "kern",
        size: s.kern
      }, {
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: X(a)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (s) {
    var g = e.height - l;
    h = D.makeVList({
      positionType: "top",
      positionData: g,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: s.elem,
        marginLeft: X(-a)
      }, {
        type: "kern",
        size: s.kern
      }, {
        type: "elem",
        elem: e
      }]
    }, r);
  } else if (u) {
    var w = e.depth + l;
    h = D.makeVList({
      positionType: "bottom",
      positionData: w,
      children: [{
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: X(a)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return e;
  var S = [h];
  if (s && a !== 0 && !o) {
    var y = D.makeSpan(["mspace"], [], r);
    y.style.marginRight = X(a), S.unshift(y);
  }
  return D.makeSpan(["mop", "op-limits"], S, r);
}, V4 = ["\\smallint"], Yi = (e, t) => {
  var n, r, i = !1, a;
  e.type === "supsub" ? (n = e.sup, r = e.sub, a = me(e.base, "op"), i = !0) : a = me(e, "op");
  var l = t.style, o = !1;
  l.size === ce.DISPLAY.size && a.symbol && !se.contains(V4, a.name) && (o = !0);
  var s;
  if (a.symbol) {
    var u = o ? "Size2-Regular" : "Size1-Regular", c = "";
    if ((a.name === "\\oiint" || a.name === "\\oiiint") && (c = a.name.slice(1), a.name = c === "oiint" ? "\\iint" : "\\iiint"), s = D.makeSymbol(a.name, u, "math", t, ["mop", "op-symbol", o ? "large-op" : "small-op"]), c.length > 0) {
      var d = s.italic, h = D.staticSvg(c + "Size" + (o ? "2" : "1"), t);
      s = D.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: s,
          shift: 0
        }, {
          type: "elem",
          elem: h,
          shift: o ? 0.08 : 0
        }]
      }, t), a.name = "\\" + c, s.classes.unshift("mop"), s.italic = d;
    }
  } else if (a.body) {
    var p = nt(a.body, t, !0);
    p.length === 1 && p[0] instanceof rn ? (s = p[0], s.classes[0] = "mop") : s = D.makeSpan(["mop"], p, t);
  } else {
    for (var g = [], w = 1; w < a.name.length; w++)
      g.push(D.mathsym(a.name[w], a.mode, t));
    s = D.makeSpan(["mop"], g, t);
  }
  var S = 0, y = 0;
  return (s instanceof rn || a.name === "\\oiint" || a.name === "\\oiiint") && !a.suppressBaseShift && (S = (s.height - s.depth) / 2 - t.fontMetrics().axisHeight, y = s.italic), i ? G4(s, n, r, t, l, y, S) : (S && (s.style.position = "relative", s.style.top = X(S)), s);
}, sl = (e, t) => {
  var n;
  if (e.symbol)
    n = new Xt("mo", [an(e.name, e.mode)]), se.contains(V4, e.name) && n.setAttribute("largeop", "false");
  else if (e.body)
    n = new Xt("mo", Dt(e.body, t));
  else {
    n = new Xt("mi", [new _a(e.name.slice(1))]);
    var r = new Xt("mo", [an("", "text")]);
    e.parentIsSupSub ? n = new Xt("mrow", [n, r]) : n = b4([n, r]);
  }
  return n;
}, Cx = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
J({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = r;
    return i.length === 1 && (i = Cx[i]), {
      type: "op",
      mode: n.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: Yi,
  mathmlBuilder: sl
});
J({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "op",
      mode: n.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: je(r)
    };
  },
  htmlBuilder: Yi,
  mathmlBuilder: sl
});
var Mx = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
J({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: n
    };
  },
  htmlBuilder: Yi,
  mathmlBuilder: sl
});
J({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: n
    };
  },
  htmlBuilder: Yi,
  mathmlBuilder: sl
});
J({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = n;
    return r.length === 1 && (r = Mx[r]), {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: Yi,
  mathmlBuilder: sl
});
var W4 = (e, t) => {
  var n, r, i = !1, a;
  e.type === "supsub" ? (n = e.sup, r = e.sub, a = me(e.base, "operatorname"), i = !0) : a = me(e, "operatorname");
  var l;
  if (a.body.length > 0) {
    for (var o = a.body.map((d) => {
      var h = d.text;
      return typeof h == "string" ? {
        type: "textord",
        mode: d.mode,
        text: h
      } : d;
    }), s = nt(o, t.withFont("mathrm"), !0), u = 0; u < s.length; u++) {
      var c = s[u];
      c instanceof rn && (c.text = c.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    l = D.makeSpan(["mop"], s, t);
  } else
    l = D.makeSpan(["mop"], [], t);
  return i ? G4(l, n, r, t, t.style, 0, 0) : l;
}, Ox = (e, t) => {
  for (var n = Dt(e.body, t.withFont("mathrm")), r = !0, i = 0; i < n.length; i++) {
    var a = n[i];
    if (!(a instanceof G.SpaceNode)) if (a instanceof G.MathNode)
      switch (a.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var l = a.children[0];
          a.children.length === 1 && l instanceof G.TextNode ? l.text = l.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var o = n.map((c) => c.toText()).join("");
    n = [new G.TextNode(o)];
  }
  var s = new G.MathNode("mi", n);
  s.setAttribute("mathvariant", "normal");
  var u = new G.MathNode("mo", [an("", "text")]);
  return e.parentIsSupSub ? new G.MathNode("mrow", [s, u]) : G.newDocumentFragment([s, u]);
};
J({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "operatorname",
      mode: n.mode,
      body: je(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: W4,
  mathmlBuilder: Ox
});
k("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
ei({
  type: "ordgroup",
  htmlBuilder(e, t) {
    return e.semisimple ? D.makeFragment(nt(e.body, t, !1)) : D.makeSpan(["mord"], nt(e.body, t, !0), t);
  },
  mathmlBuilder(e, t) {
    return Sr(e.body, t, !0);
  }
});
J({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "overline",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder(e, t) {
    var n = Ee(e.body, t.havingCrampedStyle()), r = D.makeLineSpan("overline-line", t), i = t.fontMetrics().defaultRuleThickness, a = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, t);
    return D.makeSpan(["mord", "overline"], [a], t);
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mo", [new G.TextNode("")]);
    n.setAttribute("stretchy", "true");
    var r = new G.MathNode("mover", [Me(e.body, t), n]);
    return r.setAttribute("accent", "true"), r;
  }
});
J({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "phantom",
      mode: n.mode,
      body: je(r)
    };
  },
  htmlBuilder: (e, t) => {
    var n = nt(e.body, t.withPhantom(), !1);
    return D.makeFragment(n);
  },
  mathmlBuilder: (e, t) => {
    var n = Dt(e.body, t);
    return new G.MathNode("mphantom", n);
  }
});
J({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "hphantom",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var n = D.makeSpan([], [Ee(e.body, t.withPhantom())]);
    if (n.height = 0, n.depth = 0, n.children)
      for (var r = 0; r < n.children.length; r++)
        n.children[r].height = 0, n.children[r].depth = 0;
    return n = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }]
    }, t), D.makeSpan(["mord"], [n], t);
  },
  mathmlBuilder: (e, t) => {
    var n = Dt(je(e.body), t), r = new G.MathNode("mphantom", n), i = new G.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
J({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "vphantom",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var n = D.makeSpan(["inner"], [Ee(e.body, t.withPhantom())]), r = D.makeSpan(["fix"], []);
    return D.makeSpan(["mord", "rlap"], [n, r], t);
  },
  mathmlBuilder: (e, t) => {
    var n = Dt(je(e.body), t), r = new G.MathNode("mphantom", n), i = new G.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
J({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = me(t[0], "size").value, i = t[1];
    return {
      type: "raisebox",
      mode: n.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(e, t) {
    var n = Ee(e.body, t), r = Ue(e.dy, t);
    return D.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mpadded", [Me(e.body, t)]), r = e.dy.number + e.dy.unit;
    return n.setAttribute("voffset", r), n;
  }
});
J({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t
    } = e;
    return {
      type: "internal",
      mode: t.mode
    };
  }
});
J({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = n[0], a = me(t[0], "size"), l = me(t[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && me(i, "size").value,
      width: a.value,
      height: l.value
    };
  },
  htmlBuilder(e, t) {
    var n = D.makeSpan(["mord", "rule"], [], t), r = Ue(e.width, t), i = Ue(e.height, t), a = e.shift ? Ue(e.shift, t) : 0;
    return n.style.borderRightWidth = X(r), n.style.borderTopWidth = X(i), n.style.bottom = X(a), n.width = r, n.height = i + a, n.depth = -a, n.maxFontSize = i * 1.125 * t.sizeMultiplier, n;
  },
  mathmlBuilder(e, t) {
    var n = Ue(e.width, t), r = Ue(e.height, t), i = e.shift ? Ue(e.shift, t) : 0, a = t.color && t.getColor() || "black", l = new G.MathNode("mspace");
    l.setAttribute("mathbackground", a), l.setAttribute("width", X(n)), l.setAttribute("height", X(r));
    var o = new G.MathNode("mpadded", [l]);
    return i >= 0 ? o.setAttribute("height", X(i)) : (o.setAttribute("height", X(i)), o.setAttribute("depth", X(-i))), o.setAttribute("voffset", X(i)), o;
  }
});
function K4(e, t, n) {
  for (var r = nt(e, t, !1), i = t.sizeMultiplier / n.sizeMultiplier, a = 0; a < r.length; a++) {
    var l = r[a].classes.indexOf("sizing");
    l < 0 ? Array.prototype.push.apply(r[a].classes, t.sizingClasses(n)) : r[a].classes[l + 1] === "reset-size" + t.size && (r[a].classes[l + 1] = "reset-size" + n.size), r[a].height *= i, r[a].depth *= i;
  }
  return D.makeFragment(r);
}
var nh = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], Rx = (e, t) => {
  var n = t.havingSize(e.size);
  return K4(e.body, n, t);
};
J({
  type: "sizing",
  names: nh,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      breakOnTokenText: n,
      funcName: r,
      parser: i
    } = e, a = i.parseExpression(!1, n);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: nh.indexOf(r) + 1,
      body: a
    };
  },
  htmlBuilder: Rx,
  mathmlBuilder: (e, t) => {
    var n = t.havingSize(e.size), r = Dt(e.body, n), i = new G.MathNode("mstyle", r);
    return i.setAttribute("mathsize", X(n.sizeMultiplier)), i;
  }
});
J({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (e, t, n) => {
    var {
      parser: r
    } = e, i = !1, a = !1, l = n[0] && me(n[0], "ordgroup");
    if (l)
      for (var o = "", s = 0; s < l.body.length; ++s) {
        var u = l.body[s];
        if (o = u.text, o === "t")
          i = !0;
        else if (o === "b")
          a = !0;
        else {
          i = !1, a = !1;
          break;
        }
      }
    else
      i = !0, a = !0;
    var c = t[0];
    return {
      type: "smash",
      mode: r.mode,
      body: c,
      smashHeight: i,
      smashDepth: a
    };
  },
  htmlBuilder: (e, t) => {
    var n = D.makeSpan([], [Ee(e.body, t)]);
    if (!e.smashHeight && !e.smashDepth)
      return n;
    if (e.smashHeight && (n.height = 0, n.children))
      for (var r = 0; r < n.children.length; r++)
        n.children[r].height = 0;
    if (e.smashDepth && (n.depth = 0, n.children))
      for (var i = 0; i < n.children.length; i++)
        n.children[i].depth = 0;
    var a = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
    return D.makeSpan(["mord"], [a], t);
  },
  mathmlBuilder: (e, t) => {
    var n = new G.MathNode("mpadded", [Me(e.body, t)]);
    return e.smashHeight && n.setAttribute("height", "0px"), e.smashDepth && n.setAttribute("depth", "0px"), n;
  }
});
J({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = n[0], a = t[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: a,
      index: i
    };
  },
  htmlBuilder(e, t) {
    var n = Ee(e.body, t.havingCrampedStyle());
    n.height === 0 && (n.height = t.fontMetrics().xHeight), n = D.wrapFragment(n, t);
    var r = t.fontMetrics(), i = r.defaultRuleThickness, a = i;
    t.style.id < ce.TEXT.id && (a = t.fontMetrics().xHeight);
    var l = i + a / 4, o = n.height + n.depth + l + i, {
      span: s,
      ruleWidth: u,
      advanceWidth: c
    } = qn.sqrtImage(o, t), d = s.height - u;
    d > n.height + n.depth + l && (l = (l + d - n.height - n.depth) / 2);
    var h = s.height - n.height - l - u;
    n.style.paddingLeft = X(c);
    var p = D.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(n.height + h)
      }, {
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: u
      }]
    }, t);
    if (e.index) {
      var g = t.havingStyle(ce.SCRIPTSCRIPT), w = Ee(e.index, g, t), S = 0.6 * (p.height - p.depth), y = D.makeVList({
        positionType: "shift",
        positionData: -S,
        children: [{
          type: "elem",
          elem: w
        }]
      }, t), v = D.makeSpan(["root"], [y]);
      return D.makeSpan(["mord", "sqrt"], [v, p], t);
    } else
      return D.makeSpan(["mord", "sqrt"], [p], t);
  },
  mathmlBuilder(e, t) {
    var {
      body: n,
      index: r
    } = e;
    return r ? new G.MathNode("mroot", [Me(n, t), Me(r, t)]) : new G.MathNode("msqrt", [Me(n, t)]);
  }
});
var rh = {
  display: ce.DISPLAY,
  text: ce.TEXT,
  script: ce.SCRIPT,
  scriptscript: ce.SCRIPTSCRIPT
};
J({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      breakOnTokenText: n,
      funcName: r,
      parser: i
    } = e, a = i.parseExpression(!0, n), l = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: l,
      body: a
    };
  },
  htmlBuilder(e, t) {
    var n = rh[e.style], r = t.havingStyle(n).withFont("");
    return K4(e.body, r, t);
  },
  mathmlBuilder(e, t) {
    var n = rh[e.style], r = t.havingStyle(n), i = Dt(e.body, r), a = new G.MathNode("mstyle", i), l = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, o = l[e.style];
    return a.setAttribute("scriptlevel", o[0]), a.setAttribute("displaystyle", o[1]), a;
  }
});
var Ix = function(t, n) {
  var r = t.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (n.style.size === ce.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? Yi : null;
    } else if (r.type === "operatorname") {
      var a = r.alwaysHandleSupSub && (n.style.size === ce.DISPLAY.size || r.limits);
      return a ? W4 : null;
    } else {
      if (r.type === "accent")
        return se.isCharacterBox(r.base) ? ld : null;
      if (r.type === "horizBrace") {
        var l = !t.sub;
        return l === r.isOver ? q4 : null;
      } else
        return null;
    }
  else return null;
};
ei({
  type: "supsub",
  htmlBuilder(e, t) {
    var n = Ix(e, t);
    if (n)
      return n(e, t);
    var {
      base: r,
      sup: i,
      sub: a
    } = e, l = Ee(r, t), o, s, u = t.fontMetrics(), c = 0, d = 0, h = r && se.isCharacterBox(r);
    if (i) {
      var p = t.havingStyle(t.style.sup());
      o = Ee(i, p, t), h || (c = l.height - p.fontMetrics().supDrop * p.sizeMultiplier / t.sizeMultiplier);
    }
    if (a) {
      var g = t.havingStyle(t.style.sub());
      s = Ee(a, g, t), h || (d = l.depth + g.fontMetrics().subDrop * g.sizeMultiplier / t.sizeMultiplier);
    }
    var w;
    t.style === ce.DISPLAY ? w = u.sup1 : t.style.cramped ? w = u.sup3 : w = u.sup2;
    var S = t.sizeMultiplier, y = X(0.5 / u.ptPerEm / S), v = null;
    if (s) {
      var x = e.base && e.base.type === "op" && e.base.name && (e.base.name === "\\oiint" || e.base.name === "\\oiiint");
      (l instanceof rn || x) && (v = X(-l.italic));
    }
    var C;
    if (o && s) {
      c = Math.max(c, w, o.depth + 0.25 * u.xHeight), d = Math.max(d, u.sub2);
      var R = u.defaultRuleThickness, T = 4 * R;
      if (c - o.depth - (s.height - d) < T) {
        d = T - (c - o.depth) + s.height;
        var z = 0.8 * u.xHeight - (c - o.depth);
        z > 0 && (c += z, d -= z);
      }
      var P = [{
        type: "elem",
        elem: s,
        shift: d,
        marginRight: y,
        marginLeft: v
      }, {
        type: "elem",
        elem: o,
        shift: -c,
        marginRight: y
      }];
      C = D.makeVList({
        positionType: "individualShift",
        children: P
      }, t);
    } else if (s) {
      d = Math.max(d, u.sub1, s.height - 0.8 * u.xHeight);
      var U = [{
        type: "elem",
        elem: s,
        marginLeft: v,
        marginRight: y
      }];
      C = D.makeVList({
        positionType: "shift",
        positionData: d,
        children: U
      }, t);
    } else if (o)
      c = Math.max(c, w, o.depth + 0.25 * u.xHeight), C = D.makeVList({
        positionType: "shift",
        positionData: -c,
        children: [{
          type: "elem",
          elem: o,
          marginRight: y
        }]
      }, t);
    else
      throw new Error("supsub must have either sup or sub.");
    var O = Ru(l, "right") || "mord";
    return D.makeSpan([O], [l, D.makeSpan(["msupsub"], [C])], t);
  },
  mathmlBuilder(e, t) {
    var n = !1, r, i;
    e.base && e.base.type === "horizBrace" && (i = !!e.sup, i === e.base.isOver && (n = !0, r = e.base.isOver)), e.base && (e.base.type === "op" || e.base.type === "operatorname") && (e.base.parentIsSupSub = !0);
    var a = [Me(e.base, t)];
    e.sub && a.push(Me(e.sub, t)), e.sup && a.push(Me(e.sup, t));
    var l;
    if (n)
      l = r ? "mover" : "munder";
    else if (e.sub)
      if (e.sup) {
        var u = e.base;
        u && u.type === "op" && u.limits && t.style === ce.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (t.style === ce.DISPLAY || u.limits) ? l = "munderover" : l = "msubsup";
      } else {
        var s = e.base;
        s && s.type === "op" && s.limits && (t.style === ce.DISPLAY || s.alwaysHandleSupSub) || s && s.type === "operatorname" && s.alwaysHandleSupSub && (s.limits || t.style === ce.DISPLAY) ? l = "munder" : l = "msub";
      }
    else {
      var o = e.base;
      o && o.type === "op" && o.limits && (t.style === ce.DISPLAY || o.alwaysHandleSupSub) || o && o.type === "operatorname" && o.alwaysHandleSupSub && (o.limits || t.style === ce.DISPLAY) ? l = "mover" : l = "msup";
    }
    return new G.MathNode(l, a);
  }
});
ei({
  type: "atom",
  htmlBuilder(e, t) {
    return D.mathsym(e.text, e.mode, t, ["m" + e.family]);
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mo", [an(e.text, e.mode)]);
    if (e.family === "bin") {
      var r = id(e, t);
      r === "bold-italic" && n.setAttribute("mathvariant", r);
    } else e.family === "punct" ? n.setAttribute("separator", "true") : (e.family === "open" || e.family === "close") && n.setAttribute("stretchy", "false");
    return n;
  }
});
var Y4 = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
ei({
  type: "mathord",
  htmlBuilder(e, t) {
    return D.makeOrd(e, t, "mathord");
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mi", [an(e.text, e.mode, t)]), r = id(e, t) || "italic";
    return r !== Y4[n.type] && n.setAttribute("mathvariant", r), n;
  }
});
ei({
  type: "textord",
  htmlBuilder(e, t) {
    return D.makeOrd(e, t, "textord");
  },
  mathmlBuilder(e, t) {
    var n = an(e.text, e.mode, t), r = id(e, t) || "normal", i;
    return e.mode === "text" ? i = new G.MathNode("mtext", [n]) : /[0-9]/.test(e.text) ? i = new G.MathNode("mn", [n]) : e.text === "\\prime" ? i = new G.MathNode("mo", [n]) : i = new G.MathNode("mi", [n]), r !== Y4[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var w0 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, x0 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
ei({
  type: "spacing",
  htmlBuilder(e, t) {
    if (x0.hasOwnProperty(e.text)) {
      var n = x0[e.text].className || "";
      if (e.mode === "text") {
        var r = D.makeOrd(e, t, "textord");
        return r.classes.push(n), r;
      } else
        return D.makeSpan(["mspace", n], [D.mathsym(e.text, e.mode, t)], t);
    } else {
      if (w0.hasOwnProperty(e.text))
        return D.makeSpan(["mspace", w0[e.text]], [], t);
      throw new Y('Unknown type of space "' + e.text + '"');
    }
  },
  mathmlBuilder(e, t) {
    var n;
    if (x0.hasOwnProperty(e.text))
      n = new G.MathNode("mtext", [new G.TextNode("")]);
    else {
      if (w0.hasOwnProperty(e.text))
        return new G.MathNode("mspace");
      throw new Y('Unknown type of space "' + e.text + '"');
    }
    return n;
  }
});
var ih = () => {
  var e = new G.MathNode("mtd", []);
  return e.setAttribute("width", "50%"), e;
};
ei({
  type: "tag",
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mtable", [new G.MathNode("mtr", [ih(), new G.MathNode("mtd", [Sr(e.body, t)]), ih(), new G.MathNode("mtd", [Sr(e.tag, t)])])]);
    return n.setAttribute("width", "100%"), n;
  }
});
var ah = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, lh = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, Dx = {
  "\\textit": "textit",
  "\\textup": "textup"
}, oh = (e, t) => {
  var n = e.font;
  if (n) {
    if (ah[n])
      return t.withTextFontFamily(ah[n]);
    if (lh[n])
      return t.withTextFontWeight(lh[n]);
    if (n === "\\emph")
      return t.fontShape === "textit" ? t.withTextFontShape("textup") : t.withTextFontShape("textit");
  } else return t;
  return t.withTextFontShape(Dx[n]);
};
J({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "text",
      mode: n.mode,
      body: je(i),
      font: r
    };
  },
  htmlBuilder(e, t) {
    var n = oh(e, t), r = nt(e.body, n, !0);
    return D.makeSpan(["mord", "text"], r, n);
  },
  mathmlBuilder(e, t) {
    var n = oh(e, t);
    return Sr(e.body, n);
  }
});
J({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "underline",
      mode: n.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = Ee(e.body, t), r = D.makeLineSpan("underline-line", t), i = t.fontMetrics().defaultRuleThickness, a = D.makeVList({
      positionType: "top",
      positionData: n.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: n
      }]
    }, t);
    return D.makeSpan(["mord", "underline"], [a], t);
  },
  mathmlBuilder(e, t) {
    var n = new G.MathNode("mo", [new G.TextNode("")]);
    n.setAttribute("stretchy", "true");
    var r = new G.MathNode("munder", [Me(e.body, t), n]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
J({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "vcenter",
      mode: n.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = Ee(e.body, t), r = t.fontMetrics().axisHeight, i = 0.5 * (n.height - r - (n.depth + r));
    return D.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    return new G.MathNode("mpadded", [Me(e.body, t)], ["vcenter"]);
  }
});
J({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e, t, n) {
    throw new Y("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(e, t) {
    for (var n = sh(e), r = [], i = t.havingStyle(t.style.text()), a = 0; a < n.length; a++) {
      var l = n[a];
      l === "~" && (l = "\\textasciitilde"), r.push(D.makeSymbol(l, "Typewriter-Regular", e.mode, i, ["mord", "texttt"]));
    }
    return D.makeSpan(["mord", "text"].concat(i.sizingClasses(t)), D.tryCombineChars(r), i);
  },
  mathmlBuilder(e, t) {
    var n = new G.TextNode(sh(e)), r = new G.MathNode("mtext", [n]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var sh = (e) => e.body.replace(/ /g, e.star ? "" : ""), cr = v4, j4 = `[ \r
	]`, zx = "\\\\[a-zA-Z@]+", Lx = "\\\\[^\uD800-\uDFFF]", Px = "(" + zx + ")" + j4 + "*", Bx = `\\\\(
|[ \r	]+
?)[ \r	]*`, Lu = "[-]", Fx = new RegExp(Lu + "+$"), Ux = "(" + j4 + "+)|" + // whitespace
(Bx + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(Lu + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(Lu + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Px) + // \macroName + spaces
("|" + Lx + ")");
class uh {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(t, n) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = n, this.tokenRegex = new RegExp(Ux, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(t, n) {
    this.catcodes[t] = n;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var t = this.input, n = this.tokenRegex.lastIndex;
    if (n === t.length)
      return new en("EOF", new Ft(this, n, n));
    var r = this.tokenRegex.exec(t);
    if (r === null || r.index !== n)
      throw new Y("Unexpected character: '" + t[n] + "'", new en(t[n], new Ft(this, n, n + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var a = t.indexOf(`
`, this.tokenRegex.lastIndex);
      return a === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = a + 1, this.lex();
    }
    return new en(i, new Ft(this, n, this.tokenRegex.lastIndex));
  }
}
class $x {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(t, n) {
    t === void 0 && (t = {}), n === void 0 && (n = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = n, this.builtins = t, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new Y("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var t = this.undefStack.pop();
    for (var n in t)
      t.hasOwnProperty(n) && (t[n] == null ? delete this.current[n] : this.current[n] = t[n]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(t) {
    return this.current.hasOwnProperty(t) || this.builtins.hasOwnProperty(t);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(t) {
    return this.current.hasOwnProperty(t) ? this.current[t] : this.builtins[t];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(t, n, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][t];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = n);
    } else {
      var a = this.undefStack[this.undefStack.length - 1];
      a && !a.hasOwnProperty(t) && (a[t] = this.current[t]);
    }
    n == null ? delete this.current[t] : this.current[t] = n;
  }
}
var Hx = B4;
k("\\noexpand", function(e) {
  var t = e.popToken();
  return e.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
    tokens: [t],
    numArgs: 0
  };
});
k("\\expandafter", function(e) {
  var t = e.popToken();
  return e.expandOnce(!0), {
    tokens: [t],
    numArgs: 0
  };
});
k("\\@firstoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[0],
    numArgs: 0
  };
});
k("\\@secondoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[1],
    numArgs: 0
  };
});
k("\\@ifnextchar", function(e) {
  var t = e.consumeArgs(3);
  e.consumeSpaces();
  var n = e.future();
  return t[0].length === 1 && t[0][0].text === n.text ? {
    tokens: t[1],
    numArgs: 0
  } : {
    tokens: t[2],
    numArgs: 0
  };
});
k("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
k("\\TextOrMath", function(e) {
  var t = e.consumeArgs(2);
  return e.mode === "text" ? {
    tokens: t[0],
    numArgs: 0
  } : {
    tokens: t[1],
    numArgs: 0
  };
});
var ch = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
k("\\char", function(e) {
  var t = e.popToken(), n, r = "";
  if (t.text === "'")
    n = 8, t = e.popToken();
  else if (t.text === '"')
    n = 16, t = e.popToken();
  else if (t.text === "`")
    if (t = e.popToken(), t.text[0] === "\\")
      r = t.text.charCodeAt(1);
    else {
      if (t.text === "EOF")
        throw new Y("\\char` missing argument");
      r = t.text.charCodeAt(0);
    }
  else
    n = 10;
  if (n) {
    if (r = ch[t.text], r == null || r >= n)
      throw new Y("Invalid base-" + n + " digit " + t.text);
    for (var i; (i = ch[e.future().text]) != null && i < n; )
      r *= n, r += i, e.popToken();
  }
  return "\\@char{" + r + "}";
});
var pd = (e, t, n) => {
  var r = e.consumeArg().tokens;
  if (r.length !== 1)
    throw new Y("\\newcommand's first argument must be a macro name");
  var i = r[0].text, a = e.isDefined(i);
  if (a && !t)
    throw new Y("\\newcommand{" + i + "} attempting to redefine " + (i + "; use \\renewcommand"));
  if (!a && !n)
    throw new Y("\\renewcommand{" + i + "} when command " + i + " does not yet exist; use \\newcommand");
  var l = 0;
  if (r = e.consumeArg().tokens, r.length === 1 && r[0].text === "[") {
    for (var o = "", s = e.expandNextToken(); s.text !== "]" && s.text !== "EOF"; )
      o += s.text, s = e.expandNextToken();
    if (!o.match(/^\s*[0-9]+\s*$/))
      throw new Y("Invalid number of arguments: " + o);
    l = parseInt(o), r = e.consumeArg().tokens;
  }
  return e.macros.set(i, {
    tokens: r,
    numArgs: l
  }), "";
};
k("\\newcommand", (e) => pd(e, !1, !0));
k("\\renewcommand", (e) => pd(e, !0, !1));
k("\\providecommand", (e) => pd(e, !0, !0));
k("\\message", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.log(t.reverse().map((n) => n.text).join("")), "";
});
k("\\errmessage", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.error(t.reverse().map((n) => n.text).join("")), "";
});
k("\\show", (e) => {
  var t = e.popToken(), n = t.text;
  return console.log(t, e.macros.get(n), cr[n], Ie.math[n], Ie.text[n]), "";
});
k("\\bgroup", "{");
k("\\egroup", "}");
k("~", "\\nobreakspace");
k("\\lq", "`");
k("\\rq", "'");
k("\\aa", "\\r a");
k("\\AA", "\\r A");
k("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
k("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
k("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
k("", "\\mathscr{B}");
k("", "\\mathscr{E}");
k("", "\\mathscr{F}");
k("", "\\mathscr{H}");
k("", "\\mathscr{I}");
k("", "\\mathscr{L}");
k("", "\\mathscr{M}");
k("", "\\mathscr{R}");
k("", "\\mathfrak{C}");
k("", "\\mathfrak{H}");
k("", "\\mathfrak{Z}");
k("\\Bbbk", "\\Bbb{k}");
k("", "\\cdotp");
k("\\llap", "\\mathllap{\\textrm{#1}}");
k("\\rlap", "\\mathrlap{\\textrm{#1}}");
k("\\clap", "\\mathclap{\\textrm{#1}}");
k("\\mathstrut", "\\vphantom{(}");
k("\\underbar", "\\underline{\\text{#1}}");
k("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
k("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
k("\\ne", "\\neq");
k("", "\\neq");
k("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
k("", "\\notin");
k("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
k("", "\\perp");
k("", "\\mathclose{!\\mkern-0.8mu!}");
k("", "\\notni");
k("", "\\ulcorner");
k("", "\\urcorner");
k("", "\\llcorner");
k("", "\\lrcorner");
k("", "\\copyright");
k("", "\\textregistered");
k("", "\\textregistered");
k("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
k("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
k("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
k("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
k("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
k("", "\\vdots");
k("\\varGamma", "\\mathit{\\Gamma}");
k("\\varDelta", "\\mathit{\\Delta}");
k("\\varTheta", "\\mathit{\\Theta}");
k("\\varLambda", "\\mathit{\\Lambda}");
k("\\varXi", "\\mathit{\\Xi}");
k("\\varPi", "\\mathit{\\Pi}");
k("\\varSigma", "\\mathit{\\Sigma}");
k("\\varUpsilon", "\\mathit{\\Upsilon}");
k("\\varPhi", "\\mathit{\\Phi}");
k("\\varPsi", "\\mathit{\\Psi}");
k("\\varOmega", "\\mathit{\\Omega}");
k("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
k("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
k("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
k("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
k("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
k("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dh = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
k("\\dots", function(e) {
  var t = "\\dotso", n = e.expandAfterFuture().text;
  return n in dh ? t = dh[n] : (n.slice(0, 4) === "\\not" || n in Ie.math && se.contains(["bin", "rel"], Ie.math[n].group)) && (t = "\\dotsb"), t;
});
var md = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
k("\\dotso", function(e) {
  var t = e.future().text;
  return t in md ? "\\ldots\\," : "\\ldots";
});
k("\\dotsc", function(e) {
  var t = e.future().text;
  return t in md && t !== "," ? "\\ldots\\," : "\\ldots";
});
k("\\cdots", function(e) {
  var t = e.future().text;
  return t in md ? "\\@cdots\\," : "\\@cdots";
});
k("\\dotsb", "\\cdots");
k("\\dotsm", "\\cdots");
k("\\dotsi", "\\!\\cdots");
k("\\dotsx", "\\ldots\\,");
k("\\DOTSI", "\\relax");
k("\\DOTSB", "\\relax");
k("\\DOTSX", "\\relax");
k("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
k("\\,", "\\tmspace+{3mu}{.1667em}");
k("\\thinspace", "\\,");
k("\\>", "\\mskip{4mu}");
k("\\:", "\\tmspace+{4mu}{.2222em}");
k("\\medspace", "\\:");
k("\\;", "\\tmspace+{5mu}{.2777em}");
k("\\thickspace", "\\;");
k("\\!", "\\tmspace-{3mu}{.1667em}");
k("\\negthinspace", "\\!");
k("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
k("\\negthickspace", "\\tmspace-{5mu}{.277em}");
k("\\enspace", "\\kern.5em ");
k("\\enskip", "\\hskip.5em\\relax");
k("\\quad", "\\hskip1em\\relax");
k("\\qquad", "\\hskip2em\\relax");
k("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
k("\\tag@paren", "\\tag@literal{({#1})}");
k("\\tag@literal", (e) => {
  if (e.macros.get("\\df@tag"))
    throw new Y("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
k("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
k("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
k("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
k("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
k("\\newline", "\\\\\\relax");
k("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var X4 = X(Tn["Main-Regular"][84][1] - 0.7 * Tn["Main-Regular"][65][1]);
k("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + X4 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
k("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + X4 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
k("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
k("\\@hspace", "\\hskip #1\\relax");
k("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
k("\\ordinarycolon", ":");
k("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
k("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
k("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
k("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
k("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
k("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
k("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
k("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
k("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
k("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
k("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
k("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
k("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
k("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
k("", "\\dblcolon");
k("", "\\eqcolon");
k("", "\\coloneqq");
k("", "\\eqqcolon");
k("", "\\Coloneqq");
k("\\ratio", "\\vcentcolon");
k("\\coloncolon", "\\dblcolon");
k("\\colonequals", "\\coloneqq");
k("\\coloncolonequals", "\\Coloneqq");
k("\\equalscolon", "\\eqqcolon");
k("\\equalscoloncolon", "\\Eqqcolon");
k("\\colonminus", "\\coloneq");
k("\\coloncolonminus", "\\Coloneq");
k("\\minuscolon", "\\eqcolon");
k("\\minuscoloncolon", "\\Eqcolon");
k("\\coloncolonapprox", "\\Colonapprox");
k("\\coloncolonsim", "\\Colonsim");
k("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
k("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
k("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
k("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
k("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
k("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
k("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
k("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
k("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
k("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
k("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
k("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
k("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
k("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
k("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
k("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
k("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
k("\\nleqq", "\\html@mathml{\\@nleqq}{}");
k("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
k("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
k("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
k("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
k("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
k("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
k("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
k("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
k("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
k("\\imath", "\\html@mathml{\\@imath}{}");
k("\\jmath", "\\html@mathml{\\@jmath}{}");
k("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
k("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
k("", "\\llbracket");
k("", "\\rrbracket");
k("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
k("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
k("", "\\lBrace");
k("", "\\rBrace");
k("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
k("", "\\minuso");
k("\\darr", "\\downarrow");
k("\\dArr", "\\Downarrow");
k("\\Darr", "\\Downarrow");
k("\\lang", "\\langle");
k("\\rang", "\\rangle");
k("\\uarr", "\\uparrow");
k("\\uArr", "\\Uparrow");
k("\\Uarr", "\\Uparrow");
k("\\N", "\\mathbb{N}");
k("\\R", "\\mathbb{R}");
k("\\Z", "\\mathbb{Z}");
k("\\alef", "\\aleph");
k("\\alefsym", "\\aleph");
k("\\Alpha", "\\mathrm{A}");
k("\\Beta", "\\mathrm{B}");
k("\\bull", "\\bullet");
k("\\Chi", "\\mathrm{X}");
k("\\clubs", "\\clubsuit");
k("\\cnums", "\\mathbb{C}");
k("\\Complex", "\\mathbb{C}");
k("\\Dagger", "\\ddagger");
k("\\diamonds", "\\diamondsuit");
k("\\empty", "\\emptyset");
k("\\Epsilon", "\\mathrm{E}");
k("\\Eta", "\\mathrm{H}");
k("\\exist", "\\exists");
k("\\harr", "\\leftrightarrow");
k("\\hArr", "\\Leftrightarrow");
k("\\Harr", "\\Leftrightarrow");
k("\\hearts", "\\heartsuit");
k("\\image", "\\Im");
k("\\infin", "\\infty");
k("\\Iota", "\\mathrm{I}");
k("\\isin", "\\in");
k("\\Kappa", "\\mathrm{K}");
k("\\larr", "\\leftarrow");
k("\\lArr", "\\Leftarrow");
k("\\Larr", "\\Leftarrow");
k("\\lrarr", "\\leftrightarrow");
k("\\lrArr", "\\Leftrightarrow");
k("\\Lrarr", "\\Leftrightarrow");
k("\\Mu", "\\mathrm{M}");
k("\\natnums", "\\mathbb{N}");
k("\\Nu", "\\mathrm{N}");
k("\\Omicron", "\\mathrm{O}");
k("\\plusmn", "\\pm");
k("\\rarr", "\\rightarrow");
k("\\rArr", "\\Rightarrow");
k("\\Rarr", "\\Rightarrow");
k("\\real", "\\Re");
k("\\reals", "\\mathbb{R}");
k("\\Reals", "\\mathbb{R}");
k("\\Rho", "\\mathrm{P}");
k("\\sdot", "\\cdot");
k("\\sect", "\\S");
k("\\spades", "\\spadesuit");
k("\\sub", "\\subset");
k("\\sube", "\\subseteq");
k("\\supe", "\\supseteq");
k("\\Tau", "\\mathrm{T}");
k("\\thetasym", "\\vartheta");
k("\\weierp", "\\wp");
k("\\Zeta", "\\mathrm{Z}");
k("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
k("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
k("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
k("\\bra", "\\mathinner{\\langle{#1}|}");
k("\\ket", "\\mathinner{|{#1}\\rangle}");
k("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
k("\\Bra", "\\left\\langle#1\\right|");
k("\\Ket", "\\left|#1\\right\\rangle");
var Z4 = (e) => (t) => {
  var n = t.consumeArg().tokens, r = t.consumeArg().tokens, i = t.consumeArg().tokens, a = t.consumeArg().tokens, l = t.macros.get("|"), o = t.macros.get("\\|");
  t.macros.beginGroup();
  var s = (d) => (h) => {
    e && (h.macros.set("|", l), i.length && h.macros.set("\\|", o));
    var p = d;
    if (!d && i.length) {
      var g = h.future();
      g.text === "|" && (h.popToken(), p = !0);
    }
    return {
      tokens: p ? i : r,
      numArgs: 0
    };
  };
  t.macros.set("|", s(!1)), i.length && t.macros.set("\\|", s(!0));
  var u = t.consumeArg().tokens, c = t.expandTokens([
    ...a,
    ...u,
    ...n
    // reversed
  ]);
  return t.macros.endGroup(), {
    tokens: c.reverse(),
    numArgs: 0
  };
};
k("\\bra@ket", Z4(!1));
k("\\bra@set", Z4(!0));
k("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
k("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
k("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
k("\\angln", "{\\angl n}");
k("\\blue", "\\textcolor{##6495ed}{#1}");
k("\\orange", "\\textcolor{##ffa500}{#1}");
k("\\pink", "\\textcolor{##ff00af}{#1}");
k("\\red", "\\textcolor{##df0030}{#1}");
k("\\green", "\\textcolor{##28ae7b}{#1}");
k("\\gray", "\\textcolor{gray}{#1}");
k("\\purple", "\\textcolor{##9d38bd}{#1}");
k("\\blueA", "\\textcolor{##ccfaff}{#1}");
k("\\blueB", "\\textcolor{##80f6ff}{#1}");
k("\\blueC", "\\textcolor{##63d9ea}{#1}");
k("\\blueD", "\\textcolor{##11accd}{#1}");
k("\\blueE", "\\textcolor{##0c7f99}{#1}");
k("\\tealA", "\\textcolor{##94fff5}{#1}");
k("\\tealB", "\\textcolor{##26edd5}{#1}");
k("\\tealC", "\\textcolor{##01d1c1}{#1}");
k("\\tealD", "\\textcolor{##01a995}{#1}");
k("\\tealE", "\\textcolor{##208170}{#1}");
k("\\greenA", "\\textcolor{##b6ffb0}{#1}");
k("\\greenB", "\\textcolor{##8af281}{#1}");
k("\\greenC", "\\textcolor{##74cf70}{#1}");
k("\\greenD", "\\textcolor{##1fab54}{#1}");
k("\\greenE", "\\textcolor{##0d923f}{#1}");
k("\\goldA", "\\textcolor{##ffd0a9}{#1}");
k("\\goldB", "\\textcolor{##ffbb71}{#1}");
k("\\goldC", "\\textcolor{##ff9c39}{#1}");
k("\\goldD", "\\textcolor{##e07d10}{#1}");
k("\\goldE", "\\textcolor{##a75a05}{#1}");
k("\\redA", "\\textcolor{##fca9a9}{#1}");
k("\\redB", "\\textcolor{##ff8482}{#1}");
k("\\redC", "\\textcolor{##f9685d}{#1}");
k("\\redD", "\\textcolor{##e84d39}{#1}");
k("\\redE", "\\textcolor{##bc2612}{#1}");
k("\\maroonA", "\\textcolor{##ffbde0}{#1}");
k("\\maroonB", "\\textcolor{##ff92c6}{#1}");
k("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
k("\\maroonD", "\\textcolor{##ca337c}{#1}");
k("\\maroonE", "\\textcolor{##9e034e}{#1}");
k("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
k("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
k("\\purpleC", "\\textcolor{##aa87ff}{#1}");
k("\\purpleD", "\\textcolor{##7854ab}{#1}");
k("\\purpleE", "\\textcolor{##543b78}{#1}");
k("\\mintA", "\\textcolor{##f5f9e8}{#1}");
k("\\mintB", "\\textcolor{##edf2df}{#1}");
k("\\mintC", "\\textcolor{##e0e5cc}{#1}");
k("\\grayA", "\\textcolor{##f6f7f7}{#1}");
k("\\grayB", "\\textcolor{##f0f1f2}{#1}");
k("\\grayC", "\\textcolor{##e3e5e6}{#1}");
k("\\grayD", "\\textcolor{##d6d8da}{#1}");
k("\\grayE", "\\textcolor{##babec2}{#1}");
k("\\grayF", "\\textcolor{##888d93}{#1}");
k("\\grayG", "\\textcolor{##626569}{#1}");
k("\\grayH", "\\textcolor{##3b3e40}{#1}");
k("\\grayI", "\\textcolor{##21242c}{#1}");
k("\\kaBlue", "\\textcolor{##314453}{#1}");
k("\\kaGreen", "\\textcolor{##71B307}{#1}");
var Q4 = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class qx {
  constructor(t, n, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = n, this.expansionCount = 0, this.feed(t), this.macros = new $x(Hx, n.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(t) {
    this.lexer = new uh(t, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(t) {
    this.stack.push(t);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(t) {
    this.stack.push(...t);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(t) {
    var n, r, i;
    if (t) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      n = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: n,
        end: r
      } = this.consumeArg());
    return this.pushToken(new en("EOF", r.loc)), this.pushTokens(i), n.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var t = this.future();
      if (t.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(t) {
    var n = [], r = t && t.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), a, l = 0, o = 0;
    do {
      if (a = this.popToken(), n.push(a), a.text === "{")
        ++l;
      else if (a.text === "}") {
        if (--l, l === -1)
          throw new Y("Extra }", a);
      } else if (a.text === "EOF")
        throw new Y("Unexpected end of input in a macro argument, expected '" + (t && r ? t[o] : "}") + "'", a);
      if (t && r)
        if ((l === 0 || l === 1 && t[o] === "{") && a.text === t[o]) {
          if (++o, o === t.length) {
            n.splice(-o, o);
            break;
          }
        } else
          o = 0;
    } while (l !== 0 || r);
    return i.text === "{" && n[n.length - 1].text === "}" && (n.pop(), n.shift()), n.reverse(), {
      tokens: n,
      start: i,
      end: a
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(t, n) {
    if (n) {
      if (n.length !== t + 1)
        throw new Y("The length of delimiters doesn't match the number of args!");
      for (var r = n[0], i = 0; i < r.length; i++) {
        var a = this.popToken();
        if (r[i] !== a.text)
          throw new Y("Use of the macro doesn't match its definition", a);
      }
    }
    for (var l = [], o = 0; o < t; o++)
      l.push(this.consumeArg(n && n[o + 1]).tokens);
    return l;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(t) {
    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand)
      throw new Y("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(t) {
    var n = this.popToken(), r = n.text, i = n.noexpand ? null : this._getExpansion(r);
    if (i == null || t && i.unexpandable) {
      if (t && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new Y("Undefined control sequence: " + r);
      return this.pushToken(n), !1;
    }
    this.countExpansion(1);
    var a = i.tokens, l = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      a = a.slice();
      for (var o = a.length - 1; o >= 0; --o) {
        var s = a[o];
        if (s.text === "#") {
          if (o === 0)
            throw new Y("Incomplete placeholder at end of macro body", s);
          if (s = a[--o], s.text === "#")
            a.splice(o + 1, 1);
          else if (/^[1-9]$/.test(s.text))
            a.splice(o, 2, ...l[+s.text - 1]);
          else
            throw new Y("Not a valid argument number", s);
        }
      }
    }
    return this.pushTokens(a), a.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var t = this.stack.pop();
        return t.treatAsRelax && (t.text = "\\relax"), t;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(t) {
    return this.macros.has(t) ? this.expandTokens([new en(t)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(t) {
    var n = [], r = this.stack.length;
    for (this.pushTokens(t); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), n.push(i);
      }
    return this.countExpansion(n.length), n;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(t) {
    var n = this.expandMacro(t);
    return n && n.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(t) {
    var n = this.macros.get(t);
    if (n == null)
      return n;
    if (t.length === 1) {
      var r = this.lexer.catcodes[t];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof n == "function" ? n(this) : n;
    if (typeof i == "string") {
      var a = 0;
      if (i.indexOf("#") !== -1)
        for (var l = i.replace(/##/g, ""); l.indexOf("#" + (a + 1)) !== -1; )
          ++a;
      for (var o = new uh(i, this.settings), s = [], u = o.lex(); u.text !== "EOF"; )
        s.push(u), u = o.lex();
      s.reverse();
      var c = {
        tokens: s,
        numArgs: a
      };
      return c;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(t) {
    return this.macros.has(t) || cr.hasOwnProperty(t) || Ie.math.hasOwnProperty(t) || Ie.text.hasOwnProperty(t) || Q4.hasOwnProperty(t);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(t) {
    var n = this.macros.get(t);
    return n != null ? typeof n == "string" || typeof n == "function" || !n.unexpandable : cr.hasOwnProperty(t) && !cr[t].primitive;
  }
}
var fh = /^[]/, Bl = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  : "h",
  "": "i",
  : "j",
  "": "k",
  : "l",
  "": "m",
  : "n",
  "": "o",
  "": "p",
  : "r",
  : "s",
  "": "t",
  "": "u",
  "": "v",
  : "w",
  : "x",
  : "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
}), k0 = {
  "": {
    text: "\\'",
    math: "\\acute"
  },
  "": {
    text: "\\`",
    math: "\\grave"
  },
  "": {
    text: '\\"',
    math: "\\ddot"
  },
  "": {
    text: "\\~",
    math: "\\tilde"
  },
  "": {
    text: "\\=",
    math: "\\bar"
  },
  "": {
    text: "\\u",
    math: "\\breve"
  },
  "": {
    text: "\\v",
    math: "\\check"
  },
  "": {
    text: "\\^",
    math: "\\hat"
  },
  "": {
    text: "\\.",
    math: "\\dot"
  },
  "": {
    text: "\\r",
    math: "\\mathring"
  },
  "": {
    text: "\\H"
  },
  "": {
    text: "\\c"
  }
}, hh = {
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "b",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "d",
  : "d",
  : "d",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "f",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "h",
  : "h",
  : "h",
  : "h",
  : "h",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "j",
  : "j",
  : "k",
  : "k",
  : "k",
  : "l",
  : "l",
  : "l",
  : "m",
  : "m",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "p",
  : "p",
  : "r",
  : "r",
  : "r",
  : "r",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "t",
  : "t",
  : "t",
  : "t",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "v",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "x",
  : "x",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "z",
  : "z",
  : "z",
  : "z",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "B",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "D",
  : "D",
  : "D",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "F",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "H",
  : "H",
  : "H",
  : "H",
  : "H",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "J",
  : "K",
  : "K",
  : "K",
  : "L",
  : "L",
  : "L",
  : "M",
  : "M",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "P",
  : "P",
  : "R",
  : "R",
  : "R",
  : "R",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "T",
  : "T",
  : "T",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "V",
  : "W",
  : "W",
  : "W",
  : "W",
  : "W",
  : "X",
  : "X",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "Z",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : ""
};
class bs {
  constructor(t, n) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new qx(t, n, this.mode), this.settings = n, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(t, n) {
    if (n === void 0 && (n = !0), this.fetch().text !== t)
      throw new Y("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
    n && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t, this.gullet.switchMode(t);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var t = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), t;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(t) {
    var n = this.nextToken;
    this.consume(), this.gullet.pushToken(new en("}")), this.gullet.pushTokens(t);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = n, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(t, n) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (bs.endOfExpression.indexOf(i.text) !== -1 || n && i.text === n || t && cr[i.text] && cr[i.text].infix)
        break;
      var a = this.parseAtom(n);
      if (a) {
        if (a.type === "internal")
          continue;
      } else break;
      r.push(a);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(t) {
    for (var n = -1, r, i = 0; i < t.length; i++)
      if (t[i].type === "infix") {
        if (n !== -1)
          throw new Y("only one infix operator per group", t[i].token);
        n = i, r = t[i].replaceWith;
      }
    if (n !== -1 && r) {
      var a, l, o = t.slice(0, n), s = t.slice(n + 1);
      o.length === 1 && o[0].type === "ordgroup" ? a = o[0] : a = {
        type: "ordgroup",
        mode: this.mode,
        body: o
      }, s.length === 1 && s[0].type === "ordgroup" ? l = s[0] : l = {
        type: "ordgroup",
        mode: this.mode,
        body: s
      };
      var u;
      return r === "\\\\abovefrac" ? u = this.callFunction(r, [a, t[n], l], []) : u = this.callFunction(r, [a, l], []), [u];
    } else
      return t;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(t) {
    var n = this.fetch(), r = n.text;
    this.consume(), this.consumeSpaces();
    var i = this.parseGroup(t);
    if (!i)
      throw new Y("Expected group after '" + r + "'", n);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(t) {
    for (var n = [], r = 0; r < t.length; r++)
      n.push({
        type: "textord",
        mode: "text",
        text: t[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: n
    }, a = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return a;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(t) {
    var n = this.parseGroup("atom", t);
    if (this.mode === "text")
      return n;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var a = this.fetch();
      if (a.text === "\\limits" || a.text === "\\nolimits") {
        if (n && n.type === "op") {
          var l = a.text === "\\limits";
          n.limits = l, n.alwaysHandleSupSub = !0;
        } else if (n && n.type === "operatorname")
          n.alwaysHandleSupSub && (n.limits = a.text === "\\limits");
        else
          throw new Y("Limit controls must follow a math operator", a);
        this.consume();
      } else if (a.text === "^") {
        if (r)
          throw new Y("Double superscript", a);
        r = this.handleSupSubscript("superscript");
      } else if (a.text === "_") {
        if (i)
          throw new Y("Double subscript", a);
        i = this.handleSupSubscript("subscript");
      } else if (a.text === "'") {
        if (r)
          throw new Y("Double superscript", a);
        var o = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, s = [o];
        for (this.consume(); this.fetch().text === "'"; )
          s.push(o), this.consume();
        this.fetch().text === "^" && s.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: s
        };
      } else if (Bl[a.text]) {
        var u = fh.test(a.text), c = [];
        for (c.push(new en(Bl[a.text])), this.consume(); ; ) {
          var d = this.fetch().text;
          if (!Bl[d] || fh.test(d) !== u)
            break;
          c.unshift(new en(Bl[d])), this.consume();
        }
        var h = this.subparse(c);
        u ? i = {
          type: "ordgroup",
          mode: "math",
          body: h
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: h
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: n,
      sup: r,
      sub: i
    } : n;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(t, n) {
    var r = this.fetch(), i = r.text, a = cr[i];
    if (!a)
      return null;
    if (this.consume(), n && n !== "atom" && !a.allowedInArgument)
      throw new Y("Got function '" + i + "' with no arguments" + (n ? " as " + n : ""), r);
    if (this.mode === "text" && !a.allowedInText)
      throw new Y("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && a.allowedInMath === !1)
      throw new Y("Can't use function '" + i + "' in math mode", r);
    var {
      args: l,
      optArgs: o
    } = this.parseArguments(i, a);
    return this.callFunction(i, l, o, r, t);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(t, n, r, i, a) {
    var l = {
      funcName: t,
      parser: this,
      token: i,
      breakOnTokenText: a
    }, o = cr[t];
    if (o && o.handler)
      return o.handler(l, n, r);
    throw new Y("No function handler for " + t);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(t, n) {
    var r = n.numArgs + n.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], a = [], l = 0; l < r; l++) {
      var o = n.argTypes && n.argTypes[l], s = l < n.numOptionalArgs;
      (n.primitive && o == null || // \sqrt expands into primitive if optional argument doesn't exist
      n.type === "sqrt" && l === 1 && a[0] == null) && (o = "primitive");
      var u = this.parseGroupOfType("argument to '" + t + "'", o, s);
      if (s)
        a.push(u);
      else if (u != null)
        i.push(u);
      else
        throw new Y("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: a
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(t, n, r) {
    switch (n) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, n);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var a = this.parseStringGroup("raw", r);
        return a != null ? {
          type: "raw",
          mode: "text",
          string: a.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new Y("A primitive argument cannot be optional");
        var l = this.parseGroup(t);
        if (l == null)
          throw new Y("Expected group as " + t, this.fetch());
        return l;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new Y("Unknown group type as " + t, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(t, n) {
    var r = this.gullet.scanArgument(n);
    if (r == null)
      return null;
    for (var i = "", a; (a = this.fetch()).text !== "EOF"; )
      i += a.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(t, n) {
    for (var r = this.fetch(), i = r, a = "", l; (l = this.fetch()).text !== "EOF" && t.test(a + l.text); )
      i = l, a += i.text, this.consume();
    if (a === "")
      throw new Y("Invalid " + n + ": '" + r.text + "'", r);
    return r.range(i, a);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(t) {
    var n = this.parseStringGroup("color", t);
    if (n == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(n.text);
    if (!r)
      throw new Y("Invalid color: '" + n.text + "'", n);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(t) {
    var n, r = !1;
    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? n = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : n = this.parseStringGroup("size", t), !n)
      return null;
    !t && n.text.length === 0 && (n.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(n.text);
    if (!i)
      throw new Y("Invalid size: '" + n.text + "'", n);
    var a = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!s4(a))
      throw new Y("Invalid unit: '" + a.unit + "'", n);
    return {
      type: "size",
      mode: this.mode,
      value: a,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(t) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var n = this.parseStringGroup("url", t);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), n == null)
      return null;
    var r = n.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(t, n) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    var i = this.mode;
    n && this.switchMode(n), this.gullet.beginGroup();
    var a = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var l = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: a
    };
    return n && this.switchMode(i), l;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(t, n) {
    var r = this.fetch(), i = r.text, a;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var l = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var o = this.parseExpression(!1, l), s = this.fetch();
      this.expect(l), this.gullet.endGroup(), a = {
        type: "ordgroup",
        mode: this.mode,
        loc: Ft.range(r, s),
        body: o,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (a = this.parseFunction(n, t) || this.parseSymbol(), a == null && i[0] === "\\" && !Q4.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new Y("Undefined control sequence: " + i, r);
      a = this.formatUnsupportedCmd(i), this.consume();
    }
    return a;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(t) {
    for (var n = t.length - 1, r = 0; r < n; ++r) {
      var i = t[r], a = i.text;
      a === "-" && t[r + 1].text === "-" && (r + 1 < n && t[r + 2].text === "-" ? (t.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Ft.range(i, t[r + 2]),
        text: "---"
      }), n -= 2) : (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Ft.range(i, t[r + 1]),
        text: "--"
      }), n -= 1)), (a === "'" || a === "`") && t[r + 1].text === a && (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Ft.range(i, t[r + 1]),
        text: a + a
      }), n -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var t = this.fetch(), n = t.text;
    if (/^\\verb[^a-zA-Z]/.test(n)) {
      this.consume();
      var r = n.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new Y(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    hh.hasOwnProperty(n[0]) && !Ie[this.mode][n[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + n[0] + '" used in math mode', t), n = hh[n[0]] + n.slice(1));
    var a = Fx.exec(n);
    a && (n = n.substring(0, a.index), n === "i" ? n = "" : n === "j" && (n = ""));
    var l;
    if (Ie[this.mode][n]) {
      this.settings.strict && this.mode === "math" && Ou.indexOf(n) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + n[0] + '" used in math mode', t);
      var o = Ie[this.mode][n].group, s = Ft.range(t), u;
      if (Ow.hasOwnProperty(o)) {
        var c = o;
        u = {
          type: "atom",
          mode: this.mode,
          family: c,
          loc: s,
          text: n
        };
      } else
        u = {
          type: o,
          mode: this.mode,
          loc: s,
          text: n
        };
      l = u;
    } else if (n.charCodeAt(0) >= 128)
      this.settings.strict && (o4(n.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + n[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + n[0] + '"' + (" (" + n.charCodeAt(0) + ")"), t)), l = {
        type: "textord",
        mode: "text",
        loc: Ft.range(t),
        text: n
      };
    else
      return null;
    if (this.consume(), a)
      for (var d = 0; d < a[0].length; d++) {
        var h = a[0][d];
        if (!k0[h])
          throw new Y("Unknown accent ' " + h + "'", t);
        var p = k0[h][this.mode] || k0[h].text;
        if (!p)
          throw new Y("Accent " + h + " unsupported in " + this.mode + " mode", t);
        l = {
          type: "accent",
          mode: this.mode,
          loc: Ft.range(t),
          label: p,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: l
        };
      }
    return l;
  }
}
bs.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var gd = function(t, n) {
  if (!(typeof t == "string" || t instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new bs(t, n);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!n.displayMode)
      throw new Y("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new en("\\df@tag")])
    }];
  }
  return i;
}, J4 = function(t, n, r) {
  n.textContent = "";
  var i = vd(t, r).toNode();
  n.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), J4 = function() {
  throw new Y("KaTeX doesn't work in quirks mode.");
});
var Gx = function(t, n) {
  var r = vd(t, n).toMarkup();
  return r;
}, Vx = function(t, n) {
  var r = new Qc(n);
  return gd(t, r);
}, e2 = function(t, n, r) {
  if (r.throwOnError || !(t instanceof Y))
    throw t;
  var i = D.makeSpan(["katex-error"], [new rn(n)]);
  return i.setAttribute("title", t.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, vd = function(t, n) {
  var r = new Qc(n);
  try {
    var i = gd(t, r);
    return ex(i, t, r);
  } catch (a) {
    return e2(a, t, r);
  }
}, Wx = function(t, n) {
  var r = new Qc(n);
  try {
    var i = gd(t, r);
    return tx(i, t, r);
  } catch (a) {
    return e2(a, t, r);
  }
}, ph = {
  /**
   * Current KaTeX version
   */
  version: "0.16.11",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: J4,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: Gx,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: Y,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA: ao,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: Vx,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: vd,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Wx,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: Sw,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: f,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: J,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: k,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span: ol,
    Anchor: td,
    SymbolNode: rn,
    SvgNode: Yn,
    PathNode: Er,
    LineNode: Mu
  }
};
const Kx = {};
function Yx(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || Kx, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), l = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(j9(n)), a.push($9()), l.push(H9(n));
}
const mh = /[#.]/g;
function jx(e, t) {
  const n = e || "", r = {};
  let i = 0, a, l;
  for (; i < n.length; ) {
    mh.lastIndex = i;
    const o = mh.exec(n), s = n.slice(i, o ? o.index : n.length);
    s && (a ? a === "#" ? r.id = s : Array.isArray(r.className) ? r.className.push(s) : r.className = [s] : l = s, i += s.length), o && (a = o[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: l || t || "div",
    properties: r,
    children: []
  };
}
const Pu = {}.hasOwnProperty;
function t2(e, t, n) {
  const r = n && Jx(n);
  function i(a, l, ...o) {
    let s = -1, u;
    if (a == null) {
      u = { type: "root", children: [] };
      const c = (
        /** @type {Child} */
        l
      );
      o.unshift(c);
    } else if (u = jx(a, t), u.tagName = u.tagName.toLowerCase(), r && Pu.call(r, u.tagName) && (u.tagName = r[u.tagName]), Xx(l))
      o.unshift(l);
    else {
      let c;
      for (c in l)
        Pu.call(l, c) && Zx(e, u.properties, c, l[c]);
    }
    for (; ++s < o.length; )
      Bu(u.children, o[s]);
    return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
  }
  return i;
}
function Xx(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const i = t[r];
    if (i && typeof i == "object") {
      if (!Array.isArray(i)) return !0;
      const a = (
        /** @type {Array<unknown>} */
        i
      );
      for (const l of a)
        if (typeof l != "number" && typeof l != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function Zx(e, t, n, r) {
  const i = rg(e, n);
  let a = -1, l;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      l = r;
    } else typeof r == "boolean" ? l = r : typeof r == "string" ? i.spaceSeparated ? l = $f(r) : i.commaSeparated ? l = Lf(r) : i.commaOrSpaceSeparated ? l = $f(Lf(r).join(" ")) : l = gh(i, i.property, r) : Array.isArray(r) ? l = r.concat() : l = i.property === "style" ? Qx(r) : String(r);
    if (Array.isArray(l)) {
      const o = [];
      for (; ++a < l.length; ) {
        const s = (
          /** @type {number | string} */
          gh(i, i.property, l[a])
        );
        o[a] = s;
      }
      l = o;
    }
    if (i.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        l
      );
      l = t.className.concat(o);
    }
    t[i.property] = l;
  }
}
function Bu(e, t) {
  let n = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n < t.length; )
      Bu(e, t[n]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? Bu(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function gh(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Ga(n) === Ga(t)))
      return !0;
  }
  return n;
}
function Qx(e) {
  const t = [];
  let n;
  for (n in e)
    Pu.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function Jx(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const ek = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], tk = t2(ig, "div"), nk = t2(ls, "g", ek), E0 = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function rk(e, t) {
  return n2(e, {}) || { type: "root", children: [] };
}
function n2(e, t) {
  const n = ik(e, t);
  return n && t.afterTransform && t.afterTransform(e, n), n;
}
function ik(e, t) {
  switch (e.nodeType) {
    case 1:
      return sk(
        /** @type {Element} */
        e,
        t
      );
    case 3:
      return lk(
        /** @type {Text} */
        e
      );
    case 8:
      return ok(
        /** @type {Comment} */
        e
      );
    case 9:
      return vh(
        /** @type {Document} */
        e,
        t
      );
    case 10:
      return ak();
    case 11:
      return vh(
        /** @type {DocumentFragment} */
        e,
        t
      );
    default:
      return;
  }
}
function vh(e, t) {
  return { type: "root", children: r2(e, t) };
}
function ak() {
  return { type: "doctype" };
}
function lk(e) {
  return { type: "text", value: e.nodeValue || "" };
}
function ok(e) {
  return { type: "comment", value: e.nodeValue || "" };
}
function sk(e, t) {
  const n = e.namespaceURI, r = n === E0.svg ? nk : tk, i = n === E0.html ? e.tagName.toLowerCase() : e.tagName, a = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    n === E0.html && i === "template" ? e.content : e
  ), l = e.getAttributeNames(), o = {};
  let s = -1;
  for (; ++s < l.length; )
    o[l[s]] = e.getAttribute(l[s]) || "";
  return r(i, o, r2(a, t));
}
function r2(e, t) {
  const n = e.childNodes, r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const a = n2(n[i], t);
    a !== void 0 && r.push(a);
  }
  return r;
}
new DOMParser();
function uk(e, t) {
  const n = ck(e);
  return (
    /** @type {Root} */
    rk(n)
  );
}
function ck(e) {
  const t = document.createElement("template");
  return t.innerHTML = e, t.content;
}
const yh = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(e, t, n) {
    const r = il(n);
    if (!e || !e.type || !e.children)
      throw new Error("Expected parent node");
    if (typeof t == "number") {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (t = e.children.indexOf(t), t < 0)
      throw new Error("Expected child node or index");
    for (; ++t < e.children.length; )
      if (r(e.children[t], t, e))
        return e.children[t];
  }
), ti = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return hk;
    if (typeof e == "string")
      return fk(e);
    if (typeof e == "object")
      return dk(e);
    if (typeof e == "function")
      return yd(e);
    throw new Error("Expected function, string, or array as `test`");
  }
);
function dk(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = ti(e[n]);
  return yd(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function fk(e) {
  return yd(t);
  function t(n) {
    return n.tagName === e;
  }
}
function yd(e) {
  return t;
  function t(n, r, i) {
    return !!(pk(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function hk(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "element" && "tagName" in e && typeof e.tagName == "string");
}
function pk(e) {
  return e !== null && typeof e == "object" && "type" in e && "tagName" in e;
}
const bh = /\n/g, wh = /[\t ]+/g, Fu = ti("br"), xh = ti(xk), mk = ti("p"), kh = ti("tr"), gk = ti([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  wk,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  kk
]), i2 = ti([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function Uu(e, t) {
  const n = t || {}, r = "children" in e ? e.children : [], i = i2(e), a = o2(e, {
    whitespace: n.whitespace || "normal",
    breakBefore: !1,
    breakAfter: !1
  }), l = [];
  (e.type === "text" || e.type === "comment") && l.push(
    ...l2(e, {
      whitespace: a,
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let o = -1;
  for (; ++o < r.length; )
    l.push(
      ...a2(
        r[o],
        // @ts-expect-error: `tree` is a parent if were here.
        e,
        {
          whitespace: a,
          breakBefore: o ? void 0 : i,
          breakAfter: o < r.length - 1 ? Fu(r[o + 1]) : i
        }
      )
    );
  const s = [];
  let u;
  for (o = -1; ++o < l.length; ) {
    const c = l[o];
    typeof c == "number" ? u !== void 0 && c > u && (u = c) : c && (u !== void 0 && u > -1 && s.push(`
`.repeat(u) || " "), u = -1, s.push(c));
  }
  return s.join("");
}
function a2(e, t, n) {
  return e.type === "element" ? vk(e, t, n) : e.type === "text" ? n.whitespace === "normal" ? l2(e, n) : yk(e) : [];
}
function vk(e, t, n) {
  const r = o2(e, n), i = e.children || [];
  let a = -1, l = [];
  if (gk(e))
    return l;
  let o, s;
  for (Fu(e) || kh(e) && // @ts-expect-error: something up with types of parents.
  yh(t, e, kh) ? s = `
` : mk(e) ? (o = 2, s = 2) : i2(e) && (o = 1, s = 1); ++a < i.length; )
    l = l.concat(
      a2(i[a], e, {
        whitespace: r,
        breakBefore: a ? void 0 : o,
        breakAfter: a < i.length - 1 ? Fu(i[a + 1]) : s
      })
    );
  return xh(e) && // @ts-expect-error: something up with types of parents.
  yh(t, e, xh) && l.push("	"), o && l.unshift(o), s && l.push(s), l;
}
function l2(e, t) {
  const n = String(e.value), r = [], i = [];
  let a = 0;
  for (; a <= n.length; ) {
    bh.lastIndex = a;
    const s = bh.exec(n), u = s && "index" in s ? s.index : n.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      bk(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        n.slice(a, u).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        a === 0 ? t.breakBefore : !0,
        u === n.length ? t.breakAfter : !0
      )
    ), a = u + 1;
  }
  let l = -1, o;
  for (; ++l < r.length; )
    r[l].charCodeAt(r[l].length - 1) === 8203 || l < r.length - 1 && r[l + 1].charCodeAt(0) === 8203 ? (i.push(r[l]), o = void 0) : r[l] ? (typeof o == "number" && i.push(o), i.push(r[l]), o = 0) : (l === 0 || l === r.length - 1) && i.push(0);
  return i;
}
function yk(e) {
  return [String(e.value)];
}
function bk(e, t, n) {
  const r = [];
  let i = 0, a;
  for (; i < e.length; ) {
    wh.lastIndex = i;
    const l = wh.exec(e);
    a = l ? l.index : e.length, !i && !a && l && !t && r.push(""), i !== a && r.push(e.slice(i, a)), i = l ? a + l[0].length : a;
  }
  return i !== a && !n && r.push(""), r.join(" ");
}
function o2(e, t) {
  if (e.type === "element") {
    const n = e.properties || {};
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return n.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return n.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return t.whitespace;
}
function wk(e) {
  return !!(e.properties || {}).hidden;
}
function xk(e) {
  return e.tagName === "td" || e.tagName === "th";
}
function kk(e) {
  return e.tagName === "dialog" && !(e.properties || {}).open;
}
const Ek = {}, Sk = [];
function _k(e) {
  const t = e || Ek;
  return function(n, r) {
    Kc(n, "element", function(i, a) {
      const l = Array.isArray(i.properties.className) ? i.properties.className : Sk, o = l.includes("language-math"), s = l.includes("math-display"), u = l.includes("math-inline");
      let c = s;
      if (!o && !s && !u)
        return;
      let d = a[a.length - 1], h = i;
      if (i.tagName === "code" && o && d && d.type === "element" && d.tagName === "pre" && (h = d, d = a[a.length - 2], c = !0), !d) return;
      const p = Uu(h, { whitespace: "pre" });
      let g;
      try {
        g = ph.renderToString(p, {
          ...t,
          displayMode: c,
          throwOnError: !0
        });
      } catch (S) {
        const y = (
          /** @type {Error} */
          S
        ), v = y.name.toLowerCase();
        r.message("Could not render math with KaTeX", {
          ancestors: [...a, i],
          cause: y,
          place: i.position,
          ruleId: v,
          source: "rehype-katex"
        });
        try {
          g = ph.renderToString(p, {
            ...t,
            displayMode: c,
            strict: "ignore",
            throwOnError: !1
          });
        } catch {
          g = [
            {
              type: "element",
              tagName: "span",
              properties: {
                className: ["katex-error"],
                style: "color:" + (t.errorColor || "#cc0000"),
                title: String(S)
              },
              children: [{ type: "text", value: p }]
            }
          ];
        }
      }
      typeof g == "string" && (g = /** @type {Array<ElementContent>} */
      uk(g).children);
      const w = d.children.indexOf(h);
      return d.children.splice(w, 1, ...g), Dg;
    });
  };
}
function Tk(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", l = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", g = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], w = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], S = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], y = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], C = {
    type: w,
    keyword: g,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: S
  }, R = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: y
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, T = [
    R,
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], z = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: C,
    contains: T.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: C,
        contains: T.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, P = {
    className: "function",
    begin: "(" + l + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: C,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: C,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [h],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: C,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: C,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: C,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      z,
      P,
      R,
      T,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: C,
          contains: [
            "self",
            o
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: C
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Nk(e) {
  const t = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = Tk(e), r = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return r.type = [
    ...r.type,
    ...t.type
  ], r.literal = [
    ...r.literal,
    ...t.literal
  ], r.built_in = [
    ...r.built_in,
    ...t.built_in
  ], r._hints = t._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function Ak(e) {
  const t = e.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: t.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [e.BACKSLASH_ESCAPE]
  }, a = e.inherit(
    e.COMMENT(),
    {
      match: [
        /(^|\s)/,
        /#.*$/
      ],
      scope: {
        2: "comment"
      }
    }
  ), l = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      e.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, o = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      n,
      i
    ]
  };
  i.contains.push(o);
  const s = {
    match: /\\"/
  }, u = {
    className: "string",
    begin: /'/,
    end: /'/
  }, c = {
    match: /\\'/
  }, d = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      e.NUMBER_MODE,
      n
    ]
  }, h = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], p = e.SHEBANG({
    binary: `(${h.join("|")})`,
    relevance: 10
  }), g = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, w = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], S = [
    "true",
    "false"
  ], y = { match: /(\/[a-z._-]+)+/ }, v = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], x = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "sudo",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], C = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], R = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: [
      "sh",
      "zsh"
    ],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: w,
      literal: S,
      built_in: [
        ...v,
        ...x,
        // Shell modifiers
        "set",
        "shopt",
        ...C,
        ...R
      ]
    },
    contains: [
      p,
      // to catch known shells and boost relevancy
      e.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      g,
      d,
      a,
      l,
      y,
      o,
      s,
      u,
      c,
      n
    ]
  };
}
function Ck(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", l = "(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", S = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "typeof",
      "typeof_unqual",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_BitInt",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal96",
      "_Decimal128",
      "_Decimal64x",
      "_Decimal128x",
      "_Float16",
      "_Float32",
      "_Float64",
      "_Float128",
      "_Float32x",
      "_Float64x",
      "_Float128x",
      // modifiers
      "const",
      "static",
      "constexpr",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, y = [
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], v = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: S,
    contains: y.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: S,
        contains: y.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, x = {
    begin: "(" + l + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: S,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: S,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [e.inherit(h, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: S,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: S,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: S,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      v,
      x,
      y,
      [
        d,
        {
          begin: e.IDENT_RE + "::",
          keywords: S
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            e.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: u,
      keywords: S
    }
  };
}
function Mk(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", l = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", g = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], w = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], S = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], y = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], C = {
    type: w,
    keyword: g,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: S
  }, R = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: y
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, T = [
    R,
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], z = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: C,
    contains: T.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: C,
        contains: T.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, P = {
    className: "function",
    begin: "(" + l + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: C,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: C,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [h],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: C,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: C,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: C,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      z,
      P,
      R,
      T,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: C,
          contains: [
            "self",
            o
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: C
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Ok(e) {
  const t = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], i = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], a = [
    "add",
    "alias",
    "and",
    "ascending",
    "async",
    "await",
    "by",
    "descending",
    "equals",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "remove",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], l = {
    keyword: i.concat(a),
    built_in: t,
    literal: r
  }, o = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), s = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, u = {
    className: "string",
    begin: /"""("*)(?!")(.|\n)*?"""\1/,
    relevance: 1
  }, c = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, d = e.inherit(c, { illegal: /\n/ }), h = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: l
  }, p = e.inherit(h, { illegal: /\n/ }), g = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      e.BACKSLASH_ESCAPE,
      p
    ]
  }, w = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      h
    ]
  }, S = e.inherit(w, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      p
    ]
  });
  h.contains = [
    w,
    g,
    c,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    s,
    e.C_BLOCK_COMMENT_MODE
  ], p.contains = [
    S,
    g,
    d,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    s,
    e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const y = { variants: [
    u,
    w,
    g,
    c,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ] }, v = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      o
    ]
  }, x = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?", C = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + e.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: l,
    illegal: /::/,
    contains: [
      e.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      y,
      s,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          o,
          v,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          o,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          o,
          v,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + x + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: l,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              e.TITLE_MODE,
              v
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: l,
            relevance: 0,
            contains: [
              y,
              s,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      C
    ]
  };
}
const Rk = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Ik = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], Dk = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], zk = [
  ...Ik,
  ...Dk
], Lk = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), Pk = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), Bk = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), Fk = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "appearance",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "cx",
  "cy",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "flood-color",
  "flood-opacity",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "kerning",
  "justify-content",
  "justify-items",
  "justify-self",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "scale",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-anchor",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "vector-effect",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index"
].sort().reverse();
function Uk(e) {
  const t = e.regex, n = Rk(e), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", a = /@-?\w[\w]*(-\w+)*/, l = "[a-zA-Z-][a-zA-Z0-9_-]*", o = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + l,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + Pk.join("|") + ")" },
          { begin: ":(:)?(" + Bk.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + Fk.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...o,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...o,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: t.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: a
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: Lk.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...o,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + zk.join("|") + ")\\b"
      }
    ]
  };
}
function $k(e) {
  const t = e.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: t.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: t.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function Hk(e) {
  const a = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: a,
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            // hex without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            // hex with a present digit before . (making a digit afterwards optional)
            relevance: 0
          },
          {
            match: /-?\b0[oO](_?[0-7])*i?/,
            // leading 0o octal
            relevance: 0
          },
          {
            match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
            // decimal without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            // decimal with a present digit before . (making a digit afterwards optional)
            relevance: 0
          }
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          e.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: a,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function qk(e) {
  const t = e.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      e.HASH_COMMENT_MODE,
      e.QUOTE_STRING_MODE,
      e.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: t.concat(n, t.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function Gk(e) {
  const t = e.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: e.NUMBER_RE }
    ]
  }, r = e.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, a = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, l = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, o = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      a,
      i,
      l,
      n,
      "self"
    ],
    relevance: 0
  }, s = /[A-Za-z0-9_-]+/, u = /"(\\"|[^"])*"/, c = /'[^']*'/, d = t.either(
    s,
    u,
    c
  ), h = t.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    t.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: h,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            o,
            a,
            i,
            l,
            n
          ]
        }
      }
    ]
  };
}
var ci = "[0-9](_*[0-9])*", Fl = `\\.(${ci})`, Ul = "[0-9a-fA-F](_*[0-9a-fA-F])*", Eh = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${ci})((${Fl})|\\.)?|(${Fl}))[eE][+-]?(${ci})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${ci})((${Fl})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Fl})[fFdD]?\\b` },
    { begin: `\\b(${ci})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Ul})\\.?|(${Ul})?\\.(${Ul}))[pP][+-]?(${ci})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Ul})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function s2(e, t, n) {
  return n === -1 ? "" : e.replace(t, (r) => s2(e, t, n - 1));
}
function Vk(e) {
  const t = e.regex, n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", r = n + s2("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), s = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits",
      "goto"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, u = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, c = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: s,
    relevance: 0,
    contains: [e.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: s,
    illegal: /<\/|#/,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [e.BACKSLASH_ESCAPE]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          t.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          c,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          e.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: s,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: s,
            relevance: 0,
            contains: [
              u,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              Eh,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      Eh,
      u
    ]
  };
}
const Sh = "[A-Za-z$_][0-9A-Za-z$_]*", Wk = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Kk = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], u2 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], c2 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], d2 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Yk = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], jk = [].concat(
  d2,
  u2,
  c2
);
function Xk(e) {
  const t = e.regex, n = (I, { after: $ }) => {
    const E = "</" + I[0].slice(1);
    return I.input.indexOf(E, $) !== -1;
  }, r = Sh, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, l = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (I, $) => {
      const E = I[0].length + I.index, Z = I.input[E];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        Z === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        Z === ","
      ) {
        $.ignoreMatch();
        return;
      }
      Z === ">" && (n(I, { after: E }) || $.ignoreMatch());
      let ee;
      const A = I.input.substring(E);
      if (ee = A.match(/^\s*=/)) {
        $.ignoreMatch();
        return;
      }
      if ((ee = A.match(/^\s+extends\s+/)) && ee.index === 0) {
        $.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: Sh,
    keyword: Wk,
    literal: Kk,
    built_in: jk,
    "variable.language": Yk
  }, s = "[0-9](_?[0-9])*", u = `\\.(${s})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${s})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, h = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "xml"
    }
  }, g = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "css"
    }
  }, w = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "graphql"
    }
  }, S = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      h
    ]
  }, v = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, x = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    g,
    w,
    S,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  h.contains = x.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(x)
  });
  const C = [].concat(v, h.contains), R = C.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(C)
    }
  ]), T = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with 
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: R
  }, z = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, P = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...u2,
        ...c2
      ]
    }
  }, U = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, O = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [T],
    illegal: /%/
  }, V = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function K(I) {
    return t.concat("(?!", I.join("|"), ")");
  }
  const ae = {
    match: t.concat(
      /\b/,
      K([
        ...d2,
        "super",
        "import"
      ].map((I) => `${I}\\s*\\(`)),
      r,
      t.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, ie = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, re = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      T
    ]
  }, ge = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", B = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead(ge)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      T
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: R, CLASS_REFERENCE: P },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      U,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      w,
      S,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      P,
      {
        className: "attr",
        begin: r + t.lookahead(":"),
        relevance: 0
      },
      B,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ge,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: R
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: l.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": l.isTrulyOpeningTag,
                end: l.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: l.begin,
                end: l.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      O,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          T,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      ie,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [T]
      },
      ae,
      V,
      z,
      re,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Zk(e) {
  const t = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: {
      literal: r
    },
    contains: [
      t,
      n,
      e.QUOTE_STRING_MODE,
      i,
      e.C_NUMBER_MODE,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var di = "[0-9](_*[0-9])*", $l = `\\.(${di})`, Hl = "[0-9a-fA-F](_*[0-9a-fA-F])*", Qk = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${di})((${$l})|\\.)?|(${$l}))[eE][+-]?(${di})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${di})((${$l})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${$l})[fFdD]?\\b` },
    { begin: `\\b(${di})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Hl})\\.?|(${Hl})?\\.(${Hl}))[pP][+-]?(${di})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Hl})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function Jk(e) {
  const t = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: e.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [e.C_NUMBER_MODE]
  }, a = {
    className: "variable",
    begin: "\\$" + e.UNDERSCORE_IDENT_RE
  }, l = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          a,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          e.BACKSLASH_ESCAPE,
          a,
          i
        ]
      }
    ]
  };
  i.contains.push(l);
  const o = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e.UNDERSCORE_IDENT_RE + ")?"
  }, s = {
    className: "meta",
    begin: "@" + e.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          e.inherit(l, { className: "string" }),
          "self"
        ]
      }
    ]
  }, u = Qk, c = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [e.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: e.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, h = d;
  return h.variants[1].contains = [d], d.variants[1].contains = [h], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: t,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      c,
      n,
      r,
      o,
      s,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: t,
        relevance: 5,
        contains: [
          {
            begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [e.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: t,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  e.C_LINE_COMMENT_MODE,
                  c
                ],
                relevance: 0
              },
              e.C_LINE_COMMENT_MODE,
              c,
              o,
              s,
              l,
              e.C_NUMBER_MODE
            ]
          },
          c
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          e.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          o,
          s
        ]
      },
      l,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      u
    ]
  };
}
const eE = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), tE = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], nE = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], rE = [
  ...tE,
  ...nE
], iE = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), f2 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), h2 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), aE = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "appearance",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "cx",
  "cy",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "flood-color",
  "flood-opacity",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "kerning",
  "justify-content",
  "justify-items",
  "justify-self",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "scale",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-anchor",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "vector-effect",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index"
].sort().reverse(), lE = f2.concat(h2).sort().reverse();
function oE(e) {
  const t = eE(e), n = lE, r = "and or not only", i = "[\\w-]+", a = "(" + i + "|@\\{" + i + "\\})", l = [], o = [], s = function(x) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + x + ".*?" + x
    };
  }, u = function(x, C, R) {
    return {
      className: x,
      begin: C,
      relevance: R
    };
  }, c = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: iE.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: o,
    keywords: c,
    relevance: 0
  };
  o.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    s("'"),
    s('"'),
    t.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    t.HEXCOLOR,
    d,
    u("variable", "@@?" + i, 10),
    u("variable", "@\\{" + i + "\\}"),
    u("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    t.IMPORTANT,
    { beginKeywords: "and not" },
    t.FUNCTION_DISPATCH
  );
  const h = o.concat({
    begin: /\{/,
    end: /\}/,
    contains: l
  }), p = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(o)
    // using this form to override VALUEs 'function' match
  }, g = {
    begin: a + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + aE.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: o
        }
      }
    ]
  }, w = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: c,
      returnEnd: !0,
      contains: o,
      relevance: 0
    }
  }, S = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (well still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: h
    }
  }, y = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: a,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      p,
      u("keyword", "all\\b"),
      u("variable", "@\\{" + i + "\\}"),
      // otherwise its identified as tag
      {
        begin: "\\b(" + rE.join("|") + ")\\b",
        className: "selector-tag"
      },
      t.CSS_NUMBER_MODE,
      u("selector-tag", a, 0),
      u("selector-id", "#" + a),
      u("selector-class", "\\." + a, 0),
      u("selector-tag", "&", 0),
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + f2.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + h2.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: h
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      t.FUNCTION_DISPATCH
    ]
  }, v = {
    begin: i + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [y]
  };
  return l.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    w,
    S,
    v,
    g,
    y,
    p,
    t.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: l
  };
}
function sE(e) {
  const t = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: t,
    end: n,
    contains: ["self"]
  }, i = [
    e.COMMENT("--(?!" + t + ")", "$"),
    e.COMMENT(
      "--" + t,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    keywords: {
      $pattern: e.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          e.inherit(e.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      e.C_NUMBER_MODE,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: t,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function uE(e) {
  const t = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
        contains: [e.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      t
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [t]
  }, i = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, a = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, l = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [t]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      e.HASH_COMMENT_MODE,
      t,
      n,
      r,
      i,
      a,
      l
    ]
  };
}
function cE(e) {
  const t = e.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, a = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, l = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, o = /[A-Za-z][A-Za-z0-9+.-]*/, s = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: t.concat(/\[.+?\]\(/, o, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, u = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, c = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = e.inherit(u, { contains: [] }), h = e.inherit(c, { contains: [] });
  u.contains.push(h), c.contains.push(d);
  let p = [
    n,
    s
  ];
  return [
    u,
    c,
    d,
    h
  ].forEach((y) => {
    y.contains = y.contains.concat(p);
  }), p = p.concat(u, c), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: p
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: p
              }
            ]
          }
        ]
      },
      n,
      a,
      u,
      c,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: p,
        end: "$"
      },
      i,
      r,
      s,
      l,
      {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      }
    ]
  };
}
function dE(e) {
  const t = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, o = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, s = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: o,
    illegal: "</",
    contains: [
      t,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      e.C_NUMBER_MODE,
      e.QUOTE_STRING_MODE,
      e.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [e.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + s.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: s,
        contains: [e.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + e.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function fE(e) {
  const t = e.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "class",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "field",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "method",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, a = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, l = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, o = {
    scope: "attr",
    match: /\s+:\s*\w+(\s*\(.*?\))?/
  }, s = {
    scope: "variable",
    variants: [
      { begin: /\$\d/ },
      {
        begin: t.concat(
          /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![A-Za-z])(?![@$%])"
        )
      },
      {
        // Only $= is a special Perl variable and one can't declare @= or %=.
        begin: /[$%@](?!")[^\s\w{=]|\$=/,
        relevance: 0
      }
    ],
    contains: [o]
  }, u = {
    className: "number",
    variants: [
      // decimal numbers:
      // include the case where a number starts with a dot (eg. .9), and
      // the leading 0? avoids mixing the first and second match on 0.x cases
      { match: /0?\.[0-9][0-9_]+\b/ },
      // include the special versioned number (eg. v5.38)
      { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
      // non-decimal numbers:
      { match: /\b0[0-7][0-7_]*\b/ },
      { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
      { match: /\b0b[0-1][0-1_]*\b/ }
    ],
    relevance: 0
  }, c = [
    e.BACKSLASH_ESCAPE,
    a,
    s
  ], d = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], h = (w, S, y = "\\1") => {
    const v = y === "\\1" ? y : t.concat(y, S);
    return t.concat(
      t.concat("(?:", w, ")"),
      S,
      /(?:\\.|[^\\\/])*?/,
      v,
      /(?:\\.|[^\\\/])*?/,
      y,
      r
    );
  }, p = (w, S, y) => t.concat(
    t.concat("(?:", w, ")"),
    S,
    /(?:\\.|[^\\\/])*?/,
    y,
    r
  ), g = [
    s,
    e.HASH_COMMENT_MODE,
    e.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    l,
    {
      className: "string",
      contains: c,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    u,
    {
      // regexp container
      begin: "(\\/\\/|" + e.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        e.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: h("s|tr|y", t.either(...d, { capture: !0 })) },
            // and then paired delmis
            { begin: h("s|tr|y", "\\(", "\\)") },
            { begin: h("s|tr|y", "\\[", "\\]") },
            { begin: h("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: p("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: p("m|qr", t.either(...d, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: p("m|qr", /\(/, /\)/) },
            { begin: p("m|qr", /\[/, /\]/) },
            { begin: p("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub method",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [e.TITLE_MODE, o]
    },
    {
      className: "class",
      beginKeywords: "class",
      end: "[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [e.TITLE_MODE, o, u]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return a.contains = g, l.contains = g, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: g
  };
}
function hE(e) {
  const t = e.regex, n = /(?![A-Za-z0-9])(?![$])/, r = t.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), i = t.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), a = {
    scope: "variable",
    match: "\\$+" + r
  }, l = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, o = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, s = e.inherit(e.APOS_STRING_MODE, { illegal: null }), u = e.inherit(e.QUOTE_STRING_MODE, {
    illegal: null,
    contains: e.QUOTE_STRING_MODE.contains.concat(o)
  }), c = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: e.QUOTE_STRING_MODE.contains.concat(o),
    "on:begin": (ae, ie) => {
      ie.data._beginMatch = ae[1] || ae[2];
    },
    "on:end": (ae, ie) => {
      ie.data._beginMatch !== ae[1] && ie.ignoreMatch();
    }
  }, d = e.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), h = `[ 	
]`, p = {
    scope: "string",
    variants: [
      u,
      s,
      c,
      d
    ]
  }, g = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, w = [
    "false",
    "null",
    "true"
  ], S = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], y = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], x = {
    keyword: S,
    literal: ((ae) => {
      const ie = [];
      return ae.forEach((re) => {
        ie.push(re), re.toLowerCase() === re ? ie.push(re.toUpperCase()) : ie.push(re.toLowerCase());
      }), ie;
    })(w),
    built_in: y
  }, C = (ae) => ae.map((ie) => ie.replace(/\|\d+$/, "")), R = { variants: [
    {
      match: [
        /new/,
        t.concat(h, "+"),
        // to prevent built ins from being confused as the class constructor call
        t.concat("(?!", C(y).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, T = t.concat(r, "\\b(?!\\()"), z = { variants: [
    {
      match: [
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        T
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        T
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        t.concat(
          "::",
          t.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, P = {
    scope: "attr",
    match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/))
  }, U = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: x,
    contains: [
      P,
      a,
      z,
      e.C_BLOCK_COMMENT_MODE,
      p,
      g,
      R
    ]
  }, O = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      t.concat("(?!fn\\b|function\\b|", C(S).join("\\b|"), "|", C(y).join("\\b|"), "\\b)"),
      r,
      t.concat(h, "*"),
      t.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [U]
  };
  U.contains.push(O);
  const V = [
    P,
    z,
    e.C_BLOCK_COMMENT_MODE,
    p,
    g,
    R
  ], K = {
    begin: t.concat(/#\[\s*/, i),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: w,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: w,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...V
        ]
      },
      ...V,
      {
        scope: "meta",
        match: i
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: x,
    contains: [
      K,
      e.HASH_COMMENT_MODE,
      e.COMMENT("//", "$"),
      e.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: e.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      l,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      a,
      O,
      z,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      R,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          e.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: x,
            contains: [
              "self",
              a,
              z,
              e.C_BLOCK_COMMENT_MODE,
              p,
              g
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      p,
      g
    ]
  };
}
function pE(e) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          e.inherit(e.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          e.inherit(e.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function mE(e) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function gE(e) {
  const t = e.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], o = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, s = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, u = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o,
    illegal: /#/
  }, c = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          s
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          s
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          s,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          s,
          c,
          u
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          e.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          e.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  }, h = "[0-9](_?[0-9])*", p = `(\\b(${h}))?\\.(${h})|\\b(${h})\\.`, g = `\\b|${r.join("|")}`, w = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${h})|(${p}))[eE][+-]?(${h})[jJ]?(?=${g})`
      },
      {
        begin: `(${p})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${g})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${g})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${g})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${g})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${h})[jJ](?=${g})`
      }
    ]
  }, S = {
    className: "comment",
    begin: t.lookahead(/# type:/),
    end: /$/,
    keywords: o,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, y = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: o,
        contains: [
          "self",
          s,
          w,
          d,
          e.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return u.contains = [
    d,
    w,
    s
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: o,
    illegal: /(<\/|\?)|=>/,
    contains: [
      s,
      w,
      {
        // very common convention
        scope: "variable.language",
        match: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      { match: /\bor\b/, scope: "keyword" },
      d,
      S,
      e.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [y]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          w,
          y,
          d
        ]
      }
    ]
  };
}
function vE(e) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function yE(e) {
  const t = e.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = t.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, a = t.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      e.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldnt be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: t.lookahead(t.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      e.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              a,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: i },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: a
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function bE(e) {
  const t = e.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = t.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = t.concat(r, /(::\w+)*/), l = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, o = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, s = {
    begin: "#<",
    end: ">"
  }, u = [
    e.COMMENT(
      "#",
      "$",
      { contains: [o] }
    ),
    e.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [o],
        relevance: 10
      }
    ),
    e.COMMENT("^__END__", e.MATCH_NOTHING_RE)
  ], c = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: l
  }, d = {
    className: "string",
    contains: [
      e.BACKSLASH_ESCAPE,
      c
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: t.concat(
          /<<[-~]?'?/,
          t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          e.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              e.BACKSLASH_ESCAPE,
              c
            ]
          })
        ]
      }
    ]
  }, h = "[1-9](_?[0-9])*|0", p = "[0-9](_?[0-9])*", g = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${h})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, w = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: l
      }
    ]
  }, T = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: l
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: l
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        w
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: e.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: n }
      ],
      relevance: 0
    },
    g,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: l
    },
    {
      // regexp container
      begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            e.BACKSLASH_ESCAPE,
            c
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(s, u),
      relevance: 0
    }
  ].concat(s, u);
  c.contains = T, w.contains = T;
  const O = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: T
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: l,
        contains: T
      }
    }
  ];
  return u.unshift(s), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: l,
    illegal: /\/\*/,
    contains: [e.SHEBANG({ binary: "ruby" })].concat(O).concat(u).concat(T)
  };
}
function wE(e) {
  const t = e.regex, n = /(r#)?/, r = t.concat(n, e.UNDERSCORE_IDENT_RE), i = t.concat(n, e.IDENT_RE), a = {
    className: "title.function.invoke",
    relevance: 0,
    begin: t.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      i,
      t.lookahead(/\s*\(/)
    )
  }, l = "([ui](8|16|32|64|128|size)|f(32|64))?", o = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "union",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], s = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], u = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], c = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: e.IDENT_RE + "!?",
      type: c,
      keyword: o,
      literal: s,
      built_in: u
    },
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      e.inherit(e.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + l },
          { begin: "\\b0o([0-7_]+)" + l },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + l },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + l }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [
              e.BACKSLASH_ESCAPE
            ]
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          r
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          r,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: e.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: u,
          type: c
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      a
    ]
  };
}
const xE = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), kE = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], EE = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], SE = [
  ...kE,
  ...EE
], _E = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), TE = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), NE = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), AE = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "appearance",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "cx",
  "cy",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "flood-color",
  "flood-opacity",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "kerning",
  "justify-content",
  "justify-items",
  "justify-self",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "scale",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-anchor",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "vector-effect",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index"
].sort().reverse();
function CE(e) {
  const t = xE(e), n = NE, r = TE, i = "@[a-z-]+", a = "and or not only", o = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      t.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + SE.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      o,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [t.CSS_NUMBER_MODE]
      },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + AE.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          t.BLOCK_COMMENT,
          o,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.IMPORTANT,
          t.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: a,
          attribute: _E.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          o,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE
        ]
      },
      t.FUNCTION_DISPATCH
    ]
  };
}
function ME(e) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function OE(e) {
  const t = e.regex, n = e.COMMENT("--", "$"), r = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  }, a = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], l = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], o = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], s = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], u = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], c = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], h = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], p = c, g = [
    ...u,
    ...s
  ].filter((x) => !c.includes(x)), w = {
    className: "variable",
    begin: /@[a-z0-9][a-z0-9_]*/
  }, S = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, y = {
    begin: t.concat(/\b/, t.either(...p), /\s*\(/),
    relevance: 0,
    keywords: { built_in: p }
  };
  function v(x, {
    exceptions: C,
    when: R
  } = {}) {
    const T = R;
    return C = C || [], x.map((z) => z.match(/\|\d+$/) || C.includes(z) ? z : T(z) ? `${z}|0` : z);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: v(g, { when: (x) => x.length < 3 }),
      literal: a,
      type: o,
      built_in: d
    },
    contains: [
      {
        begin: t.either(...h),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: g.concat(h),
          literal: a,
          type: o
        }
      },
      {
        className: "type",
        begin: t.either(...l)
      },
      y,
      w,
      r,
      i,
      e.C_NUMBER_MODE,
      e.C_BLOCK_COMMENT_MODE,
      n,
      S
    ]
  };
}
function p2(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function sa(e) {
  return Ne("(?=", e, ")");
}
function Ne(...e) {
  return e.map((n) => p2(n)).join("");
}
function RE(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function yt(...e) {
  return "(" + (RE(e).capture ? "" : "?:") + e.map((r) => p2(r)).join("|") + ")";
}
const bd = (e) => Ne(
  /\b/,
  e,
  /\w$/.test(e) ? /\b/ : /\B/
), IE = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(bd), _h = [
  "init",
  "self"
].map(bd), DE = [
  "Any",
  "Self"
], S0 = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "package",
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], Th = [
  "false",
  "nil",
  "true"
], zE = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], LE = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], Nh = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], m2 = yt(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), g2 = yt(
  m2,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), _0 = Ne(m2, g2, "*"), v2 = yt(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Ho = yt(
  v2,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), xn = Ne(v2, Ho, "*"), ql = Ne(/[A-Z]/, Ho, "*"), PE = [
  "attached",
  "autoclosure",
  Ne(/convention\(/, yt("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  Ne(/objc\(/, xn, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], BE = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function FE(e) {
  const t = {
    match: /\s+/,
    relevance: 0
  }, n = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    e.C_LINE_COMMENT_MODE,
    n
  ], i = {
    match: [
      /\./,
      yt(...IE, ..._h)
    ],
    className: { 2: "keyword" }
  }, a = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: Ne(/\./, yt(...S0)),
    relevance: 0
  }, l = S0.filter((ye) => typeof ye == "string").concat(["_|0"]), o = S0.filter((ye) => typeof ye != "string").concat(DE).map(bd), s = { variants: [
    {
      className: "keyword",
      match: yt(...o, ..._h)
    }
  ] }, u = {
    $pattern: yt(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: l.concat(LE),
    literal: Th
  }, c = [
    i,
    a,
    s
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: Ne(/\./, yt(...Nh)),
    relevance: 0
  }, h = {
    className: "built_in",
    match: Ne(/\b/, yt(...Nh), /(?=\()/)
  }, p = [
    d,
    h
  ], g = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, w = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: _0 },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${g2})+`
      }
    ]
  }, S = [
    g,
    w
  ], y = "([0-9]_*)+", v = "([0-9a-fA-F]_*)+", x = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${y})(\\.(${y}))?([eE][+-]?(${y}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${v})(\\.(${v}))?([pP][+-]?(${y}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, C = (ye = "") => ({
    className: "subst",
    variants: [
      { match: Ne(/\\/, ye, /[0\\tnr"']/) },
      { match: Ne(/\\/, ye, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), R = (ye = "") => ({
    className: "subst",
    match: Ne(/\\/, ye, /[\t ]*(?:[\r\n]|\r\n)/)
  }), T = (ye = "") => ({
    className: "subst",
    label: "interpol",
    begin: Ne(/\\/, ye, /\(/),
    end: /\)/
  }), z = (ye = "") => ({
    begin: Ne(ye, /"""/),
    end: Ne(/"""/, ye),
    contains: [
      C(ye),
      R(ye),
      T(ye)
    ]
  }), P = (ye = "") => ({
    begin: Ne(ye, /"/),
    end: Ne(/"/, ye),
    contains: [
      C(ye),
      T(ye)
    ]
  }), U = {
    className: "string",
    variants: [
      z(),
      z("#"),
      z("##"),
      z("###"),
      P(),
      P("#"),
      P("##"),
      P("###")
    ]
  }, O = [
    e.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [e.BACKSLASH_ESCAPE]
    }
  ], V = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: O
  }, K = (ye) => {
    const zt = Ne(ye, /\//), Ge = Ne(/\//, ye);
    return {
      begin: zt,
      end: Ge,
      contains: [
        ...O,
        {
          scope: "comment",
          begin: `#(?!.*${Ge})`,
          end: /$/
        }
      ]
    };
  }, ae = {
    scope: "regexp",
    variants: [
      K("###"),
      K("##"),
      K("#"),
      V
    ]
  }, ie = { match: Ne(/`/, xn, /`/) }, re = {
    className: "variable",
    match: /\$\d+/
  }, ge = {
    className: "variable",
    match: `\\$${Ho}+`
  }, B = [
    ie,
    re,
    ge
  ], I = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: BE,
        contains: [
          ...S,
          x,
          U
        ]
      }
    ] }
  }, $ = {
    scope: "keyword",
    match: Ne(/@/, yt(...PE), sa(yt(/\(/, /\s+/)))
  }, E = {
    scope: "meta",
    match: Ne(/@/, xn)
  }, Z = [
    I,
    $,
    E
  ], ee = {
    match: sa(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: Ne(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Ho, "+")
      },
      {
        // Type identifier
        className: "type",
        match: ql,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: Ne(/\s+&\s+/, sa(ql)),
        relevance: 0
      }
    ]
  }, A = {
    begin: /</,
    end: />/,
    keywords: u,
    contains: [
      ...r,
      ...c,
      ...Z,
      g,
      ee
    ]
  };
  ee.contains.push(A);
  const Se = {
    match: Ne(xn, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, xe = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: u,
    contains: [
      "self",
      Se,
      ...r,
      ae,
      ...c,
      ...p,
      ...S,
      x,
      U,
      ...B,
      ...Z,
      ee
    ]
  }, he = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      ee
    ]
  }, qe = {
    begin: yt(
      sa(Ne(xn, /\s*:/)),
      sa(Ne(xn, /\s+/, xn, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: xn
      }
    ]
  }, Ke = {
    begin: /\(/,
    end: /\)/,
    keywords: u,
    contains: [
      qe,
      ...r,
      ...c,
      ...S,
      x,
      U,
      ...Z,
      ee,
      xe
    ],
    endsParent: !0,
    illegal: /["']/
  }, ut = {
    match: [
      /(func|macro)/,
      /\s+/,
      yt(ie.match, xn, _0)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      he,
      Ke,
      t
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, gt = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      he,
      Ke,
      t
    ],
    illegal: /\[|%/
  }, vn = {
    match: [
      /operator/,
      /\s+/,
      _0
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, Mr = {
    begin: [
      /precedencegroup/,
      /\s+/,
      ql
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [ee],
    keywords: [
      ...zE,
      ...Th
    ],
    end: /}/
  }, Or = {
    begin: [
      /(struct|protocol|class|extension|enum|actor)/,
      /\s+/,
      xn,
      /\s*/
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    },
    keywords: u,
    contains: [
      he,
      ...c,
      {
        begin: /:/,
        end: /\{/,
        keywords: u,
        contains: [
          {
            scope: "title.class.inherited",
            match: ql
          },
          ...c
        ],
        relevance: 0
      }
    ]
  };
  for (const ye of U.variants) {
    const zt = ye.contains.find((yn) => yn.label === "interpol");
    zt.keywords = u;
    const Ge = [
      ...c,
      ...p,
      ...S,
      x,
      U,
      ...B
    ];
    zt.contains = [
      ...Ge,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...Ge
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: u,
    contains: [
      ...r,
      ut,
      gt,
      Or,
      vn,
      Mr,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      ae,
      ...c,
      ...p,
      ...S,
      x,
      U,
      ...B,
      ...Z,
      ee,
      xe
    ]
  };
}
const qo = "[A-Za-z$_][0-9A-Za-z$_]*", y2 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], b2 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], w2 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], x2 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], k2 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], E2 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], S2 = [].concat(
  k2,
  w2,
  x2
);
function UE(e) {
  const t = e.regex, n = (I, { after: $ }) => {
    const E = "</" + I[0].slice(1);
    return I.input.indexOf(E, $) !== -1;
  }, r = qo, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, l = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (I, $) => {
      const E = I[0].length + I.index, Z = I.input[E];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        Z === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        Z === ","
      ) {
        $.ignoreMatch();
        return;
      }
      Z === ">" && (n(I, { after: E }) || $.ignoreMatch());
      let ee;
      const A = I.input.substring(E);
      if (ee = A.match(/^\s*=/)) {
        $.ignoreMatch();
        return;
      }
      if ((ee = A.match(/^\s+extends\s+/)) && ee.index === 0) {
        $.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: qo,
    keyword: y2,
    literal: b2,
    built_in: S2,
    "variable.language": E2
  }, s = "[0-9](_?[0-9])*", u = `\\.(${s})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${s})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, h = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "xml"
    }
  }, g = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "css"
    }
  }, w = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "graphql"
    }
  }, S = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      h
    ]
  }, v = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, x = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    g,
    w,
    S,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  h.contains = x.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(x)
  });
  const C = [].concat(v, h.contains), R = C.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(C)
    }
  ]), T = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with 
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: R
  }, z = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, P = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...w2,
        ...x2
      ]
    }
  }, U = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, O = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [T],
    illegal: /%/
  }, V = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function K(I) {
    return t.concat("(?!", I.join("|"), ")");
  }
  const ae = {
    match: t.concat(
      /\b/,
      K([
        ...k2,
        "super",
        "import"
      ].map((I) => `${I}\\s*\\(`)),
      r,
      t.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, ie = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, re = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      T
    ]
  }, ge = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", B = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead(ge)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      T
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: R, CLASS_REFERENCE: P },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      U,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      w,
      S,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      P,
      {
        className: "attr",
        begin: r + t.lookahead(":"),
        relevance: 0
      },
      B,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ge,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: R
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: l.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": l.isTrulyOpeningTag,
                end: l.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: l.begin,
                end: l.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      O,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          T,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      ie,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [T]
      },
      ae,
      V,
      z,
      re,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function $E(e) {
  const t = UE(e), n = qo, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], i = {
    begin: [
      /namespace/,
      /\s+/,
      e.IDENT_RE
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    }
  }, a = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [t.exports.CLASS_REFERENCE]
  }, l = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, o = [
    "type",
    // "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override",
    "satisfies"
  ], s = {
    $pattern: qo,
    keyword: y2.concat(o),
    literal: b2,
    built_in: S2.concat(r),
    "variable.language": E2
  }, u = {
    className: "meta",
    begin: "@" + n
  }, c = (p, g, w) => {
    const S = p.contains.findIndex((y) => y.label === g);
    if (S === -1)
      throw new Error("can not find mode to replace");
    p.contains.splice(S, 1, w);
  };
  Object.assign(t.keywords, s), t.exports.PARAMS_CONTAINS.push(u);
  const d = t.contains.find((p) => p.className === "attr");
  t.exports.PARAMS_CONTAINS.push([
    t.exports.CLASS_REFERENCE,
    // class reference for highlighting the params types
    d
    // highlight the params key
  ]), t.contains = t.contains.concat([
    u,
    i,
    a
  ]), c(t, "shebang", e.SHEBANG()), c(t, "use_strict", l);
  const h = t.contains.find((p) => p.label === "func.def");
  return h.relevance = 0, Object.assign(t, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), t;
}
function HE(e) {
  const t = e.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, a = /\d{4}-\d{1,2}-\d{1,2}/, l = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, o = /\d{1,2}(:\d{1,2}){1,2}/, s = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: t.concat(/# */, t.either(a, i), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: t.concat(/# */, o, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: t.concat(/# */, l, / *#/)
      },
      {
        // date plus time
        begin: t.concat(
          /# */,
          t.either(a, i),
          / +/,
          t.either(l, o),
          / *#/
        )
      }
    ]
  }, u = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, c = {
    className: "label",
    begin: /^\w+:/
  }, d = e.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), h = e.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      s,
      u,
      c,
      d,
      h,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [h]
      }
    ]
  };
}
function qE(e) {
  e.regex;
  const t = e.COMMENT(/\(;/, /;\)/);
  t.contains.push("self");
  const n = e.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], i = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, a = {
    className: "variable",
    begin: /\$[\w_]+/
  }, l = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, o = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, s = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, u = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      n,
      t,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      a,
      l,
      i,
      e.QUOTE_STRING_MODE,
      s,
      u,
      o
    ]
  };
}
function GE(e) {
  const t = e.regex, n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, a = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, l = e.inherit(a, {
    begin: /\(/,
    end: /\)/
  }), o = e.inherit(e.APOS_STRING_MODE, { className: "string" }), s = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }), u = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          a,
          s,
          o,
          l,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  a,
                  l,
                  s,
                  o
                ]
              }
            ]
          }
        ]
      },
      e.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              s
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [u],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [u],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: t.concat(
          /</,
          t.lookahead(t.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            t.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: u
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: t.concat(
          /<\//,
          t.lookahead(t.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function VE(e) {
  const t = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      // added brackets support 
      { begin: /\w[\w :()\./-]*:(?=[ \t]|$)/ },
      {
        // double quoted keys - with brackets
        begin: /"\w[\w :()\./-]*":(?=[ \t]|$)/
      },
      {
        // single quoted keys - with brackets
        begin: /'\w[\w :()\./-]*':(?=[ \t]|$)/
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, a = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      e.BACKSLASH_ESCAPE,
      i
    ]
  }, l = e.inherit(a, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), d = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, h = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: t,
    relevance: 0
  }, p = {
    begin: /\{/,
    end: /\}/,
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, g = {
    begin: "\\[",
    end: "\\]",
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, w = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    e.HASH_COMMENT_MODE,
    {
      beginKeywords: t,
      keywords: { literal: t }
    },
    d,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: e.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    p,
    g,
    a
  ], S = [...w];
  return S.pop(), S.push(l), h.contains = S, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: w
  };
}
const WE = {
  arduino: Nk,
  bash: Ak,
  c: Ck,
  cpp: Mk,
  csharp: Ok,
  css: Uk,
  diff: $k,
  go: Hk,
  graphql: qk,
  ini: Gk,
  java: Vk,
  javascript: Xk,
  json: Zk,
  kotlin: Jk,
  less: oE,
  lua: sE,
  makefile: uE,
  markdown: cE,
  objectivec: dE,
  perl: fE,
  php: hE,
  "php-template": pE,
  plaintext: mE,
  python: gE,
  "python-repl": vE,
  r: yE,
  ruby: bE,
  rust: wE,
  scss: CE,
  shell: ME,
  sql: OE,
  swift: FE,
  typescript: $E,
  vbnet: HE,
  wasm: qE,
  xml: GE,
  yaml: VE
};
function _2(e) {
  return e instanceof Map ? e.clear = e.delete = e.set = function() {
    throw new Error("map is read-only");
  } : e instanceof Set && (e.add = e.clear = e.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((t) => {
    const n = e[t], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && _2(n);
  }), e;
}
class Ah {
  /**
   * @param {CompiledMode} mode
   */
  constructor(t) {
    t.data === void 0 && (t.data = {}), this.data = t.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function T2(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function dr(e, ...t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in e)
    n[r] = e[r];
  return t.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const KE = "</span>", Ch = (e) => !!e.scope, YE = (e, { prefix: t }) => {
  if (e.startsWith("language:"))
    return e.replace("language:", "language-");
  if (e.includes(".")) {
    const n = e.split(".");
    return [
      `${t}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${t}${e}`;
};
class jE {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(t, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, t.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(t) {
    this.buffer += T2(t);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(t) {
    if (!Ch(t)) return;
    const n = YE(
      t.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(t) {
    Ch(t) && (this.buffer += KE);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(t) {
    this.buffer += `<span class="${t}">`;
  }
}
const Mh = (e = {}) => {
  const t = { children: [] };
  return Object.assign(t, e), t;
};
class wd {
  constructor() {
    this.rootNode = Mh(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(t) {
    this.top.children.push(t);
  }
  /** @param {string} scope */
  openNode(t) {
    const n = Mh({ scope: t });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(t) {
    return this.constructor._walk(t, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(t, n) {
    return typeof n == "string" ? t.addText(n) : n.children && (t.openNode(n), n.children.forEach((r) => this._walk(t, r)), t.closeNode(n)), t;
  }
  /**
   * @param {Node} node
   */
  static _collapse(t) {
    typeof t != "string" && t.children && (t.children.every((n) => typeof n == "string") ? t.children = [t.children.join("")] : t.children.forEach((n) => {
      wd._collapse(n);
    }));
  }
}
class XE extends wd {
  /**
   * @param {*} options
   */
  constructor(t) {
    super(), this.options = t;
  }
  /**
   * @param {string} text
   */
  addText(t) {
    t !== "" && this.add(t);
  }
  /** @param {string} scope */
  startScope(t) {
    this.openNode(t);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(t, n) {
    const r = t.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new jE(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function ja(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function N2(e) {
  return ni("(?=", e, ")");
}
function ZE(e) {
  return ni("(?:", e, ")*");
}
function QE(e) {
  return ni("(?:", e, ")?");
}
function ni(...e) {
  return e.map((n) => ja(n)).join("");
}
function JE(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function xd(...e) {
  return "(" + (JE(e).capture ? "" : "?:") + e.map((r) => ja(r)).join("|") + ")";
}
function A2(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1;
}
function eS(e, t) {
  const n = e && e.exec(t);
  return n && n.index === 0;
}
const tS = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function kd(e, { joinWith: t }) {
  let n = 0;
  return e.map((r) => {
    n += 1;
    const i = n;
    let a = ja(r), l = "";
    for (; a.length > 0; ) {
      const o = tS.exec(a);
      if (!o) {
        l += a;
        break;
      }
      l += a.substring(0, o.index), a = a.substring(o.index + o[0].length), o[0][0] === "\\" && o[1] ? l += "\\" + String(Number(o[1]) + i) : (l += o[0], o[0] === "(" && n++);
    }
    return l;
  }).map((r) => `(${r})`).join(t);
}
const nS = /\b\B/, C2 = "[a-zA-Z]\\w*", Ed = "[a-zA-Z_]\\w*", M2 = "\\b\\d+(\\.\\d+)?", O2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", R2 = "\\b(0b[01]+)", rS = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", iS = (e = {}) => {
  const t = /^#![ ]*\//;
  return e.binary && (e.begin = ni(
    t,
    /.*\b/,
    e.binary,
    /\b.*/
  )), dr({
    scope: "meta",
    begin: t,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, e);
}, Xa = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, aS = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Xa]
}, lS = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Xa]
}, oS = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, ws = function(e, t, n = {}) {
  const r = dr(
    {
      scope: "comment",
      begin: e,
      end: t,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = xd(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: ni(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, sS = ws("//", "$"), uS = ws("/\\*", "\\*/"), cS = ws("#", "$"), dS = {
  scope: "number",
  begin: M2,
  relevance: 0
}, fS = {
  scope: "number",
  begin: O2,
  relevance: 0
}, hS = {
  scope: "number",
  begin: R2,
  relevance: 0
}, pS = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    Xa,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [Xa]
    }
  ]
}, mS = {
  scope: "title",
  begin: C2,
  relevance: 0
}, gS = {
  scope: "title",
  begin: Ed,
  relevance: 0
}, vS = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Ed,
  relevance: 0
}, yS = function(e) {
  return Object.assign(
    e,
    {
      /** @type {ModeCallback} */
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1];
      },
      /** @type {ModeCallback} */
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch();
      }
    }
  );
};
var Gl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: aS,
  BACKSLASH_ESCAPE: Xa,
  BINARY_NUMBER_MODE: hS,
  BINARY_NUMBER_RE: R2,
  COMMENT: ws,
  C_BLOCK_COMMENT_MODE: uS,
  C_LINE_COMMENT_MODE: sS,
  C_NUMBER_MODE: fS,
  C_NUMBER_RE: O2,
  END_SAME_AS_BEGIN: yS,
  HASH_COMMENT_MODE: cS,
  IDENT_RE: C2,
  MATCH_NOTHING_RE: nS,
  METHOD_GUARD: vS,
  NUMBER_MODE: dS,
  NUMBER_RE: M2,
  PHRASAL_WORDS_MODE: oS,
  QUOTE_STRING_MODE: lS,
  REGEXP_MODE: pS,
  RE_STARTERS_RE: rS,
  SHEBANG: iS,
  TITLE_MODE: mS,
  UNDERSCORE_IDENT_RE: Ed,
  UNDERSCORE_TITLE_MODE: gS
});
function bS(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch();
}
function wS(e, t) {
  e.className !== void 0 && (e.scope = e.className, delete e.className);
}
function xS(e, t) {
  t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = bS, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, e.relevance === void 0 && (e.relevance = 0));
}
function kS(e, t) {
  Array.isArray(e.illegal) && (e.illegal = xd(...e.illegal));
}
function ES(e, t) {
  if (e.match) {
    if (e.begin || e.end) throw new Error("begin & end are not supported with match");
    e.begin = e.match, delete e.match;
  }
}
function SS(e, t) {
  e.relevance === void 0 && (e.relevance = 1);
}
const _S = (e, t) => {
  if (!e.beforeMatch) return;
  if (e.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, e);
  Object.keys(e).forEach((r) => {
    delete e[r];
  }), e.keywords = n.keywords, e.begin = ni(n.beforeMatch, N2(n.begin)), e.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, e.relevance = 0, delete n.beforeMatch;
}, TS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], NS = "keyword";
function I2(e, t, n = NS) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof e == "string" ? i(n, e.split(" ")) : Array.isArray(e) ? i(n, e) : Object.keys(e).forEach(function(a) {
    Object.assign(
      r,
      I2(e[a], t, a)
    );
  }), r;
  function i(a, l) {
    t && (l = l.map((o) => o.toLowerCase())), l.forEach(function(o) {
      const s = o.split("|");
      r[s[0]] = [a, AS(s[0], s[1])];
    });
  }
}
function AS(e, t) {
  return t ? Number(t) : CS(e) ? 0 : 1;
}
function CS(e) {
  return TS.includes(e.toLowerCase());
}
const Oh = {}, Gr = (e) => {
  console.error(e);
}, Rh = (e, ...t) => {
  console.log(`WARN: ${e}`, ...t);
}, si = (e, t) => {
  Oh[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), Oh[`${e}/${t}`] = !0);
}, Go = new Error();
function D2(e, t, { key: n }) {
  let r = 0;
  const i = e[n], a = {}, l = {};
  for (let o = 1; o <= t.length; o++)
    l[o + r] = i[o], a[o + r] = !0, r += A2(t[o - 1]);
  e[n] = l, e[n]._emit = a, e[n]._multi = !0;
}
function MS(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw Gr("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Go;
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw Gr("beginScope must be object"), Go;
    D2(e, e.begin, { key: "beginScope" }), e.begin = kd(e.begin, { joinWith: "" });
  }
}
function OS(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw Gr("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Go;
    if (typeof e.endScope != "object" || e.endScope === null)
      throw Gr("endScope must be object"), Go;
    D2(e, e.end, { key: "endScope" }), e.end = kd(e.end, { joinWith: "" });
  }
}
function RS(e) {
  e.scope && typeof e.scope == "object" && e.scope !== null && (e.beginScope = e.scope, delete e.scope);
}
function IS(e) {
  RS(e), typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }), typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }), MS(e), OS(e);
}
function DS(e) {
  function t(l, o) {
    return new RegExp(
      ja(l),
      "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (o ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(o, s) {
      s.position = this.position++, this.matchIndexes[this.matchAt] = s, this.regexes.push([s, o]), this.matchAt += A2(o) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const o = this.regexes.map((s) => s[1]);
      this.matcherRe = t(kd(o, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(o) {
      this.matcherRe.lastIndex = this.lastIndex;
      const s = this.matcherRe.exec(o);
      if (!s)
        return null;
      const u = s.findIndex((d, h) => h > 0 && d !== void 0), c = this.matchIndexes[u];
      return s.splice(0, u), Object.assign(s, c);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(o) {
      if (this.multiRegexes[o]) return this.multiRegexes[o];
      const s = new n();
      return this.rules.slice(o).forEach(([u, c]) => s.addRule(u, c)), s.compile(), this.multiRegexes[o] = s, s;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(o, s) {
      this.rules.push([o, s]), s.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(o) {
      const s = this.getMatcher(this.regexIndex);
      s.lastIndex = this.lastIndex;
      let u = s.exec(o);
      if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
        const c = this.getMatcher(0);
        c.lastIndex = this.lastIndex + 1, u = c.exec(o);
      }
      return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
    }
  }
  function i(l) {
    const o = new r();
    return l.contains.forEach((s) => o.addRule(s.begin, { rule: s, type: "begin" })), l.terminatorEnd && o.addRule(l.terminatorEnd, { type: "end" }), l.illegal && o.addRule(l.illegal, { type: "illegal" }), o;
  }
  function a(l, o) {
    const s = (
      /** @type CompiledMode */
      l
    );
    if (l.isCompiled) return s;
    [
      wS,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      ES,
      IS,
      _S
    ].forEach((c) => c(l, o)), e.compilerExtensions.forEach((c) => c(l, o)), l.__beforeBegin = null, [
      xS,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      kS,
      // default to 1 relevance if not specified
      SS
    ].forEach((c) => c(l, o)), l.isCompiled = !0;
    let u = null;
    return typeof l.keywords == "object" && l.keywords.$pattern && (l.keywords = Object.assign({}, l.keywords), u = l.keywords.$pattern, delete l.keywords.$pattern), u = u || /\w+/, l.keywords && (l.keywords = I2(l.keywords, e.case_insensitive)), s.keywordPatternRe = t(u, !0), o && (l.begin || (l.begin = /\B|\b/), s.beginRe = t(s.begin), !l.end && !l.endsWithParent && (l.end = /\B|\b/), l.end && (s.endRe = t(s.end)), s.terminatorEnd = ja(s.end) || "", l.endsWithParent && o.terminatorEnd && (s.terminatorEnd += (l.end ? "|" : "") + o.terminatorEnd)), l.illegal && (s.illegalRe = t(
      /** @type {RegExp | string} */
      l.illegal
    )), l.contains || (l.contains = []), l.contains = [].concat(...l.contains.map(function(c) {
      return zS(c === "self" ? l : c);
    })), l.contains.forEach(function(c) {
      a(
        /** @type Mode */
        c,
        s
      );
    }), l.starts && a(l.starts, o), s.matcher = i(s), s;
  }
  if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return e.classNameAliases = dr(e.classNameAliases || {}), a(
    /** @type Mode */
    e
  );
}
function z2(e) {
  return e ? e.endsWithParent || z2(e.starts) : !1;
}
function zS(e) {
  return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map(function(t) {
    return dr(e, { variants: null }, t);
  })), e.cachedVariants ? e.cachedVariants : z2(e) ? dr(e, { starts: e.starts ? dr(e.starts) : null }) : Object.isFrozen(e) ? dr(e) : e;
}
var LS = "11.10.0";
class PS extends Error {
  constructor(t, n) {
    super(t), this.name = "HTMLInjectionError", this.html = n;
  }
}
const T0 = T2, Ih = dr, Dh = Symbol("nomatch"), BS = 7, L2 = function(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const a = "Could not find the language '{}', did you forget to load/include a language module?", l = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let o = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: XE
  };
  function s(B) {
    return o.noHighlightRe.test(B);
  }
  function u(B) {
    let I = B.className + " ";
    I += B.parentNode ? B.parentNode.className : "";
    const $ = o.languageDetectRe.exec(I);
    if ($) {
      const E = U($[1]);
      return E || (Rh(a.replace("{}", $[1])), Rh("Falling back to no-highlight mode for this block.", B)), E ? $[1] : "no-highlight";
    }
    return I.split(/\s+/).find((E) => s(E) || U(E));
  }
  function c(B, I, $) {
    let E = "", Z = "";
    typeof I == "object" ? (E = B, $ = I.ignoreIllegals, Z = I.language) : (si("10.7.0", "highlight(lang, code, ...args) has been deprecated."), si("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), Z = B, E = I), $ === void 0 && ($ = !0);
    const ee = {
      code: E,
      language: Z
    };
    re("before:highlight", ee);
    const A = ee.result ? ee.result : d(ee.language, ee.code, $);
    return A.code = ee.code, re("after:highlight", A), A;
  }
  function d(B, I, $, E) {
    const Z = /* @__PURE__ */ Object.create(null);
    function ee(L, q) {
      return L.keywords[q];
    }
    function A() {
      if (!de.keywords) {
        Je.addText(Ae);
        return;
      }
      let L = 0;
      de.keywordPatternRe.lastIndex = 0;
      let q = de.keywordPatternRe.exec(Ae), Q = "";
      for (; q; ) {
        Q += Ae.substring(L, q.index);
        const oe = Ge.case_insensitive ? q[0].toLowerCase() : q[0], Te = ee(de, oe);
        if (Te) {
          const [at, on] = Te;
          if (Je.addText(Q), Q = "", Z[oe] = (Z[oe] || 0) + 1, Z[oe] <= BS && (ri += on), at.startsWith("_"))
            Q += q[0];
          else {
            const Rr = Ge.classNameAliases[at] || at;
            he(q[0], Rr);
          }
        } else
          Q += q[0];
        L = de.keywordPatternRe.lastIndex, q = de.keywordPatternRe.exec(Ae);
      }
      Q += Ae.substring(L), Je.addText(Q);
    }
    function Se() {
      if (Ae === "") return;
      let L = null;
      if (typeof de.subLanguage == "string") {
        if (!t[de.subLanguage]) {
          Je.addText(Ae);
          return;
        }
        L = d(de.subLanguage, Ae, !0, ji[de.subLanguage]), ji[de.subLanguage] = /** @type {CompiledMode} */
        L._top;
      } else
        L = p(Ae, de.subLanguage.length ? de.subLanguage : null);
      de.relevance > 0 && (ri += L.relevance), Je.__addSublanguage(L._emitter, L.language);
    }
    function xe() {
      de.subLanguage != null ? Se() : A(), Ae = "";
    }
    function he(L, q) {
      L !== "" && (Je.startScope(q), Je.addText(L), Je.endScope());
    }
    function qe(L, q) {
      let Q = 1;
      const oe = q.length - 1;
      for (; Q <= oe; ) {
        if (!L._emit[Q]) {
          Q++;
          continue;
        }
        const Te = Ge.classNameAliases[L[Q]] || L[Q], at = q[Q];
        Te ? he(at, Te) : (Ae = at, A(), Ae = ""), Q++;
      }
    }
    function Ke(L, q) {
      return L.scope && typeof L.scope == "string" && Je.openNode(Ge.classNameAliases[L.scope] || L.scope), L.beginScope && (L.beginScope._wrap ? (he(Ae, Ge.classNameAliases[L.beginScope._wrap] || L.beginScope._wrap), Ae = "") : L.beginScope._multi && (qe(L.beginScope, q), Ae = "")), de = Object.create(L, { parent: { value: de } }), de;
    }
    function ut(L, q, Q) {
      let oe = eS(L.endRe, Q);
      if (oe) {
        if (L["on:end"]) {
          const Te = new Ah(L);
          L["on:end"](q, Te), Te.isMatchIgnored && (oe = !1);
        }
        if (oe) {
          for (; L.endsParent && L.parent; )
            L = L.parent;
          return L;
        }
      }
      if (L.endsWithParent)
        return ut(L.parent, q, Q);
    }
    function gt(L) {
      return de.matcher.regexIndex === 0 ? (Ae += L[0], 1) : (F = !0, 0);
    }
    function vn(L) {
      const q = L[0], Q = L.rule, oe = new Ah(Q), Te = [Q.__beforeBegin, Q["on:begin"]];
      for (const at of Te)
        if (at && (at(L, oe), oe.isMatchIgnored))
          return gt(q);
      return Q.skip ? Ae += q : (Q.excludeBegin && (Ae += q), xe(), !Q.returnBegin && !Q.excludeBegin && (Ae = q)), Ke(Q, L), Q.returnBegin ? 0 : q.length;
    }
    function Mr(L) {
      const q = L[0], Q = I.substring(L.index), oe = ut(de, L, Q);
      if (!oe)
        return Dh;
      const Te = de;
      de.endScope && de.endScope._wrap ? (xe(), he(q, de.endScope._wrap)) : de.endScope && de.endScope._multi ? (xe(), qe(de.endScope, L)) : Te.skip ? Ae += q : (Te.returnEnd || Te.excludeEnd || (Ae += q), xe(), Te.excludeEnd && (Ae = q));
      do
        de.scope && Je.closeNode(), !de.skip && !de.subLanguage && (ri += de.relevance), de = de.parent;
      while (de !== oe.parent);
      return oe.starts && Ke(oe.starts, L), Te.returnEnd ? 0 : q.length;
    }
    function Or() {
      const L = [];
      for (let q = de; q !== Ge; q = q.parent)
        q.scope && L.unshift(q.scope);
      L.forEach((q) => Je.openNode(q));
    }
    let ye = {};
    function zt(L, q) {
      const Q = q && q[0];
      if (Ae += L, Q == null)
        return xe(), 0;
      if (ye.type === "begin" && q.type === "end" && ye.index === q.index && Q === "") {
        if (Ae += I.slice(q.index, q.index + 1), !i) {
          const oe = new Error(`0 width match regex (${B})`);
          throw oe.languageName = B, oe.badRule = ye.rule, oe;
        }
        return 1;
      }
      if (ye = q, q.type === "begin")
        return vn(q);
      if (q.type === "illegal" && !$) {
        const oe = new Error('Illegal lexeme "' + Q + '" for mode "' + (de.scope || "<unnamed>") + '"');
        throw oe.mode = de, oe;
      } else if (q.type === "end") {
        const oe = Mr(q);
        if (oe !== Dh)
          return oe;
      }
      if (q.type === "illegal" && Q === "")
        return 1;
      if (Xi > 1e5 && Xi > q.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return Ae += Q, Q.length;
    }
    const Ge = U(B);
    if (!Ge)
      throw Gr(a.replace("{}", B)), new Error('Unknown language: "' + B + '"');
    const yn = DS(Ge);
    let bn = "", de = E || yn;
    const ji = {}, Je = new o.__emitter(o);
    Or();
    let Ae = "", ri = 0, In = 0, Xi = 0, F = !1;
    try {
      if (Ge.__emitTokens)
        Ge.__emitTokens(I, Je);
      else {
        for (de.matcher.considerAll(); ; ) {
          Xi++, F ? F = !1 : de.matcher.considerAll(), de.matcher.lastIndex = In;
          const L = de.matcher.exec(I);
          if (!L) break;
          const q = I.substring(In, L.index), Q = zt(q, L);
          In = L.index + Q;
        }
        zt(I.substring(In));
      }
      return Je.finalize(), bn = Je.toHTML(), {
        language: B,
        value: bn,
        relevance: ri,
        illegal: !1,
        _emitter: Je,
        _top: de
      };
    } catch (L) {
      if (L.message && L.message.includes("Illegal"))
        return {
          language: B,
          value: T0(I),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: L.message,
            index: In,
            context: I.slice(In - 100, In + 100),
            mode: L.mode,
            resultSoFar: bn
          },
          _emitter: Je
        };
      if (i)
        return {
          language: B,
          value: T0(I),
          illegal: !1,
          relevance: 0,
          errorRaised: L,
          _emitter: Je,
          _top: de
        };
      throw L;
    }
  }
  function h(B) {
    const I = {
      value: T0(B),
      illegal: !1,
      relevance: 0,
      _top: l,
      _emitter: new o.__emitter(o)
    };
    return I._emitter.addText(B), I;
  }
  function p(B, I) {
    I = I || o.languages || Object.keys(t);
    const $ = h(B), E = I.filter(U).filter(V).map(
      (xe) => d(xe, B, !1)
    );
    E.unshift($);
    const Z = E.sort((xe, he) => {
      if (xe.relevance !== he.relevance) return he.relevance - xe.relevance;
      if (xe.language && he.language) {
        if (U(xe.language).supersetOf === he.language)
          return 1;
        if (U(he.language).supersetOf === xe.language)
          return -1;
      }
      return 0;
    }), [ee, A] = Z, Se = ee;
    return Se.secondBest = A, Se;
  }
  function g(B, I, $) {
    const E = I && n[I] || $;
    B.classList.add("hljs"), B.classList.add(`language-${E}`);
  }
  function w(B) {
    let I = null;
    const $ = u(B);
    if (s($)) return;
    if (re(
      "before:highlightElement",
      { el: B, language: $ }
    ), B.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", B);
      return;
    }
    if (B.children.length > 0 && (o.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(B)), o.throwUnescapedHTML))
      throw new PS(
        "One of your code blocks includes unescaped HTML.",
        B.innerHTML
      );
    I = B;
    const E = I.textContent, Z = $ ? c(E, { language: $, ignoreIllegals: !0 }) : p(E);
    B.innerHTML = Z.value, B.dataset.highlighted = "yes", g(B, $, Z.language), B.result = {
      language: Z.language,
      // TODO: remove with version 11.0
      re: Z.relevance,
      relevance: Z.relevance
    }, Z.secondBest && (B.secondBest = {
      language: Z.secondBest.language,
      relevance: Z.secondBest.relevance
    }), re("after:highlightElement", { el: B, result: Z, text: E });
  }
  function S(B) {
    o = Ih(o, B);
  }
  const y = () => {
    C(), si("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function v() {
    C(), si("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let x = !1;
  function C() {
    if (document.readyState === "loading") {
      x = !0;
      return;
    }
    document.querySelectorAll(o.cssSelector).forEach(w);
  }
  function R() {
    x && C();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", R, !1);
  function T(B, I) {
    let $ = null;
    try {
      $ = I(e);
    } catch (E) {
      if (Gr("Language definition for '{}' could not be registered.".replace("{}", B)), i)
        Gr(E);
      else
        throw E;
      $ = l;
    }
    $.name || ($.name = B), t[B] = $, $.rawDefinition = I.bind(null, e), $.aliases && O($.aliases, { languageName: B });
  }
  function z(B) {
    delete t[B];
    for (const I of Object.keys(n))
      n[I] === B && delete n[I];
  }
  function P() {
    return Object.keys(t);
  }
  function U(B) {
    return B = (B || "").toLowerCase(), t[B] || t[n[B]];
  }
  function O(B, { languageName: I }) {
    typeof B == "string" && (B = [B]), B.forEach(($) => {
      n[$.toLowerCase()] = I;
    });
  }
  function V(B) {
    const I = U(B);
    return I && !I.disableAutodetect;
  }
  function K(B) {
    B["before:highlightBlock"] && !B["before:highlightElement"] && (B["before:highlightElement"] = (I) => {
      B["before:highlightBlock"](
        Object.assign({ block: I.el }, I)
      );
    }), B["after:highlightBlock"] && !B["after:highlightElement"] && (B["after:highlightElement"] = (I) => {
      B["after:highlightBlock"](
        Object.assign({ block: I.el }, I)
      );
    });
  }
  function ae(B) {
    K(B), r.push(B);
  }
  function ie(B) {
    const I = r.indexOf(B);
    I !== -1 && r.splice(I, 1);
  }
  function re(B, I) {
    const $ = B;
    r.forEach(function(E) {
      E[$] && E[$](I);
    });
  }
  function ge(B) {
    return si("10.7.0", "highlightBlock will be removed entirely in v12.0"), si("10.7.0", "Please use highlightElement now."), w(B);
  }
  Object.assign(e, {
    highlight: c,
    highlightAuto: p,
    highlightAll: C,
    highlightElement: w,
    // TODO: Remove with v12 API
    highlightBlock: ge,
    configure: S,
    initHighlighting: y,
    initHighlightingOnLoad: v,
    registerLanguage: T,
    unregisterLanguage: z,
    listLanguages: P,
    getLanguage: U,
    registerAliases: O,
    autoDetection: V,
    inherit: Ih,
    addPlugin: ae,
    removePlugin: ie
  }), e.debugMode = function() {
    i = !1;
  }, e.safeMode = function() {
    i = !0;
  }, e.versionString = LS, e.regex = {
    concat: ni,
    lookahead: N2,
    either: xd,
    optional: QE,
    anyNumberOfTimes: ZE
  };
  for (const B in Gl)
    typeof Gl[B] == "object" && _2(Gl[B]);
  return Object.assign(e, Gl), e;
}, $i = L2({});
$i.newInstance = () => L2({});
var FS = $i;
$i.HighlightJS = $i;
$i.default = $i;
const US = /* @__PURE__ */ Lh(FS), zh = {}, $S = "hljs-";
function HS(e) {
  const t = US.newInstance();
  return e && a(e), {
    highlight: n,
    highlightAuto: r,
    listLanguages: i,
    register: a,
    registerAlias: l,
    registered: o
  };
  function n(s, u, c) {
    const d = c || zh, h = typeof d.prefix == "string" ? d.prefix : $S;
    if (!t.getLanguage(s))
      throw new Error("Unknown language: `" + s + "` is not registered");
    t.configure({ __emitter: qS, classPrefix: h });
    const p = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      t.highlight(u, { ignoreIllegals: !0, language: s })
    );
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised
      });
    const g = p._emitter.root, w = (
      /** @type {RootData} */
      g.data
    );
    return w.language = p.language, w.relevance = p.relevance, g;
  }
  function r(s, u) {
    const d = (u || zh).subset || i();
    let h = -1, p = 0, g;
    for (; ++h < d.length; ) {
      const w = d[h];
      if (!t.getLanguage(w)) continue;
      const S = n(w, s, u);
      S.data && S.data.relevance !== void 0 && S.data.relevance > p && (p = S.data.relevance, g = S);
    }
    return g || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: p }
    };
  }
  function i() {
    return t.listLanguages();
  }
  function a(s, u) {
    if (typeof s == "string")
      t.registerLanguage(s, u);
    else {
      let c;
      for (c in s)
        Object.hasOwn(s, c) && t.registerLanguage(c, s[c]);
    }
  }
  function l(s, u) {
    if (typeof s == "string")
      t.registerAliases(
        // Note: copy needed because hljs doesnt accept readonly arrays yet.
        typeof u == "string" ? u : [...u],
        { languageName: s }
      );
    else {
      let c;
      for (c in s)
        if (Object.hasOwn(s, c)) {
          const d = s[c];
          t.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof d == "string" ? d : [...d],
            { languageName: c }
          );
        }
    }
  }
  function o(s) {
    return !!t.getLanguage(s);
  }
}
class qS {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(t) {
    this.options = t, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(t) {
    if (t === "") return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += t : n.children.push({ type: "text", value: t });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(t) {
    this.openNode(String(t));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(t, n) {
    const r = this.stack[this.stack.length - 1], i = (
      /** @type {Array<ElementContent>} */
      t.root.children
    );
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(t) {
    const n = this, r = t.split(".").map(function(l, o) {
      return o ? l + "_".repeat(o) : n.options.classPrefix + l;
    }), i = this.stack[this.stack.length - 1], a = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    i.children.push(a), this.stack.push(a);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const GS = {};
function VS(e) {
  const t = e || GS, n = t.aliases, r = t.detect || !1, i = t.languages || WE, a = t.plainText, l = t.prefix, o = t.subset;
  let s = "hljs";
  const u = HS(i);
  if (n && u.registerAlias(n), l) {
    const c = l.indexOf("-");
    s = c > -1 ? l.slice(0, c) : l;
  }
  return function(c, d) {
    fs(c, "element", function(h, p, g) {
      if (h.tagName !== "code" || !g || g.type !== "element" || g.tagName !== "pre")
        return;
      const w = WS(h);
      if (w === !1 || !w && !r || w && a && a.includes(w))
        return;
      Array.isArray(h.properties.className) || (h.properties.className = []), h.properties.className.includes(s) || h.properties.className.unshift(s);
      let S;
      try {
        S = w ? u.highlight(w, Uu(g), { prefix: l }) : u.highlightAuto(Uu(g), { prefix: l, subset: o });
      } catch (y) {
        const v = (
          /** @type {Error} */
          y
        );
        if (w && /Unknown language/.test(v.message)) {
          d.message(
            "Cannot highlight as `" + w + "`, its not registered",
            {
              ancestors: [g, h],
              cause: v,
              place: h.position,
              ruleId: "missing-language",
              source: "rehype-highlight"
            }
          );
          return;
        }
        throw v;
      }
      !w && S.data && S.data.language && h.properties.className.push("language-" + S.data.language), S.children.length > 0 && (h.children = /** @type {Array<ElementContent>} */
      S.children);
    });
  };
}
function WS(e) {
  const t = e.properties.className;
  let n = -1;
  if (!Array.isArray(t))
    return;
  let r;
  for (; ++n < t.length; ) {
    const i = String(t[n]);
    if (i === "no-highlight" || i === "nohighlight")
      return !1;
    !r && i.slice(0, 5) === "lang-" && (r = i.slice(5)), !r && i.slice(0, 9) === "language-" && (r = i.slice(9));
  }
  return r;
}
function KS({
  content: e,
  className: t = ""
}) {
  return /* @__PURE__ */ xt.createElement("div", { className: `markdown-display ${t}` }, /* @__PURE__ */ xt.createElement(
    M8,
    {
      remarkPlugins: [U9, Yx],
      rehypePlugins: [_k, VS],
      components: {
        // Custom component rendering
        a: ({ node: n, ...r }) => /* @__PURE__ */ xt.createElement("a", { ...r, target: "_blank", rel: "noopener noreferrer" }),
        img: ({ node: n, ...r }) => /* @__PURE__ */ xt.createElement("img", { ...r, loading: "lazy" })
      }
    },
    e
  ));
}
function YS() {
  const [e] = zf("content"), [t] = zf("class_name");
  return /* @__PURE__ */ xt.createElement(
    KS,
    {
      content: e,
      className: t
    }
  );
}
const jS = {
  render: a6(YS)
};
export {
  jS as default
};
